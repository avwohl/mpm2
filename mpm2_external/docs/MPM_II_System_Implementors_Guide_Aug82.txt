~

-------

MP/M JITM
OPERATING SYSTEM
SYSTEM
GUIDE

[ij] DIGITAL RESEARCH™

M

MP/M Ir
Operating System
SYSTEM IMPLEMENTOR'S GUIDE

Copyright

~

1981

Digital Research
P.O. Box 579
801 Lighthouse Avenue
Pacific Grove, C~ 93950
(408)

649-3896

TWX 910 360 5001

All Rights Reserved

COPYRIGHT
Copyright
1981 by Digital Research. All rights
reserved.
No part of this publication may be
reproduced, transmitted, transcribed, stored in a
retrieval system, or translated into any language or
computer language, in any form or by any means,
electronic, mechanical, magnetic, optical, chemical,
manual or otherwise, without the prior written
permission of Digi tal Research, Post Office Box 579,
Pacific Grove, California, 93950.

DISCLAIMER
Digital Research makes no representations or
warranties with respect to the contents hereof and
spec ifically disclaims any implied warranties of
merchantability or fitness for any particular
purpose.
Further, Digi tal Research reserves the
right to revise this publication and to make changes
from time to time in the content hereof without
obligation of Digital Research to notify any person
of such revision or changes.

TRADEMARKS
CP/M is a registered trademark of Digital Research.
CP INET, MP 1M II, LINK-80, RMAC and PL/I-80 are
trademarks of Digital Research. Z80 is a registered
trademark of Zilog, Inc.

The "MP/M II SYSTEM GUIDE" was prepared using the
Digital Research TEX-80 Text Formatter and printed
in the United States of America by Commercial Press
I Monterey.

************************************

*
*

First Edition: September 1981
Second Edition: August 1982

*
*

************************************

Foreword
MP/M II T .M .
is a multi-user operating system for any
microcomputer based on an 8-bit Zilog Z80® or Intel 8080 or 8085
microprocessor.
Typically, an lViP/M II system resides in
approximately 27k.
16k of the operating system must reside in
common memory.
The version of MP/M II that Digital Research ships cannot be
directly booted on any specific hardware configuration. However,
all the hardware-dependent code is isolated in specific subroutines
that can be modified by the u~er.
This document describes the procedures required to implement
MP/M II for a custom hardware environment. At minimum, the custom
hardware environment must include an 8080, 8085, or Z-80 processor,
32K bytes of random access memory (RAM), a system console, and a
real~time clock.
This manual assumes the reader is familiar with
the following Digital Research publications:
• MP/M II User's Guide
• MP/M II Programmer's Guide
It is also assumed that the reader has already implemented a
CP/M 2 Basic Input Output System (BIOS), preferrably on the target
MP/M II machine.

iii

Table of Contents
1

MP/M II Alteration Procedure

1.1

preparation for MP/M II Alteration

1.2

Customizing the MPMLDR

1.3

Customizing the XIOS

1.4

Debugging an XIOS

. .

····

1

·····
····
····

'1.5.1 Preparing an MP/M II Boot Using SYSGEN
1.5.2 Custom Generation of an MP/M II Boot

6

·

····

7
8

· · · · 11

1.6

Loading MPM.SYS Wi thout the MPMLDR

1.7

Digital Research Copyright and Trudemark

1.8

Disk Organization

11

..·····..······

12

The MP/M II BIOS

···

· · · · · · · · 15

2.1

MP/M II BIOS Overview

2.2

BIOS De,vice Characteristics and Entry Points

2.3

BIOS Disk Definition Tables

2.3.1
2.3.2

3

3
4

1.5 . Directly Booting MP/M II

2

2

······

···..

Externa,l Procedu,re Access

2.5

Blocking and Deblocking Algorighms

2.6

Common Memory Portion of the BNKXIOS

24
24
29

Disk Parameter Table Format
The DISKDEF Macro Library

2.4

16

· ···
· ·· ·

33
36

· · · 37

The MP/M II XIOS

..
3.2 MP/M XIOS Entry Points .
···
3.3 Interrupt Service Routines
··..
3.4 Time Base Management
··..
3.1

MP/M II XIOS Overview

v

· · · · · · 39
39

· · · 43
44
. · ···

Table of Contents
(continued)
4

MP/M II System File Components
4.1

System Data • •

47

4.2

Customized XIOS •

48

4.3

BDOS

48

4 .. 3.1
4.3.2

5

RESBDOS
BNKBDOS

48
49

4.4

XDOS

49

4.5

Resident System Processes.

49

4.6

Banked Resident System Processes

49

System Generation
5.1

GENSYS Operation

51

5.2

System Gener2tion Parameters

52

5.2.1 Defaults • . • • . • • •
5.2.2 Top Page of Opersting System .
5.2.3 Number of System Consoles
5.2.4 Number of Printers • • • •
5.2.5 Breakpoint RST • • • • • •
5.2.6 System Call User Stacks
5.2.7 Z80 CPU
• • • • • • . • •
5.2.8 Number of Ticks / Second • • • • • •
• • . • . •
5.2.9 System Disk
. ~ .•
5.2.10 Temporary File Drive .
5.2.11 Maximum Locked Records / Process
5.2.12 Total Locked Records / System
5.2.13 Maximum Open Files / Process .
5.2.14 Total Open Files / System
5.2.15 Bank Switched Memory • • • • •
5.2.16 Number of User Memory Segments •
5.2.17 Common Memory Base Page
5.2.18 Dayfile Logging at Console • • • • • .
5.2.19 Accept System Data Page Entries
5.2.20 Select Resident System Processes •
5.2.21 Memory Segment Table • . . . •
5.2.22 Accept MemolY Segment Table

52
53
53
53
53
53
54
54
54
54
54
54
55
55
55
55
55
55
56
56
56
57

GENSYS Execution

57

r:
?
::>.J

vi

Table of Contents
( continued)
6

MP/M Loader
6.1

MP/M Loader Operation and Display • •

59

6.2

MPMLDR Execution

60

Appendixes
A

B
C

.... ····
Sector Deblocking Algorithms .
····
Sample MP/M II Loader BIOS
· ·· ·
Disk Definition lVlacro

D

Simple XIOS Source Listing

E

Sample MP/M II Banked XIOS

61

....

67
75
77

.

vii

. ..

. . . . . 97

Section 1
MP1M II Alteration Procedure
The MP/M II operating system is designed so that the user can
alter a specific set of subroutines that define the hardware
operating environment. By modifying these subroutines, the user can
produce Gl diskette that operates with any IBrvI-3740 format compatible
diskette subsystem and other peripheral devices.
Although the standard MP/M II is shipped on single-density
floppy disks, field-alteration features c:;llow the user to adapt MP/M
II to a wide variety of disk subsystems, including single drive
minidisks and high-capacity "hard disk" systems.
To achieve device independence, MP/M II has isolated (']11
hardware-dependent code into an XIOS module. The user can rewrite
the distributed version of the XIOS to customize the interface
between the remaining MP/M II modules and the user's own hardware
system.
The user can also rewrite the distributed version of the
LDRBIOS, which loads the MP/M II system from disk.
There are actually two versions of the XIOS:
the RESXIOS for
non-banked systems, and the BNKXIOS for banked memory systems. To
avoid repeating both names for each reference, the term XIOS refers
to both versions.
1.1

Preparation for MP/M II Alteration

To s impl i fy the al te rat ion process, th i s document assumes tha t
a CP/M 2 BIOS has already been implemented on the target MP/M II
mach ine.
You must implement both the BIOS as well as the XIOS
because the MP/M II loader uses a CP/M 2 BIOS to load the MP/M II
system. Once loaded, MP/M II uses the XIOS and not the BIOS.
The
CP/M 2 BIOS used by the MP/M II loader is called the LDRBIOS.
Another good reason for implementing CP/M 2 on the target MP/M
machine is that debugging your XIOS is simpler when you can run SID
or DDT under a CP/M 2 system.

All Information Presented Here is Proprietary to Digital Research
1

MP/M II System Guide

1.2

1.2

Customizing the MPMLDR

Customizing the MPMLDR

To customize the MPMLDR, you must integrate a LDRBIOS for your
hardware configuration into the MPMLDR.COM file supplied on the
distribution disk. The required LDRBIOS can be simply a version of
your CP/M 2 BIOS, altered as described below and renamed to LDRBIOS.
The customized LDRBIOS must have an ORG of 1700H, perform
console output functions, and be able to read data from a single
disk drive.
'rhe first call MPMLDR makes to LDRBIOS is SELDSK:
select disk.
If your system has devices that require
initialization, place initialization code or perhaps a call to the
LDRBIOS cold start at the beginning of the SELDSK handler.
The LDRBIOS need only perform the opErations described above.
Other functions can be deleted to conserve space. There is only one
restriction on memory space for LDRBIOS: it cannot extend above the
base of the MPM.SYS which it is loading.
(GENSYS Lists MP/M II's
base address in its load map.) However, if you plan to boot MP/M II
from floppy disks, you will encounter a LDRBIOS upper address limit
of lAOOH in order to place the MPMLDR.COM file on two system tracks.
Test LbRBIOS completely to ensure that it properly performs
console character output and disk reads. Be especially careful that
no disk write operations occur accidently during read operations,
and check that the proper track and sectors are addressed on all
reads.
Use the following steps to integrate a custom LDRBIOS into the
MPMLDR.COM:

1.

Obtain access to a CP/M system and prepare a LDRBIOS.HEX file.

2.

Read the MPMLDR.COM file into memory using either DDT or SID.

A)DDT MPMLDR.COM
DDT VERS 2.0
NEX r!, PC
1780 0100
3.

Using the input command (I), specify that the LDRBIOS.HEX file
is to be read in and then read (R) in the file. This operation
overlays the LDRBIOS portion of the MP/M loader.

--ILDRBIOS .HEX
-R
NEXT PC
lAOO 0000

All Information Presented Here is Proprietary to Digital Research
2

1.2

MP/M II System Guide

4.

Customizing the MPMLDR

Exit the debugger, returning to the CCP by executing a jump to
location zero.

-GO
5.

Write the updated memory image onto a disk file. Use the CP/M
SAVE command to write the updated memory image onto a disk
file.
In the example below, the X in front of the filename
simply designates an experimental version, and preserves the
original.
A>SAVE 26 XMPMLDR.COM

6.

Test XMPMLDR.COM and then rename it to MPMLDR.COM.

1.3

Customizing the XIOS

As you are tailoring MP/M II for your computer system, your new
XIOS will require software development and tEsting.
'rwo sample
XIOS's are listed in the Appendixes, and can be used as models for
the customized package.
The XIOS entry points, including both basic and extended, are
described in Sections 2 and 3.
These sections, along with the
appendixes, give you the information you need to write your XIOS.
Your initial implementation of an XIOS should use polled I/O without
any interrupts.
This initial system can run without a clock
interrupt.
Implement interrupts only after your XIOS is fully
developed and tested.
Follow the procedure below to pr-epare
RESXIOS.SPR file from your customized XIOS:
1.

a

BNKXIOS.SPR

or

Assemble your BNKXIOS .ASM or RESXIOS .ASIVl wi th RMAC or- any other'
assembler that can generate a file of type REL in Microsoft's
relocatable object file format.

A>RMAC BNKXIOS
2.

Link the BNKXIOS.REL or RESXIOS.REL file using the Digital
Research LINK-80 to produce the BNKXIOS.SPR or RESXIOS.SPR
file.

A>LINK BNKXIOS [OS]

All Information Presented Here is Proprietary to Digital Research
3

MP/M II System Guide
1.4

1.4

De~ugging

an XIOS

Debugging an XIOS

You can debug an XIOS or a resident system process with DDT or
SID running under CP/M. The debugging technique is outlined in the
following steps:

1.

Determine the amount of memory available to MP/M II when the
debugger and CP/M are resident.
Do this by' loading the
debugger and then listing the jump instruction at location
OOOSH. This jump is to the base of the debugger.
A)DDT
DDT VERS 2.0
-L5
0005

2.

JMP'C800

Using GENSYS running under CP/M, generate" an MPM.SYS file that
specifies the top of memory determined by the previous step,
allowing at least 256 bytes for a patch area.
Top page of operating system (xx)

? C6

Also while executing GENSYS, specify a breakpoint restart
number different from the one used by the CP/M debugger you
plan to use.
The suggested MP/M II restart is #6;
however,
any restart from ~tl to :ltG, can usually be used.
The CP/M
debuggers normally use restart #7.
Breakpoint RST (xx)

? 6

Note: If you are alsodeuugging a resident system .process, be
sure to select it for fnclusion in MPM.SYS during GENSYS
execution.

3.

Using CP/M, load the MPMLDR.COM file into memory.
A)DDT MPMLDR.COM
DDT VERS 2.0
NEXT PC
IAOO 0100

All Information Presented Here is Proprietary to Digital Research
4

MP/M II System Guide
4.

1.4

Debugging an XIOS

Place the char acters n$B n into locations OOSOH and OOSEH of the
default FCB based at OOSCH. This operation can be done with
the I command:
-1$8

The "$B" causes the MPMLOR to break after loading the MPM.SYS
file. You can specify the breakpoint restart to be executed by
the MPMLDR by adding one additional character to the string in
the fourth position of the default FCB.
-1$86

In the example above, a restart #6 is to be executed by the
MPMLDR when loading of the MPM.SYS file is completed. If no
restart number is supplied, the default restart is #7.
Remember, the restart number at the location SFH is the CP/M
debugger restart number, not the MP/M debugger restart.
5.

Execute the MPMLOR.COM program by entering a G command:
-G

6.

Af ter the G command, the MP/M I I loader loads the MP/M I I
operating system into memory and displays a memory map. You
may obtain a hard copy of your load map during the GENSYS
operation by entering a Tp before executing GEN5YS.

7.

If you are debugging an XIOS, note the address of the
BNKXrOS.SPR or RESXIOS.SPR memory segment. You must also note
the address of SYSTEM. OAT.
If you are debugging a resident
system process, note its address as well. The debugger lists
actual addresses at the console. If your hard copy listing of
the XIOS or RSP starts at zero, you must add the base address
listed in the GENSYS load map to each address on the listing to
make the 1 isting reflect actual addresses. Or you can assemble
the code again with an additional ORG statement specifying the
base listed in the load map, although the object code generated
by this assembly is unusable.

8.

Using the X command, determine the MP/M II beginning execution
address. The address is the first location past the current
program counter.

-x

. . . . .. . .. ..... . . . . . . . .. P == 09F2 •••••

In the example shown above, MP/M II execution starts at address
09F3H, which is the first instruction after the restart at
09F2H.

All Information Presented Here is Proprietary to Digital Research
5

MP/M II System Guide

9.

1.4

Debugging an XIOS

Begin execution of MP/M II using the G command, specifying the
start address and any breakpoints you need in your code. The
actual memory address can be determined by entering an H
command to add the code segment base address given in the
memory map to the relative displacement address in your XIOS or
resident system process listing.
The following example shows how to set a breakpoint in an XIOS
at the list subroutine entry point given in the memory map:

XIOSJMP TBL

C300H

OlOOH

-G9F3,C30F
09F3H is the beginning MP/M II execution address and C30FH is
the XIOS jump vector address of the list subroutine.

10. At this point, you have MP/M II running with CP/M and the CP/M
debugger also in memory. Because interrupts are left enabled
during operation of the CP/M debugger, ensure that interruptdriven code does not execute through a breakpoint.
Because the CP/M debugger operates with interrupts left
enabled, it is a somewhat difficult task to debug an interruptdriven console handler.
Approach this problem by leaving
console #0 in a polled mode while debugging the other consoles
in an interrupt-driven mode. Once this is done, very little,
if any, debugging is required to adapt the interrupt-driven
code from another console to console #0.
It is further
recommended that you maintain a debug version of your XlOS that
has polled I/O for console #0.
Otherwise, it is not possible
to run the CP/M debugger underneath the MP/M II system because
the CP/M debugger cannot get any console input, as all of it is
sent to the MP/M interrupt-driven console #0 handler.

1.5

Directly Booting MP/M II

In systems where MP/M II is to be booted directly at cold start
rather than loaded and run as a transient program under CP/M, the
customized MPMLDR.COM file and cold start loader can be placed on
the first two tracks of a eight-inch floppy disk.
If a CP/M
SYSGEN.COM program is available, use it to write the MPMLDR.COM file
on the first two tracks. If a SYSGEN.COM program is not available,
or if SYSGEN.COM does not work because a different media such as a
five-inch floppy disk or hard disk is to be used, the user must
write two programs:
a simple memory loader, called GETSYS, which
brings the MP/M loader into memory, and a program called PUTSYS,
which places the MPlVILDR on the first two tracks of a disk.
If you
have implemented a CP/M 2 BIOS, you have probably already prepared
GETSYS and PUTSYS.
All Information Presented Here is Proprietary to Digital Research
6

MP/M II System Guide

1.5

Directly Booting MP/M II

You can use either the SID or DDT debugger instead of writing a
GETSYS program.
This method is shown in the following example,
which also uses SYSGEN in place of PUTSYS. Sample skeletal GETSYS·
and PUTSYS programs are given in Section 1.5.3.
To load and run the MP/M system automatically, you must also
supply a cold start loader that loads the MP/M loader into memory
from the first two tracks of the diskette.
Modify the CP/M 2 cold
start loader in the following manner:
change the load address to
OIOOH and the execution address to OIOOH.
The following bootstrap techniques are specific to the Intel
MDS-800,
which has a boot ROM that loads the first track into
location 3000H.
However, the steps shown can be applied in a
general sense to any custom hardware environment.
1.5.1

Preparing an MP/M II Boot Using SYSGEN

If a SYSGEN program is available, use the following steps to
prepare a diskette that cold starts MP/M II:

1.

Prepare the MPMLDR.COM file by integrating your custom LDRBIOS.
as described in Section 1.2.
Test the MPMLDR.COM and verify
that it operates properly.

2.

Execute either DDT or SID.
A)DDT
DDT VERS 2.0

3.

Using the input command (I), specify that the MPMLDR.HEX file
is to be read in and then read (R) in the file with an offset
of 880H bytes.
-IMPMLDR.HEX
-R880
NEXT PC
2480 0100

4.

Using the I command, specify that the BOOT. HEX file is to be
read in and then read in the file with an offset that loads the
boot into memory at 900H.
You can use the H command to
calculate the offset.
-H900 3000
3900 D900
-IBOOT.HEX
-RD900
NEXT PC
2480 0000

All Information Presented Here is Proprietary to Digital Research
7

MP/M II System Guide
5.

1.5

Directly Booting MP/M It

Return to the CP/M console command processor (CCP) by jumping
to location zero.
-GO

6.

Use the SYSGEN program to write the new cold start loader onto
the first two tracks of the diskette.
A>SYSGEN
SYSGEN VER 2.0
SOURCE DRIVE NAME (OR RETURN TO SKIP) <cr>
DESTINATION DRIVE NAME (OR RETURN TO REBOOT)B
DESTINATION ON B, THEN TYPE RETURN<cr>
FUNCTION COMPLETE

1.5.2

Custom Generation of an MP/M II Boot

If a SYSGEN program is not available, then use the following
steps to prepare a diskette that cold starts MP/M II:
1.

Write a GETSYS program that reads the custom MPMLDR.COM file
into location 3380H and the cold start loader (or boot program)
into location 3300H. Code GETSYS so that it starts at location
100H (base of the TPA).
Or, as in the previous example, you can use either SID or DDT
to perform this function instead of writing a GETSYS program.

2.

Run the GETSYS program using an initialized MP/M II diskette to
see if GETSYS loads the MP/M loader starting at 3380H (th~
operating system actually starts 128 bytes later at 3400H).

3.

Write a PUTSYS program that writes memory starting at 3380H
back onto the first two tracks of the diskette.
The PUTSYS
program should be located at 200H.

4.

Test the PUTSYS program using a blank, uninitia1ized diskette
by writing a portion of memory to the first two tracks; clear
memory and read it back. Test PUTSYS completely, because you
will use this program to alter the MP/M II system diskette.

5.

Use PUTSYS to place the MP/M II loader and cold start loader
onto the first two tracks of a blank diskette.

All information Presented Here is Proprietary to Digital Research

8

MP/M II System Guide
1.5.3

1.5

Directly Booting MP/M II

Sample GETSYS and PUTSYS Programs

The following programs provide a framework for the GETSYS and
PUTSYS program. You must insert WRITESEC subroutines to write the
specific sectors.
;

GETSYS PROGRAM REGISTER
A
B
C
DE
HL
SP

START: LXI
LXI
MVI
RDTRK:
MVI
RDSEC:
CALL
LXI
DAD
INR
MOV
CPI
JC
;

SP,3380H
H, 3380H
B, 0

C,l
READSEC
D,128
D
C

A,C
27
RDSEC

READ TRACKS 0 AND 1 TO MEMORY AT 33808
USE
(SCRATCH REGISTER)
TRACK COUNT (0, 1)
SECTOR COUNT (1,2, ••• ,26)
(SCRATCH REGISTER PAIR)
LOAD ADDRESS
SET TO STACK ADDRESS
;SET STACK POINTER TO SCRATCH AREA
iSET BASE LOAD ADDRESS
iSTART WITH TRACK 0
iREAD NEXT TRACK (INITIALLY 0)
iREAD STARTING WITH SECTOR 1
iREAD NEXT SECTOR
;USER-SUPPLIED SUBROUTINE
;MOVE LOAD ADDRESS TO NEXT 1/2 PAGE
;HL = HL + 128
iSECTOR = SECTOR + 1
;CHECK FOR END OF TRACK
;CARRY GENERATED IF SECTOR

< 27

ARRIVE HERE AT END OF TRACK, MOVE TO NEXT TRACK
INR
B
MOV
A,B
;TEST FOR LAST TRACK
CPI
2
JC
RDTRK
iCARRY GENERATED IF TRACK < 2
ARRIVE HERE AT END OF LOAD, HALT FOR NOW
HLT

i
USER-SUPPLIED SUBROUTINE TO READ THE DISK
READSEC:
ENTER WITH TRACK NUMBER IN REGISTER S,
SECTOR NUMBER IN REGISTER C, AND
ADDRESS TO FILL IN HL

PUSH
PUSH

B
H

iSAVE SAND C REGISTERS
;SAVE HL REGISTERS

perform disk read at this point, branch to
label START if an error occurs
POP
POP
RET
END

H

B

iRECOVER HL
;RECOVER BAND C REGISTERS
iBACK TO MAIN PROGRAM

START

All Information Presented Here is Proprietary to Digital Research
9

MP/M II System Guide

;
i
i

i

J~

i
i

Directly Booting MP/~ II

PUTSYS PROGRAM - WRITE TRACKS 0 AND 1 FROM MEMORY AT 33808
REGIS'rER
USE
(SCRATCH REGISTER)
A
TRACK COUNT CO, 1)
B
SECTOR COUNT (1,2, ••. ,26)
C
(SCRATCH REGISTER PAIR)
DE
LOAD ADDRESS
HL
SET TO STACK ADDRESS
SP

START: LXI
LXI
MVI
WRTRK:
MVI
WRSEC:
CALL
LXI
DAD
INR
MOV
CPI
i

1.5

SP,3380H
H, 3380H
B, 0

C,l
WRITESEC
D,128
D
C

A,C
27
WRSEC

iSET STACK POINTER TO SCRATCH AREA
iSET BASE LOAD ADDRESS
iSTART WITH TRACK 0
iWRITE NEXT TRACK (INITIALLY 0)
iWRITE STARTING WITH SECTOR 1
iWRITE NEXT SECTOR
iUSER-SUPPLIED SUBROUTINE
iMOVE LOAD ADDRESS TO NEXT 1/2 PAGE
iHL = HL + 128
iSECTOR = SECTOR + 1
iCHECK FOR END OF TRACK
iCARRY GENERATED IF SECTOR < 27

ARRIVE HERE AT END OF TRACK, MOVE TO NEXT TRACK
INR
B'
MOV
A,B
iTEST FOR LAST TRACK
CPI
2
JC
WRTRK
iCARRY GENERATED IF TRACK < 2
ARRIVE HERE AT END OF LOAD, HALT FOR NOW
HLT

i
USER-SUPPLIED SUBROUTINE TO WRITE THE DISK
WRITESEC:
ENTER WITH TRACK NUMBER IN REGISTER B,
SECTOR NUMBER IN REGISTER C, AND
ADDRESS TO FILL IN HL

PUSH
PUSH

B
H

iSAVE BAND C REGISTERS
iSAVE HL REGISTERS

perform disk write at this point, branch to
label START if an error occurs
POP.
POP
RET

H
B

END

START

iRECOVER HL
iRECOVER BAND C REGISTERS
;BACK TO MAIN PROGRAM

All Information Presented Here is Proprietary to Digital Research

10

MP/M II
1.6

System Guide

1.6

Loading MPM.SYS Without the MPMLDR

Loading MPM.SYS Without the MPMLDR

The MPM.SYS file is a fully-relocated absolute file that can be
moved directly into memory and then executed without the use of the
MPMLDR.
The format of the MPM.SYS file is in Table 1-1, below.
Table 1-1.
Record

MPM.SYS File Format

I

Contents

+------...1.-----------------------------------4
1

First 128 bytes of the SYSDAT page

2

Second 128 bytes of the SYSDAT page

3-n

MP/M operating system in reverse order,
top down.

The actual base of the SYSDAT page in memory is specified in
byte 000 of the SYSDAT page.
The rest of MP/M II operating system
is to be located directly below the SYSDAT page.
In Table 1-1, n
represents the number of records. Bytes 120-121 of the SYSDAT page
contain the value of n. The execution address of MP/M is specifed
by the page address given in byte all of the SYSDAT page.
MPMLDR could load the MPM.SYS file into memory and then move it
to its destination specified in the SYSDAT page (byte 000). Or the
user could write a separate custom program to produce a directly
loadable memory image from the MPM.SYS file.

1.7

Digital Research Copyright and Trademark

Read your MP/M II Licenping Agreement;
responsibilities when copying the MP/M
copyright notice:

it specifies your legal
II system.
Place the

Copyright ~ 1981 Digital Research
on the label of each copy you make of your customized MP/M II
diskette. Digital Research also requests that you place your MP/M
II serial number on the label of any copies you make. Remember also
that MP/M II is a trademark of Digital Research, and the first time
it appears on a disk label or in a document, it should be followed
by a trademark symbol, as shown below:
MP/M II

™

All Information Presented Here is Propriet&ry to Digital Research
11

MP/M II System Guide

1.8

1.8

Disk Organization

Disk Organization

This,section describes MP/M II sector allocation for a system
in which the MPMLDR resides on the first two tracks of a single
density diskette.
The first sector (see Table 1-2) contains an
optional software boot section. Disk controllers are often set up
to bring track 0, sector 1 into memory at a specific location, often
location OOOOH.
The program in this sector, called BOOT, is
responsible for bringing the remaining sectors into memory starting
at location OIOOH.
If your controller does not have a built-in
sector load, you can ignore the program in track 0, sector 1, and
begin the load from track a sector 2 to location OIOOH.
As an exa~ple, the Intel MDS-800 hardware cold start loader
brings track 0, sector 1 into absolute address 3000H.
When this
sector is loaded, control transfers to location 3000H, where the
bootstrap operation commences by loading the remainder"of track 0,
and all of track 1 into memory, starting at OIOOB.
Remember that
this bootstrap loader is of little use in a non-MDS environment, but
it is useful to examine it because you will have to duplicate some
of its actions in your own cold start loader.

All Information Presented Here is Proprietary to Digital Research
12

MP/M II System Guide

1.8

Table 1-2.
Track#
00
00

,

..

00
00
01

I

Sector#
01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
01
02
03
04

as

,

1
01
n

"
"

06
07
08
09
10
11
12
13
14
15
16
17
18
19
20
21
22
23

I

MP/M II Sample Disk Organization
Pagett
00

"
01

"

02

"

03

"
04

..
..

05
06

.

07

"

08

"

09

..
10
..
11
..
12
..
13

..
14
..
15

"
16

"

17

"

18

"

19

"

20

II

21

"
22

"

23

"

"

24

24

"

25
26

"

01

Disk Organization

25

I

Memory Address
(boot address)
0100B
0180H
0200H
0280H
0300H
0380H
0400H
0480H
0500B
0580H
0600H
0680H
0700H
0780H
0800H
0880H
0900H
0980H
OAOOH
OA80H
OBOOH
OB80H
OCOOH
OC80H
ODOOH
OD80H
OEOOH
OE80H
OFOOH
OF80H
1000H
1080H
1100H
1180H
1200H
1280H
1300H
1380B
1400H
1480H
1500B
1580B
1600H
1680H
1700H
1780H
1800H
1880H
1900H
1980B
1AOOH

1

MP/M Module name

Cold Start Loader
MPMLDR

MPMLDR
LDRBDOS

,

LDRBDOS
LDRBIOS

"

"
"

"
"

LDRBIOS

All Information Presented Here is Proprietary to Digital Research
13

Section 2

MP/M II BIOS
2.1

MP/M II BIOS Overview

The IV{P/M I I BDOS and XDOS access per ipheral. devices as
"logical" devices within the BIOS and XIOS.
To customize MP/M II
for a specific hardware environment, the system implementor must
prepare the BIOS and XIOS subroutines upon which the BDOS and XDOS
depend. This section describes how the logical portions of MP/M II
expect to interact with the BIOS; Section 3 describes the same for
the XIOS.
The BDOS and XDOS call BIOS subroutines through a "jump vector"
located at the base of the BIOS as shown below and in Appendixes D
and E. The jump vector is a sequence of 26 jump instructions that
send prog ra'ffi contra 1 to the ind i vidual BIOS subrout ines.
All
subroutines must be represented in the jump vector during MP/M II
system regeneration. However, certain subroutines may be "empty",
that is, they may contain only a single RET instruction.
The BIOS jump vector must take the form shown below.
The
individual jump addresses for each entry point are listed to the
left. Note that the XIOS entry points immediately follow the last
BIOS entry point.
BIOS+OOH
BIOS+03H
BIOS+06H
B10S+09H
BIOS+OCH
BIOS+OFH
BIOS+12H
8108+15H
8IOS+18H
BIOS+1BH
8IOS+1EH
B10S+21H
BIOS+24H
810S+27H
BIOS+2AH
8I08+2DH
BIOS+30H

JMP COMMONBASE
JMP WBOOT
JMP CONST
JfvlP CONIN
JMP CONOUT
JMP LIST
JMP PUNCH
JMP READER
JMP HOME
JMP SELDSK
JMP SETTRK
JMP SE'rSEC
JMP SETDMA
JMP READ
JMP WRITE
JMP LISTST
JMP SECTRAN

COMMONBASE, TERMINATE PROCESS
WARM BOOT, TERMINATE PROCESS
CHECK FOR CONSOLE CHAR READY
READ CONSOLE CHARACTE~ IN
WRITE CONSOLE CHARACTER OUT
WRITE LIST CHARACTER OUT
not used by MP/M II
not used by MP/M I I
MOVE TO TRACK 00
SELECT DISK DRIVE
SET TRACK NUMBER
; SET SECTOR NUMBER
SET DMA ADDRESS
READ SELECTED SECTOR
WRITE SELECTED SECTOR
not used by MP/M II
SECTOR TRANSLATE SUBROUTINE

Each jump address corresponds to a particular subroutine that
performs a specific function, as outlined in Section 2.3.
Three
major functions are performed by calls to the jump table: process
termination from COMMONBASE and WBOOT; simple character I/O from
CONST, CONIN, CONOUT, and LIST;
and disk I/O from HOME, SELDSK,
SE'rTRK, SETSEC, SETDMA, READ, WRI'rE, and SECTRAN.

All Information Presented Here is Proprietary to Digital Research
15

MP/M II System Guide

2.1

MP/M II BIOS Overview

All simple character I/O operations are assumed to be performed
in ASCII, upper and lower case, with high-order (parity) bit set to
zero.
The BDOS depends on only the CONST, CONIN, and CONOU'l'
subroutines for simple character I/O.
An ASCII iz (IAH) i~
interpreted as an end-of-file condition for an input device.

2.2

BIOS Device Characteristics and Entry Points

The BIOS generally supports three types of devices: consoles,
list devices and disks.
The characteristics of each device are
described below.
Consoles a re the pr inc ipal interact i ve dev ices that communicate
with operators, and are accessed through CONST, CONIN, and CONOUT~
Typically, consoles are devices such as CRTs or teletypes. MP/M It
supports up to 16 console or character I/O devices.
List Devices, if they exist on your system, are usually hardcopy devices, such as printers or teletypes. MP/M II supports up to
16 list devices.
Disks are accessed through a sequence of calls on the various
disk I/O subroutines. These subroutines set up the disk number to
access, the track and sector on a particular disk, and the direct
memory access (D~A) address involved in the I/O operation. Aftet
all these parameters have been set up, a call is made to the READ or
WRITE function to perform the actual I/O operation. Note that there
is often a single call to SELDSK to select a disk drive, followed by
a nu~ber of read or write operations to the selected disk before
selecting another drive for subsequent operations. Similarly, there
may be a single call to set the DMA address, followed by several
calls which read or write from the selected DMA address before the
DMA address is changed. The track and sector subroutines are always
called before the READ or WRITE operations are performed.
Note that the READ and WRITE routines should perfor"m several
retries (10 is standard) before reporting an error condition to the
BDOS.
If the error condition is returned to the BDOS, it reportS
the error to the user. The HOME subroutine mayor may not actuallY
per for m the t r a c k 0 0 see k, de pen ding up 0 n yo u r con t roll e r
characteristics; the important point is that track 00 has been
selected for the next operation, and is often treated in exactlyth~
same manner as SETTRK with a parameter of 00.
Table 2-1 outlines the exact responsibilities
subroutine entered through the BIOS jump table.

of

each

All Information Presented Here is Proprietary to Digital Research

16

MP/M II System Guide

2.2

Table 2-1.
Subroutine

I

BIOS Device Characteristics

BIOS Subroutine Summary
Description

COMMONBASE

The COMMONBASE entry point establishes the
base address of the portion of the XIOS
that must reside in common memory.
The
COMMONBASE entry point also contains a jump
vector that enables the XIOS to access user
and system memory bank switching
subroutines, the MP/M II dispatcher, the
XDOS and BDOS, the SYSDAT page, and
COLDSTART.
The effect of a call to
COMMONBASE is to terminate the calling
pro g ram.
0 the r e x t e rna I pro c e d u res
accessed by COMMONBASE are described in
Section 2.4.

WBODT

The WBOOT subroutine performs an XDOS
te rminate process call, terminating the
calling process.
'I'he subroutine must be
re-entrant and this entry point must be
above the COMMONBASE label.

CONST

The CONST subroutine obtains the status of
the console device specified by register D
and returns OFFH in register A if a
character is ready to read, or OOH in
register A if no console characters are
ready. This subroutine must be re-entrant
a nd this entry po int must be above the
COMMONBASE label.

CONIN

The CONIN subroutine reads the next
character from the console device specified
by register D into register A, and sets the
parity bit (high-order bit) to zero. If no
console character is ready, CONIN waits
until a character is typed before
returning.
This subroutine must be reentrant and this entry point must be above
the COMMONBASE label.

All Information Presented Here is Proprietary to Digital Research

17

MP/M II System Guide

2.2

(continued)

Table 2-1.
Subroutine

BIOS Device Characteristics

I

Description

CON OUT

The CONOUT subroutine sends the character
from register C to the console output
de vic e s p e c i fie d by reg i s t e rD.
Th e
character is in ASCII, with high-order
parity bit set to zero.
You may want to
include a delay on a line feed or carriage
return if your console device requires some
time interval at the end of the line (such
as a TI Silent 700 terminal). You can, if
you wish, filter out control characters
that cause your console device to react in
a strange way.
For example, a Tz causes
the Lear-Seigler terminal to clear the
screen, and could be f i]. tered out by
CONOUT. Th is subroutine must be roe-entrant
and this entry point must be above the
COMMONBASE label.

LIST

'rhe LIST subrout ine sends the character
from register C to the list output device
specified by register D. The character is
in ASCII with zero parity. This subroutine
must be re-entrant and this entry point
must be above the Co'MMONBASE label.

PUNCH

The punch device is not implemented under
MP/M II. The transfer vector position is
preserved to maintain CP/M compatibility.
Note that MP/M II supports up to 16
character I/O devices, any of which can be
a reader/punch.

READER

The reader device is not implemented under
MP/M II. See the note above for PUNCH.

HOME

The HOME subroutine returns the disk head
of the currently-selected disk to the track
00 position.
If your controller allows
access to the track 0 flag from the drive,
step the head until the track 0 flag is
detected.
If your controller does not
support this feature, you can translate the
HOME call into a calIon SETTRK wi th a
parameter of o.

All Information Presented Here is Proprietary to Digital Research
18

MP/M II System Guide

2.2

Table 2-1.
Subroutine
SELDSK

BIOS Device Characteristics

(continued)

I

Description
The SELDSK subroutine selects the disk
d r i ve g i ve n by reg i s t e r C for f u [' the r
operations, where register C contains 0 for
drive A, 1 for drive B, and so up to 15 for
drive P. On each disk select, SELDSK must
return in HL the base address of a 16-byte
a rea, called the Disk Parameter Header,
described in Section 2.3.
For standard
floppy disk drives, the contents of the
he a d e r a n d ass 0 cia ted tab 1 e s doe s no t
change, and thus the program segment
included in the sample XIOS performs this
operation automatically.
If there is an
attempt to select a non-existent drive,
SELDSK returns HL=OOOOH as an error
indicator.
On
entry to SELDSK, it is possible to
determine whether it is the first time the
specified disk has been selected. Register
E, bit 0 (least significant bit) is a zero
if the dr ive has not been proeviously
selected. This information is of interest
in systems that read configuration
information from the disk to set up. a
dynamic disk definition table.
Al though SELDSK must return the heade r
address on each call, it is advisable to
postpone the actual physical disk select
operation until an I/O function (read or
write) is actually performed.
This is
because disk selects often occur without
ultimately performing any disk I/O, and
many controllers unload the head of the
current disk before selecting the new
drive.
This unloading can cause an
excessive amount of noise and disk wear.
The first SELDSK subroutine call that MP/M
II makes is only for getting the DIRBUF
address and need not perform any actual
I/O.

All Information Presented Here is Proprietary to Digital Research

19

MP/M II System Guide

2.2

(continued)

Table 2-1.
Subrout ine

BIOS Device Characteristics

I

Description

SETTRK

For the SE'l"TRK subroutine, register BC
contains the track number for subsequent
disk accesses on the currently selected
drive. You can choose to seek the selected
track at this time, or delay the seek until
the next read or wri te actually occurs.
Register BC can take on values in the range
0-76 corresponding to valid track numbers
for standard floppy disk drives, and 065535 for non-standard disk subsystems.

SETSEC

For the SETSEC subroutine, register BC
contains the translated sector number for
subsequent disk accesses on the currently
selected drive (see SECTRAN, below).
You
can choose to send this information to the
controller at this point, or instead delay
sector selection until a read or write
operation occurs. Register BC can take on
values in the range 1-26 corresponding to
valid sector numbers for standard floppy
disk drives, and 0-65535 for non-standard
disk subsystems.

SETDMA

For the SET DMA sub r 0 uti n e , reg i s t e r BC
contains the DMA (disk memory access)
address for subsequent
read or write
operations. For example, if B = OOH and C
= 8 0 H when S E TD MA i sea 11 ed, the naIl
subsequent read operations read their data
into 80H through OFFH, and all subsequent
write operations get their data from 80H
through OFFH, until the next call to SETDMA
occurs. The initial DMA address is assumed
to be 80H (relative to the base of the
memory segment from which the call was
made).
Note that the controller need not
actually support di rect memory access. If,
for example, all data is received and sent
through I/O ports, the XIOS you construct
can use the 128 byte area starting at the
selected DMA address for the memory buffer
during subsequent read or write operations.
A special case of the SETDMA subroutine
occurs when the passed parameter in
reg i s t e r B C con t a ins a 0 F F F F H •
Th is
parameter indicates that the blocking
buffer, if it exists, must be flushed.

All Information Presented Here is Proprietary to Digital Research
20

MP/M II System Guide

2.2

(continued)

Table 2-1.
Subroutine

BIOS Device Characteristics

I

Description
Thus, a call to the SETDMA subroutine is
interpreted as a flush buffer call when a
parameter of OFFFFH is passed.
The BDOS
function to flush buffers is translated to
this form of a SETDMA subroutine call.
If
the flush buffer operation performed as a
result of the OFFFFH parameter is
successful a simple return should be
executed. However, if a disk error occurs
the current return address should be popped
from the stack and one of the following
error codes should be returned in the
register A:
1
2

READ

non-recoverable error
condition occurred
disk read/only

Assuming the drive has been selected, the
track has been set, the sector has been
set, and the DMA address has been
specified, the READ subroutine attempts to
read one sector based upon these
parameters, and returns the following error
codes in register A:

a
1

no errors occurred
non-recoverable error
condition occurred

If the value in register A is 0, then MP/M
I I ass urn e s t hat the dis k 0 per at ion was
completed properly.
If an error occurs,
however, the XIOS should attempt at least
10 retries to see if the error is
r e co v era b 1 e •
Wh en an err 0 r i s r e po r ted,
the BDOS prints the message "BDOS ERR ON x:
BAD SECTOR". Then, depending on the error
mode of the calling process, the calling
process is terminated or returned an error
code.
An additional parameter containing the
absolute record number for the disk read is
now passed by MP/M II on entry to the READ
subroutine.
The parameter is three bytes
in length, with the high-order byte in
register B and the low-order two bytes in
register DE. This parameter may be useful
in blocking/deblocking algorithms.

All Information Presented Here is Proprietary to Digital Research

21

MF/M II System Guide

. Subr.out ine

+------

I

2.2

BIOS Device Characteristics

(continued)

Table 2-1 •

Description
The BNKXIOS of MP/M II allows portions of
the XIOS to reside in bank-switched memory
(non- common) •
Th is reduces the common
memory requirements. The XIOS code for all
the disk operations including READ and
WRITE can reside in non-common memory with
one exception:
the code thC\t actually
performs the transfer of data into the DMA
address must reside in common memory. Two
additional entry points within the XIOS,
named SWTUSER and SWTSYS, enable switching
between the user's memory bank and the
system bank containing the BNKXIOS.
SWTUSER and SWTSYS are described in Section
2.4.
.

,

If you perform deblocking in your READ and
WRITE code, you must choose whether to
p I ace you r deb I 0 c kin g b u f fer i n c 0 mmo n
memory and then perform a single move into
the user's DMA, or to place your deblocking
buffer in non-common memory. If you choose
the latter, you must then perform an extra
move to first move the sector into common
memory and then another move into the
us e r 's DMA •
B10 c kin g and deb 10 c kin gar e
discussed in Section 2.5.
WRITE

The WRITE subroutine writes the data from the
cur rently selected DMA address to the cur rentl y
selected drive, track, and sector.
The data
should be marked as "non deleted data" to
maintain compatibility with other CP/M and MP/M
systems.
WRITE returns the followi ng error
codes in register A, as shown below:

o
I
2

no errors occurred
non-recoverable error condition
occurred
disk read/only

If the value in register A is 0, then MP/M II
assumes that the disk operation completed
properly.
If an error occurs, however, the
XIOS should attempt at least 10 retries to see
if the ~rror is recoverable. When an error is
reported, the BDOS prints the message "BDOS ERR
ON x:
BAD SECTOR".
Then, depend ing on the
error mode of the calling process, the calling
process is terminated or returned an error
code.
All Information Presented Here is proprietary to Digital
22

Rese~rch

MP/M II System Guide

2.2
Table 2-1.

Subroutine

BIOS Device Characteristics

(continued)

I

Description
On entry to the WRITE subroutine a
parameter is passed in the C register which
is intended for use by blocking/deblocking
algorithms. rrhis parameter is described in
Section 2.5 on blocking/deblocking.
An additional parameter containing the
absolute record number for the disk write
is now passed by MP/M lIon entry to the
WRITE subroutine.
The parameter is three
bytes in length, with the high-order byte
in register B and the low-order two bytes
in ,register DE.
This parameter can be
useful in blocking/deblocking algoritms.
See the previous section on disk READ for a
discussion of placing disk WRITE code in
bank-swi tched memory and deblocking in your
WRITE code.

LISTST

The LISTST subroutine returns the ready
status of the list device specified by
register D. The value 00 is returned in A
if the list device is not ready to accept a
character, and OFFH if a character can be
sent to the printer. Note that a 00 value
always suffices.
LISTST must be reentrant.
This entry point is maintained
solely for compatibility with CP/M and can
generally be omitted from the MP/M II XIOS
as none of the standard utilities use this
entry point.

SECTRAN

The SECTRAN subroutine performs logical
sector to physical sector translation and
can improve the overall response of MP/M
II.
Standard MP/M II systems are shipped
with a "skew factor" of 6, where six
physical sectors are skipped between each
logical read operation.
This skew factor
allows enough time between sectors for most
programs to load their buffers without
missing the next sector.

All Information Presented Here is Proprietary to Digital Research
23

MP/M II System Guide

Subroutine

I

2.2

BIOS Device Characteristics

(continued)

Table 2-1.

Description
For computer systems that use fast
processors, memory and disk subsystems, you
can change the skew factor to improve
overall response. Note, however, that you
should maintain a single-density IBMcompatible version of MP/M II for
information transfer into and out of your
computer system, using a skew factor of 6.
I n g e n era 1, S ECTRAN r e c e i v e s a l 0 g i cal
sector number in BC and a translate table
add ress in DE.
SECTRAN uses the sector
number as an index into the translate
table, and returns the resulting physical
sector number in HL. For standard systems,
the tables and indexing code are provided
in the XIOS and need not be changed.

2.3

BIOS Disk Definition Tables

This section presents the organization and construction of
tables within the BIOS that define the characteristics of a
particular disk system used with MP/M II.
These tables can be
either hand-coded or automatically generated using the DISKDEF
utility provided with MP/M II.
The elements of these tables are
presented below.

2.3.1

Disk Parameter Table Format

In general, each disk drive has an associated (16-byte) Disk
Parameter Header which both contains information about the disk
drive and provides a scratchpad area for certain BDOS operations.
The format of the Disk Parameter Header for each drive is shown
below.
Disk

Parameter

Header

XLT

0000

0000

0000

DIRBUE'

DPB

CSV

ALV

16b

16b

16b

16b

16b

16b

16b

16b

Each element is a word (16-bit) value.
The meaning of each Disk
Parameter Header (DPH) element is given in Table 2-2.

All Information Presented Here is 'Proprietary to Digital Research
24

MP/M II System Guide

Table 2-2.

Element

I

2.3

BIOS Disk Definition Tables

Disk Parameter Header Elements
Descr iption

XLT

Offset of the logical to physical translation vector,
if used for this particular drive, or the value OOOOH
if no sector translation takes place (i.e, the
physical and logical sector numbers are the same).
Disk drives with identical sector skew factors share
the same translate tables.

0000

Scratchpad values for use within the BDOS
value is unimportant).

DIRBUF

Offset of a 128 byte scratchpad area for directory
operations wi thin BDOS.
All DPHs address the same
scratchpad area.
The same DIRBUF is used by all
drives.

DPB

Offset of a disk parameter block for this drive.
Drives with identical disk characteristics address the
same disk parameter block.

CSV

Offset of a scratchpad area used for software check for
changed disks. This offset is different for each DPH.

ALV

Offset of a scratchpad area used by the BDOS to keep
disk storage allocation information.
This offset is
different for each DPH.

(initial

Given n disk drives, the DPHs are arranged in a table whose first
row of 16 bytes corresponds to drive 0, with the last row
corresponding to drive n-1.
The table thus appears as:
DPBASE
00

XLT 00

0000

0000

0000

DIRBUF DBP 00 CSV 00 ALV, 00

01

XLT 01

0000

0000

0000

DIRBUF DBP 01 CSV 01 ALV 01

n-1 XLTn-1

0000

0000

0000

DIRBUF DBPn-1 CSVn-1 ALVn-1

where the label DPBASE defines the offset of the DPH table relative
to the beginning of the operating system.
A responsibility of the SELDSK subroutine, defined in the
previous section, is to return the offset of the DPH from the
beginning of the operating system for the selected drive.
The
following sequence of operations returns the table offset, with a
OOOOH returned if the selected drive does not exist.

All Information Presented Here is Proprietary to Digital Research
25

MP/M II System Guide
NDISKS

EQU

2.3
4

BIOS Disk Definition Tables

;NUMBER OF DISK DRIVES

SELDSK:
;SELECT DISK N GIVEN BY C
H,OOOOH
LXI
;READY FOR ERR
MOV
A,C
CPI
NDISKS
;N BEYOND MAX DISKS?
RNC
;RETURN IF SO
;0 <= N < NDISKS
MOV
L,C
DAD
H
;READY FOR * 16
DAD
H
DAD
H
DAD
H
LXI
D,DPBASE
DAD
D
;DPBASE + N * 16
RET
The translation vectors (XLT 00 through XLTn-l) are located
elsewhere in the BIOS, and simply correspond one-for-one with the
logical sector numbers zero through the sector count-I.
The Disk
Parameter Block (DPB) for each drive is more complex. A particular
DPB, which is addressed by one or more DPHs, takes the general form:
SPT

BSH BLM EXM

DSM

DRM

ALO ALI

CKS

OFF

16b

8b

16b

16b

8b

16b

16b

8b

8b

8b

where each is a byte or word value, as shown by the "8b" or "16b"
indicator below the field.
The fields are defined in Table 2-3.

All Information Presented Here is Proprietary to Digital Research
26

MP/M II System Guide

2.3

Table 2-3.
Field

BIOS Disk Definition Tables

Disk Parameter Block Fields

I

Definition

SPT

is the total number of sectors per track.

BSH

is the data allocation block shift factor,
determined by the data block allocation size.

BLM

is the block mask which is also determined by the
data block allocation size.

EXM

is the extent mask, determined by the data block
allocation size and the number of disk blocks.

DSM

determines the total storage capacity of the disk
drive.

DRM

determines the total number of directory entries
which can be stored on this drive.

ALO,ALI

determine reserved directory blocks.

CKS

is the size of the directory check vector, a CKS of
8000H marks the drive as permanent with no
directory records checked.

OFF

is the number of reserved tracks at the beginning
of the (logical) disk.

Although these table values are produced automatically by DISKDEF,
it is worthwhile reviewing the derivation of each field so that the
values may be cross-checked when necessary. The values of BSH and
BLM determine (implicitly) the data allocation size BLS, which is
not an entry in the disk parameter block.
Given that you have
sele~ted a value for BLS, the values of BSH and BLM are shown in
Table 2-4 below, where all values are in decimal.
Table 2-4.

BSH and BLM Values for Selected BLS
BLS

1,024
2,048
4,096
8,192
16,384

I

BSH
3
4
5
6
7

I

BLM
7
15
31
63
127

The value of EXM depends upon both the BLS and whether the DSM value
is less than 256 or greater than 255, as shown in the following
table.

All Information Presented Here is Proprietary to Digital Research
27

2.3

MP/M II System Guide
Table 2-5.
BLS

BIOS'Disk Definition Tables

Maximum EXM Values

IDSM

<;:

256

I

o

1,024
2,048
4,096
8,192
16,384

DSM

> 255

N/A

o

1
3
7

1
3

15

7

The value of DSM is the maximum data block number supported by
this particular drive, measured in BLS units. The product BLS times
(DSM+l) is the total number of bytes held by the drive and, of
course, must be within the capacity of the physical disk, not
counting the reserved operating system tracks.
The DRM entry is one less than the total number of directory
entries, which can take on a 16-bit value.
The values of ALO and
ALl, however, are determined by DRM. The two values ALO and ALI can
together be considered a string of 16-bits, as shown below.
ALI

ALO

00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
where position 00 corresponds to the high-order bit of the byte
labeled ALO, and 15 corresponds to the low-order bit of the byte
labeled ALI. Each bit position reserves a data block for a number
of directory entries, thus allowing a total of 16 data blocks to be
assigned for dir~ctory entries (bits are assigned starting at 00 and
fill e d t 0 the rig h t un til po sit ion 15).
E a c h d ire c to rye n try
occupies 32 bytes, as shown in Table 2-6.
Table 2-6.

BLS and Number of Directory Entries

BLS
1,024
2,048
4,096
8,192
16,384

I

Directory Entries
32
64
128
256
512

times
times
times
times
times

#
=It

#
#
#

bits
bits
bits
bits
bits

Th us, i f DRM = 127 ( 128 d ire c tor yen t r i e s), and B LS = 10 24, the n
there are 32 directory entries per block, requiring 4 reserved
blocks.
In this case, the 4 high-order bits of ALO are set,
resulting in the values ALO = OFOH and ALI = OOH.

All Information Presented Here is Proprietary to Digital Research
28

MP/M II System Guide

2.3

BIOS Disk Definition Tables

The CKS value is determined as follows:
if the disk drive
media is removable, then CKS = (DRM+l)/4, where DRM is the last
directory entry number. If the media is fixed, then set CKS = 8000H
(no directory records are checked in this case and drive marked as
permanent) •
Finally, the OFF field determines the number of tracks which
are skipped at the beginning of the physical disk.
This value is
automatically added whenever SETTRK is called, and can be used as a
mechanism for skipping reserved operating system tracks, or for
partitioning a large disk into smaller segmented sections.
To complete the discussion of the OPB, recall that several DPHs
can address the same OPB if their drive characteristics are
identical. Further, the DPB can be dynamically changed when a new
drive is addressed by simply changing the pointer in the DPH since
the BOOS copies the DPB values to a local area whenever the SELDSK
function is invoked.
Returning back to the DPH for a particular drive, note that the
two address values CSV and ALV remain. Both addresses reference an
area of uninitialized memory following the BIOS. The areas must be
unique for each drive, and the size of each area is determined by
the values in the DPB.
The size of the area addressed by CSV is CKS bytes, which is
sufficient to hold the directory check information for this
particular drive.
If CKS = (DRM+l)/4, then you must reserve
(DRM+l)/4 bytes for directory check use. If CKS = 0, indicating no
checked directory entries, or CKS = 8000H, marking the drive as
permanent with no checked directory entries, then no storage is
reserved.
The size of the area addressed by ALV is determined by the
maximum number of data blocks allowed for this particular disk, and
is computed as (DSM/8)+1.

2.3.2

The DISKDEF Macro Library

A macro library called DISKOEF greatly simplifies the table
cons t ruc t ion process.
You must have access to the MAC macro
assembler or the RMAC relocatable macro assembler distributed with
MP/M II to use the DISKDEF facility. The macro library is included
with all MP/M II distribution disks.
A BIOS disk definition consists of the following sequence of
macro statements:

All Information Presented Here is Proprietary to Digital Research

29

MP/M II System Guide
MACLIB

DISKDEF

DISKDEF
DISKDEF

o , •••

DISKDEF

n-l

. ....
DISKS

.. . . .
ENDEF

2.3

BIOS Disk Definition Tables

n

1 , •••

where the MACLIB statement loads the DISKDEF.LIB file (on the same
disk as your BIOS) into MAC's internal tables. The DISKS macro call
follows, which specifies the number of drives to be configured with
your system, where n is an integer in the range 1 tol6.
A series
of DISKDEF macro calls then follow, which define the characteristics
of each logical disk, 0 through n-l (corresponding to logical drives
A through P). Note that the DISKS and DISKDEF macros generate the
in-line fixed data tables described in the previous section, and
thus must be placed in a non-executable portion of your BIOS,
typically directly following the BIOS jump vector.
The remaining portion of your BIOS is defined following the
DISKDEF macros, with the ENDEF macro call immediately preceding the
END statement.
The ENDEF (End of Diskdef) macro generates the
necessary uninitialized RAM areas that are located in memory above
your BIOS.
The form of the DISKDEF macro call is
DISKDEF

dn,fsc,lsc, [skf] ,bls,dks,dir,cks,ofs, [k16], [prm]

where
dn
fsc
lsc
skf
bls
dks
dir
cks
ofs
k16
prm

is the logical disk number, 0 to n-l
is the first physical sector number (0 or 1)
is the last sector number
is the optional sector skew factor
is the data allocation block size
is the total number of blocks on the drive.
is the number of directory entries
is the number of "checked" directory entries
is the track offset to logical track 00
is an optional 1.4 compatibility flag which
forces 16K/directory entry
is an optional flag which indicates that the
drive is permanent (cannot be removed)

The value dn is the drive number being defined with this
DISKDEF macro invocation. The fsc parameter accounts for differing
sector numbering systems, and is usually 0 or 1.
The lsc is the
last numbered sector on a track.
When present, the skf parameter
defines the sector skew factor which is used to create a sector
translation table according to the skew.
If the number of sectors
is less than 256, a single-byte table is created, otherwise each
All Information Presented Here is Proprietary to Digital Research
30

MP/M II System Guide

2.3

BIOS Disk Definition Tables

translation table element occupies two bytes. No translation table
is created if the skf parameter is omitted (or equal to 0).
The bls parameter specifies the number of bytes allocated to
each data block, and takes on the values 1024, 2048, 4096, 8192, or
16384.
Generally, performance increases wi th larger data block
sizes since there are fewer directory references and logically
connected data records are physically close on the disk. Also, each
directory entry addresses more data, and the BIOS-resident RAM space
is reduced.
The dks specifies the total disk size in bIs units.
That is, if the bls = 2048 and dks = 1000, then the total disk
capacity is 2,048,000 bytes. If dks is greater than 255, then the
block size parameter bls must be greater than 1024. The value of
dir is the total number of directory entries which may exceed 255,
if desired.
The cks parameter determines the number of directory items to
check on each directory scan and is used internally to detect
c han g e d dis k s d uri n g s ys tern 0 pe rat ion.
Wh en t his sit u at ion i s
detected, MP/M II automatically marks the disk read/only, so that
data is not subsequently destroyed.
As stated in the previous
section, the vallle of cks equals dir when the media is easily
changed, as is the case with a floppy disk subsystem. If the disk
is permanently mounted, then the value of cks is typically 0 and
thus the prm parameter should be included to indicate that the drive
is permanent.
The ofs value determines the number of tracks to skip when this
particular drive is addressed, which can be used to reserve
additional operating system space or to simulate several logical
drives on a single large-capacity physical drive.
The k16 parameter is included when file compatibility is
required with versions of CP/M 1.4 that have been modified for
higher density disks.
This parameter ensures that only 16K is
allocated for each directory record, as was the case for previous
versions. Normally, this parameter is left null. Finally, the prm
parameter can be used to indicate that the drive is permanent. This
parameter should only be included if the disk media cannot be
removed from the drive.
For convenience and economy of table space, the special form
DISKDEF

i,j

gives disk i the same characteristics as a previously defined drive
j. A standard four-drive single density system, which is compatible
with CP/M 1.4, is defined using the following macro invocations:

All Information Presented Here is Proprietary to Digital Research
31

MP/M II System Guide
DISKS
DISKDEF
DISKDEF
DISKDEF
DISKDEF

2.3

BIOS Disk Definition Tables

4
0,1,26,6,1024,243,64,64,2
1,0
2,0
3,0

ENDEF
with all disks having the same parameter values of 26 sectors per
track (numbered 1 through 26), with 6 sectors skipped between e~ch
access, 1024 bytes per data block, 243 data blocks for a total of
243k byte disk capacity, 64 checked directory entries, and two
operating system tracks.
The DISKS macro generates nDisk Parameter Headers (DPHs),
starting at the DPH table address DPBASE generated by the macro.
Each disk header block contains sixteen bytes, as described above,
and corresponds one-for-one to each of the defined drives. In the
four drive standard system, for example, the DISKS macro generates a
table of the form:
DPBASE
DPEO:
DPEl:
DPE2:
DPE3:

EQU

DW
DW
DW
DW

$
XLTO,OOOOH,OOOOH,OOOOH,DIRBUF,DPBO,CSVO,ALVO
XLTO,OOOOH,0000H,0000H,DIRBUF,DPBO,CSVl,ALV1
XLTO,0000H,0000H,0000H,DIRBUF,DPBO,CSV2,ALV2
XLTO,0000H,0000H,0000H,DIRBUF,DPBO,CSV3,ALV3

where the DPHlabels are included for reference purposes to show the
beginning table addresses for each drive,
through 3. The values
contained within the disk parameter header are described in detail
in the previous section. The check and allocation vector addresses
are generated by the ENDEF macro in the RAM area following the BIOS
code and tables.

°

Note that if the skf (skew factor) parameter is omitted (or
equal to 0), the translation table is omitted, and a OOOOH value is
inserted in the XLT position of the disk parameter header for the
disk.
In a subsequent call to perform the logical to physical
translation, SECTRAN receives a translation table address of DE =
OOOOH, and simply returns the original logical sector from BC in the
HL register pair.
A translate table is constructed when the skf
parameter is present, and the (non-zero) table address is placed
into the corresponding DPHs. The table shown below, for example, is
constructed when the standard skew factor skf = 6 is specified in
the DISKDEF macro call:
XLTO:

DB
DB

1,7,13,19,25,5,11,17,23,3,9,15,21
2,8,14,20,26,6,12,18,24,4,10,16,22

Following the ENDEF macro call, a number of uninitialized data
areas are defined. These data areas need not be a part of the BIOS
that is loaded upon cold start, but must be available between the
BIOS and the end of memory. The size of the uninitialized RAM area
is determined by EQU statements generated by the ENDEF macro. For a
standard four-drive system, the ENDEF macro might produce:
All Information Presented Here is Proprietary to Digital Research
32

MP/M II System Guide

4C72 =
4DBO =
013C =

2.3

BIOS Disk Definition Tables

BEGDAT EQU $
(data areas)
ENDDAT EQU $
DATSIZ EQU $-BEGDAT

which indicates that uninitia1ized RAM begins at location 4C72H,
ends at 40BOH-l, and occupies 013CH bytes.
You must ensure that
these addresses are free for use after the system is loaded.
After modification, you can use the STAT program to check your
drive characteristics, because STAT uses the disk parameter block to
decode the drive information. The STAT command form
STAT d:DSK:
decodes the disk parameter block
displays the values shown below.
r:

k:
d:
c:
e:
b:
s:
t:

128 Byte
Kilobyte
32 Byte
Checked
Records/
Records/
Sectors/
Reserved

for

drive

d

(d=A, ••• ,P)

and

Record Capacity
Drive Capacity
Directory Entries
Directory Entries
Extent
Block
Track
Tracks

Three examples of DISKDEF macro invocations are shown below
with corresponding STAT parameter values. The last example produces
an 8-megabyte system.
DISKDEF 0,1,58,,2048,256,128,128,2
r=4096, k=512, d=128, c=128, e=256, b=16, s=58, t=2
DISKDEF 0,1,58,,2048,1024,300,0,2
r=16384, k=2048, d=300, c=O, e=128, b=16, s=58, t=2
DISKDEF 0,1,58,,16384,512,128,128,2
r=65536, k=8192, d=128, c=128, e=1024, b=128, s=58, t=2

2.4

External Procedure Access

To help the XIOS access other MP/M entry points, a jump vector
is dynamically built by the MP/M II GENSYS program and placed at the
COMMONBASE subroutine entry point. The dynamic portion of the jump
vector contains five entry points that provide access to user and
system memory bank switching, the MP/M II dispatcher, the XDOS, and
the SYSDAT page.
Table 2-7
describes external procedure entry
points.

All Information Presented Here is Proprietary to Digital Research
33

MP/M II System Guide

2.4

The following example
external procedures:
COMMONBASE:
JMP
SWTUSER: JMP
SWTSYS: JMP
PDISP:
JMP
XDOS:
JMP
SYSDAT: DW
COLDSTART:
WBOOT:
MVI
JMP

External Procedure Access

illustrates the code used

to access

COLDSTART
$-$
$-$
$-$
$-$
$-$

C,O
XDOS

iterminate process

All Information Presented Here is Proprietary to Digital Research
34

MP/M II System Guide

2.4

Table 2-7.
Subroutine

External Procedure Access

External Procedure Summary

1

Description

sw'rUSER

The SWTUSER entry point restores the bank
of the user's calling program.
There are
no parameters passed or returned.
The
purpose of SWTUSER is to enable BIOS disk
read and write code to transfer data from a
disk controller or buffer in common memory
to/from the DMA buffer in the user's
calling program.
This procedure must be
called only from common memory, that is
above the COMMONBASE label, and it must be
used only from BIOS disk functions.
Internally the SWTUSER procedure disables
and then re-enables interrupts.
Thus, if
you disable interrupts before calling
SWTUSER they will be enabled on returning
from SWTUSER.

SWTSYS

The SWTSYS entry point restores the bank of
the BNKBDOS.
There are no parameters
passed or returned. The purpose of SWTSYS
is to restore the bank containing the
banked portion of the BDOS following the
transfer of data from a disk controller or
buffer in common memory to/from the DMA
buffer in the user's calling program. This
procedure must be called only from common
memory.
Internally the SWTSYS procedure
disables and then re-enables interrupts.
Thus, if you disable interrupts before
call i n g S WT S YS they will be en a b 1 e d on
returning from SWTSYS.

PDISP

The PDISP entry point forces a dispatch
call.
It is intended to be used at the
conclusion of interrupt handling when a
process is to be dispatched.
It is
effectively a null procedure call from the
point of view of the calling program.

XDOS

The XDOS entry point provides access to
XDOS functions.
XDOS functions are
required for flag operations, queue
operations and polling devices.

SYSDAT

The SYSDAT entry is not a true entry point,
but the address of the system data page.
Section 4 provides a definition of the
system data page.

All Information Presented Here is Proprietary to Digital Research

35

MP/M II System Guide

2.5

2.5

Blocking and Deblocking Algorithms

Blocking and Deblocking Algorithms

Upon each call to the BIOS WRITE entry point, the BDOS includes
information that allows effective sector blocking and deblocking
where the host disk subsystem has a sector size which is a multiple
of the basic 128-byte uni t. This section presents a general-purpose
algorithm that can be included within your BIOS that uses the BDOS
information to perform the operations automatically.
Upon each call to WRITE,
information in register C:

o

=

I
2

=
=

3

=

the

BDOS

provides

the

following

deferred write sector
non-deferred write sector
deferred write to the first sector
of a new data block
non-deferred write to the first sector
of a new data block

Conditions 0 and 2 occur only for permanent drives and allow
deferred writes.
Conditions I and 3 occur for non-permanent
( rem 0 va b Ie) d r i ve sand for c e i mm e d i ate ( non - de fer red) wr i t e s •
Condition I also occurs on permanent drives for writes to the
directory.
Conditions 2 and 3 occur when a write operation is made to the
first sector of a new data block. The blocking/deblocking algori thm
does not perform physical record pre-reads if sequential writes are
made to a new data block. In most cases, application programs read
or write multiple l28-byte sectors in sequence, and thus there is
little overhead involved in either operation when blocking and
deblocking records because pre-read operations can be avoided when
writing records.
The blocking and deblocking algorithm is listed in Appendix B
in skeletal form.
The file is included on your MP/M II disk.
Generally, the algorithms map all MP/M II sector rea~ operations
onto the host disk through an intermediate buffer whichds the size
of the host disk sector.
Throughout the program, values and
variables which relate to the sector involved in a seek operation
are prefixed by "sek," while those related to the host disk system
are prefixed by "hst." The equate statements beginning on line 24
define the mapping between MP/M II and the host system, and must be
changed if other than the sample host system is involved.
The SELDSK entry point clears the host buffer flag whenever a
new disk is logged-in.
Note that although the SELDSK entry point
computes and returns the Disk Parameter Header address, it does not
physically select the host disk at this point (it is selected later
at READHST 0 r WRITEHST). Furthe r, SETTRK, SETSEC, and SETDMA s impl y
store the values, but do not take any other action at this point.
SECTRAN performs a trivial function of returning the physical sector
number.

All Information Presented Here is Proprietary to Digital Research
36

MP/M II System Guide

2.5

Blocking and Deblocking Algorithms

The principal entry points are READ and WRITE.
These
subroutines take the place of your previous READ and WRITE
operations.
The actual physical read or write takes place at either
WRITEHST or READHST, where all values have been prepared: hstdsk is
the host disk number, hsttrk is the host track number, and hstsec is
the host sector number (which may require translation to a physical
sector number). You must insert code at this point which performs
the full host sector read or write into, or out of, the buffer at
hstbuf of length hstsiz. All other mapping functions are performed
by the algorithms.
2.6

Common Memory Portion of the BNKXIOS

Take care when selecting which XIOS code is to be placed in
common memory.
This section should give you some helpful
guidelines.
In general, all XIOS and BIOS entries (with the exception of
the disk I/O entries) must be above the COMMONBASE subroutine entry
point. Thus, the BNKXIOS enables you to place your disk drivers in
a portion of code that is not in common memory. There are, however,
some exceptions that affect both the code and data areas of of the
disk handlers.
Th e Dis k Par a me t er He ad e r sand Dis k Par am e t e r BI 0 c k s mu s t be in
common memory.
The DIRBUF data structure, which is referenced by the disk
parameter blocks, must reside in common memory.
All disk device polling code and interrupt handlers must reside
in common memory.
While it is possible to place a deblocking buffer in non-common
memory, it requires a sector buffer in common memory and an extra
move of 128 bytes to move the data first into common memory and then
into the users DMA buffer. Also, bank switching cannot be permitted
while a physical DMA from a disk controller to a deblocking buffer
in non-common memory is in operation.

All Information Presented Here is Proprietary to Digital Research
37

Section 3
MP/M II XIOS
3.1

MP/M II XIOS Overview

The Extended Input/Output System (XIOS) must include the
hardware dependent code that polls devices, handles interrupts and
performs memory management functions.
The MP/M II system implementor must prepare subroutines that
perform the functions described in Table 3-1, then place a jump
vector containing the XIOS entry points immediately following the
BIOS jump vector.
Most of the XIOS subroutines need to be reentrant. The XIOS jump vector must take the following form:
BIOS+33H
BIOS+36H
BIOS+39H
BIOS+3CH
BIOS+3FH
BIOS+42H
BIOS+45H
BIOS+48H

3.2

JMP SELMEMORY
JMP POLLDEVICE
JMP STARTCLOCK
JMP STOP CLOCK
JMP EXITREGION
JMP MAXCONSOLE
JMP SYSTEMINIT
JMP IDLE

SELECT MEMORY
POLL DEVICE
START CLOCK
STOP CLOCK
EXIT CRITICAL REGION
MAXIMUM CONSOLE NUMBER
SYSTEM INITIALIZATION
IDLE PROCEDURE (Optional)

MP/M XIOS Entry Points

Each jump address corresponds to a particular subroutine that
performs the specific function.
Table 3-1 outlines the exact
responsibilities of each XIOS entry point subroutine.

Table 3-1.
Subrout ine
SELMEMORY

I

XIOS Subroutine Summary
Function

The SELMEMORY subroutine identifies the
segment of memory where a process is to
execute. Each time a process is dispatched
for execution, the operating system makes a
call to this XIOS select memory procedure.
If the hardware environment has memory bank
selection/protection, SELMEMORY can use the
passed pa rameter to select/protect areas of
memory. The passed parameter (in registers
BC) is a pointer to a memory descriptor
from which the memory base, size,
attributes and bank of the executing
process can be determined. Thus, all other
regions of memory can be write-protected.

All Information Presented Here is Proprietary to Digital Research
39

MP/M II System Guide

Subroutine

3.2

Table 3-1.

I

MP/M XIOS Entry Points

(continued)
Function

MP/M II calls SELMEMORY wi th interrupts
disabled from within the dispatcher.
The
SELl"lEMORY subroutine must not enable
interrupts.
This subroutine must reside
above the COMMONBASE entry point.
POLLDEVICE

A po 11 ed env i ronmen t can be c rea ted by
cod ing XIOS device poll handlers.
The
purpose of implementing a polled
environment is to avoid typical busy-wait
code for device operation completion.
There are also peripheral devices that may
not operate efficiently under interrupts.
XDOS calls the device poll handler
(POLLDEVICE) with the device to be polled
in the C register as a single parameter.
The user-written POLLDEVICE procedure can
be coded to access the device poll ing
routines via a table that contains the
addresses of the device polling procedures.
An association is made between a device
number to be polled and the polling
procedure itself. The polling procedures
must return a value of OFFH in the
accumulator if the device is ready, or OOH
if the device is not ready. POLLDEVICE is
called from a critical region within the
dispatcher;
therefore, the POLLDEVICE
subrout i ne must not enable inte r rups. Th is
subroutine must reside above the COMMONBASE
entry point.

STARTCLOCK

The STARTCLOCK and STOPCLOCK procedures
eliminate unnecessary overhead for the
system clock interrupt handler. The system
clock provides a time base for both the
real time flag and the system tick
procedure.
However, the system tick
procedure is needed only when where is a
process on the delay list. MP/M II calls
STARTCLOCK when a process enters the delay
list to initiate the system tick time base
(see Section 3.4).
.

'----_._-------.

__ ._-------_._-------------

All Information Presented Here is Proprietary to Digital Research
40

MP/M II System Guide

3.2
Table 3-1.

Subroutine

MP/M XIOS Entry Points

(continued)

I

Function
In some hardware environments, it is not
possible to shut off the system time unit
clock while maintaining the one-second flag
used for keeping time of day.
In this
situation, the STARTCLOCK procedure simply
sets a boolean variable to true, indicating
that there is a delayed process. The clock
interrupt handler can then determine if
system time unit flag is to be set by
testing the boolean. This subroutine must
reside above the COMMONBASE entry point.

STOPCLOCK

When the system delay list is emptied, MP/M
II calls the STOPCLor~ procedure to stop
the system tick time base. This eliminates
unnecessary overhead for the system clock
interrupt handler.
In some hardware environments, it is not
possible to shut off the system time unit
clock while maintaining the one second flag
used for keeping time of day;
that is, a
single clock/timer interrupt source is
used.
In this situation, the STOPCLOCK
procedure simply sets a boolean variable to
false, indicating that there are no delayed
processes. The clock interrupt handler can
then determine if the system time unit flag
is to be set by testing the boolean. This
subroutine must reside above the COMMONBASE
entry point.

EXITREGION

MP/M II calls the EXITREGION procedure to
test a local parameter called the PREEMPT
flag.
I f PREEMPT is true, EXITREGION
leaves interrupts disabled. If PREEMPT is
false, EXITREGION enables interrupts.
Interrupt service routines must set the
PREEMPT flag true at beginning of the
interrupt handling. This procedure allows
an interrupt service routine to make a flag
set MP/M II system call, leaving interrupts
disabled until completion of the interrupt
handl ing.
This subroutine must reside
above the COMMONBASE entry point.

All Information Presented Here is Proprietary to Digital Research

41

MP/MII System Guide

3.2
Table 3-1.

Subrout ine

MP/M XIOS Entry Points

(continued)

I

Funct ion

MAXCONSOLE

maximum console procedure enables the
calling program to determine the number of
physical consoles the BIOS is capable of
supporting.
The number of physical
consoles is returned in the A register.
This subroutine must reside above the
COMMONBASE entry point.

SYSTEMINIT

The system initialization procedure
performs the required MP/M cold start
initialization. The following is a typical
initialization for a banked system: first,
MP/M II initializes bank 0, disables
interrupts and calls SYSTEMINIT.
Then,
SYSTEMINIT sets up interrupt jump vectors,
interrupt masks, and the base page of each
bank before returning to MP/M II. Finally,
MP/M I I enables interrupts.
A typical
initialization for a non-banked system
would perform the same steps, but only one
bank would be initialized.

Th~

MP/M II disables interrupts and calls the
SYSTEMINIT entry point prior to any other
XIOS call.
As stated above, MP/M II
enables interrupts immediately upon return
from SYS'rEMINIT.
This subroutine must
reside above the COMMONBASE entry point.
In systems wi th bank swi tched memory, it is
necessary to set up the base page (OOOOH OOFFH) within each bank of memory.
Both
the MPMLDR and MP/M itself assume that the
base bank (bank #0) is switched in when the
MPMLDR is executed.
The base bank is
properly initialized by MP/M prior to
enter ing SYSTEMINIT.
The information
required for the initialization of other
banks is provided on entry to SYSTEMINIT in
the registers defined below:
C

MP/M debugger restart #

DE

MP/M entry point address for the debugger.
Place a jump at the proper debugger restart
location to the address contained in DE.

All Information Presented Here is Proprietary to Digital Research
42

MP/M II System Guide

3.2
(continued)

Table 3-1.
Subrout ine

MP/M XIOS Entry Points

I

Routine

HL

BIOS direct jump table address.
Place a
jump instruction at location OOOOH in each
bank's base page to the address contained
in HL.

IDLE

An IDLE process is the anchor of the
process ready list.
The MP/M II nucleus
calls the IDLE procedure when there are no
other processes ready to run.
The normal
IDLE procedure is a call to the dispatcher.
T his m0 s t e f f i c i en t I Y s e r v e s po 11 e d
devices. If your system is entirely
interrupt-driven (i.e. no polled devices),
you can supply your own IDLE procedure,
which should be as follows:
IDLE:
HALT
RET
I f you do not supply an IDLE procedure,
place three bytes of zero at the BIOS +48H
location.

3.3

Interrupt Service Routines

The MP/M II operating system is designed to work with virtually
any interrupt architecture, be it flat or vectored.
The code
operating at the interrupt level saves the required registers,
determines the cause of the interrupt, removes the interrupting
condition, sets an appropriate flag, and then forces a dispatch to
take place.
Be sure to use a minimum number of stack levels when saving the
state of the interrupted process. This is because the interrupted
application program, especially if it has been written for a CP/M
environment, is not likely to provide extra stack area as a
contigency for interrupts.
The example Extended Input/Output
Systems shown in the Appendixes illustrate a technique whereby no
additional levels of stack are required beyond that of the interrupt
restart itself.
This technique is highly recommended.
Operation of the flags is described in Section 3 of the MP/M II
Programmer's Guide, under the discussion of the Flag Set and Flag
Wait XDOS Functions.
Briefly, flags synchronize a process to an
asynchronous event. In general, an interrupt service routine sets a
particular flag while another process waits for the flag to be set.

All Information Presented Here is Proprietary to Digital Research

43

MP/M II System Guide

3.3

Interrupt Service Routines

At a logical level above the physical interrupts, the flags can
be regarded as providing 256 levels of virtual interrupts (32 flags
are supported under MP/M II). Thus, logical interrupt handlers wait
on flags set by the physical interrupt handlers. This mechanism
allows a common XDOS to operate on potentially all 8080, 8085 and
Z80® microcomputers, regardless of the hardware environment.
As an example, consider a hardware environment with a flat
interrupt structure. That is, a single interrupt level is provided
and devices must be polled to determine the cause of the interrupt.
Once the interrupt cause is determined, a specific flag is set
indicating that that particular interrupt has occurred.
j

At the conclusion of the interrupt processing, a jump should be
made to the MP/M II dispatcher. This is done by jumping to the
PDISP entry point. This jump gives the processor resource to the
highest priori ty ready process, usually the process· readied by
setting the flag in the interrupt handler, and then enables
interrupts before jumping to resume execution of that process.
The. only XDOS or aDOS call that should be made from an
interrupt handler is 133: Flag Set. Any other XDOS or aDOS call
results in a dispatch which would then enable interrupts before the
execution of the interrupt handler is completed.
It is recommended tha t interrupts be used only for asynchronous
operations such as console input or disk operation complete.
In
general, operations s~ch as console output should not be interruptdriven, because the system has more elasticity when performing
polled console outputs while idling, rather than incurring the
dispatch overhead for each character transmitted.
This is
particularly true at higher baud rates.
If a system requires the execution of a return from interrupt
(RETI) instruction, the interrupt handler must execute the RETI
before branching to the dispatcher via the PDISP entry point.
3.4

Time Base Management

The XIOS must provide two time bases: a one second flag for
real time and a system tick for managing the delay list. The one
second flag operation is logically separate from the system tick
operation even though it may physically share the same clock/timer
interrupt source. The one second flag procedure sets flag #2 at
each one second of real time. MP/M II uses flag #2 to maintain a
time of day clock.
The system tick procedure, when enabled by STARTCLOCK, sets
flag #1 at system time unit intervals. The recommended time unit is
a period of 16.67 milliseconds, corresponding to a tick frequency of
60 Hz.
Wh e nope rat in g with SOH z , use a 20m i 11 i sec 0 nd pe r i od •
MP/M II uses the system tick to manage the delay list until the
delay list is empty, at which time the system tick procedure is
disabled by STOPCLOCK.
All Information Presented Here is Proprietary to Digital Research
44

3.4

MP/M II System Guide

Time Base Management

The system tick frequency is critical because it determines the
dispatch frequency for compute-bound processes. If the frequency is
too high, a significant amount of system overhead is incurred by
excessive dispatches. If the frequency is too low, compute-bound
processes keep the CPU resource for accordingly longer periods.

All Information Presented Here is Proprietary to Digital Research
45

Section 4
MP1M II System File Components
The MP/M II system file, MPM.SYS, consists of a number of
components: the system data page, the customized XIOS, the RESBDOS
and BNKBDOS, the XDOS and BNKXDOS, the TMP, and the resident system
processes. MPM.SYS resides in the directory with a user code of 0
and usually has the Read Only attribute. The MP/M II loader reads
the MPM.SYS file into memory to bring up the MP/M II system.
4.1

System Data

The system data page contains 256 bytes used by GENSYS to
dynamically configure the MP/M II system. The system data page can
be prepared using the GENSYS program or it can be manually prepared
using DDT or SID. The Table 4-1 describes the byte assignments.
Table 4-1.
Byte
000-000
001-001
002-002
003-003
004-004
005-005
006-006
007-007
008-008
009-010
011-011
012-012
013-013
014-014
015-015
016-047
048-063
064-079
080-095
096-119
120-121
122-122
123-123
124-124
125-125
126-127
128-143

System Data Byte Assignments

l

Contents
Mem$top, top page of memory
Nmb$cns, number of system consoles (TMPs)
Brkpt$RST, breakpoint RST
Add system call user stacks, boolean
Bank switched, boolean
Z80 version, boolean
banked bdos, boolean
XIOS jump table page
RESBDOS base page
CP/NET master configuration table address
XDOS base page
RSPs (BNKXIOS top+1) base page
BNKXIOS base page
BNKBDOS base page
Max$mem$seg, max memory segment number
Initial memory segment table
Breakpoint vector table, filled in by debuggers
Reserved for MP/M II
System call user stack pointer table
Reserved for MP/M II
Nmb records in MPM.SYS file
ticks/sec
System Drive
Common Memory Base Page
Number of RSPs
Listcp array Address
Subf1g, submit flag array

*

*

All Information Presented Here is Proprietary to Digital Research
47

4.1

MP/M II System Guide
Table 4-1.

System Data

(continued)

Byte

Contents

144-186
187-187
188-188
189-190
191-192
193-193
194-194
195-195
196-196
197':'197
197-241
242-242
243-243
244-244
245-246
247-247
248-248
249-249
250-251
252-253
254-255

Reserved for MP/M II
Max locked records/process
Max open files/process
# list items
Pointer to base of lock table free space
Total system locked records
Total system open files
Dayfile logging, boolean
Temporary file drive
Number of printers
Reserved for MP/M II
Banked XDOS base page
TMP process descriptor base
Console.dat base
BDOS/XDOS entry point
TMP.spr base
Nmbrsps, number of banked RSPs
Brsp base address
Brspl, non-resident rsp process link
Sysdatadr, XDOS internal data segment address
Rspl, resident system process link

4.2

Customized XIOS

The customized XIOS is obtained either from a file named
RESXIOS.SPR, or a file named BNKXIOS.SPR. The XIOS file of type SPR
contains the page relocatable version of the user-customized XIOS.
The standard method for the generation of the XIOS is to use the
Digital Research LINK program. An alternative method is described
in Section 1.
4.3

BOOS

The Basic Disk Operating System (BDOS) resides in two pagerelocatable files named the RESBDOS and the BNKBDOS.
These two
files contain the console, list and disk file management code.
4.3.1

RESBOOS

The file named RESBDOS.SPR is a page relocatable file
containing the logical console and list handling, as well as the
resident portion of the disk file system that provides an interface
to the BNKBDOS.

All Information Presented Here is Proprietary to Digital Research
48

MP/M II System Guide

4.3

BDOS

The file named BNKBDOS.SPR is a page relocatable
containing the non-resident portion of the banked BDOS.

file

4.3.2

4.4

BNKBDOS

XDOS

The XDOS file named XDOS.SPR is a page-relocatable file
containing the priority-driven MP/M II nucleus.
The nucleus
contains the following code pieces: root module, dispatcher, queue
management, flag management, memory management, terminal handler,
te rm i na I mess age process, command line inte rprete r, file name
parser, and time base management.

4.5

Resident System Processes

A file type of RSP identifies a resident system process. The
RSP files distributed with MP/M II include: run-time system status
display (MPMSTAT) t printer spooler (SPOOL), abort named process
(ABORT), and a scheduler (SCHED). At system generation time, GENSYS
prompts you to select which RSPs to include in the MPM.SYS file.
It is possible for the user to prepare custom resident system
processes. The resident system processes must follow these rules:
• The file must be page-relocatable. Page relocatable files can
be generated by LINK, or by the submit files MACSPR.SUB or
ASMSPR.SUB.
The output file must be renamed to type RSP.
• The first two bytes of the resident system process are reserved
for the address of the BDOS/XDOS.
Thus a resident system
process can access the BDOS/XDOS by loading the two bytes at
relative OOOO-OOOIH and then performing a PCHL.
• The process descriptor for the resident system process must
begin at the third byte position.

4.6

Banked Resident System Processes

A banked resident system process consists of two parts: a
resident portion and the code for the process. The resident portion
contains the process descriptor, and queues or other data structures
that must be in common memory. This portion follows the rules given
above for resident system processes.
The presence of a banked
portion is specified by setting the process descriptor memory
segment index to zero rather than OFFH.
The name provided in the
process descriptor is used to obtain the banked portion which has a
file type of BRS.

All Information Presented Here is proprietary to Digital Research
49

MP/M II System Guide

4.6

Non-Resident System Processes

The second part of a banked system process is the actual code
piece for the process.
The rules for the BRS portion are as
follows:
• The file must be page relocatable. Page relocatable files can
be generated by LINK, or the procedure outlined in Section 1.
The output file must be renamed to type BRS.
• Bytes OOOO-OOOlH of the banked RSP are reserved for the address
of the resident portion of the RSP.
Thus, a banked RSP must
access the BDOS/XDOS functions by indirectly loading from the
two bytes at relative OOOO-OOOlH, which point to the base of
the resident portion of the RSP, which in turn contain the
BDOS/XDOSentry point address.
• Bytes 0002-,P003H of the banked RSP must contain the ini tial
stack pointer value for the process. Thus the stack for the
banked RSP is in the banked portion of the RSP, and should be
initialized such that the return address on top of the stack is
the banked RSP entry point address.
• Bytes 0004-000BH of the banked RSP must contain an ASCII name
for the process.
This is used for display purposes during
GENSYS and MPMLDR execution.

All Information Presented Here is proprietary to Digital Research
50

Section 5
System Generation
5.1 GENSYS Operation
MP/M II system generation consists of preparing a system data
file and concatenating both required and optional code files to
produce a file named MPM.SYS. A GENSYS program reforms these tasks
and can be run under either MP/M II or CP/M.
The GENSYS automates
the system generation process by prompting the user for optional
parameters and then prepares the MPM.SYS file. The following sample
execution illustrates GENSYS operation.
OA>gensys
MP/M-80 V2.0 System Generation
Copyright (C) 1981, Digital Research
Default entries are shown in (parens).
Default base is Hex, precede entry with # for decimal
Use SYSTEM.DAT for defaults (Y) ?
Top page of operating system (FF) ?
Number of TMPs (system consoles) (#2) ?
Number of Printers (#1) ?
Breakpoint RST (06) ?
Add system call user stacks (Y) ?
Z80 CPU (Y) ?
Number of ticks/second (#60) ?
System Disk (E:) ?
Temporary file drive (E:) ?
Maximum locked records/process (#16) ?
Total locked records/system (#32) ?
Maximum open files/process (#16) ?
Total open files/system (#32) ?
Bank switched memory (Y) ?
Number of user memory segments (#3) ?
Common memory base page (CO) ?
Dayfile logging at console (Y) ?
SYSTEM
TMPD
USERSYS
XIOSJMP

DAT
DAT
STK
TBL

FFOOH
FEOOH
FDOOH
FCOOH

OIOOH
OIOOH
OIOOH
OIOOH

Accept new system data page entries (Y)
RESBDOS SPR
SPR
XDOS

FOOOH
CEOOH

?

OCOOH
2200H

Select Resident System Processes:
All Information Presented Here is Proprietary to Digital Research
51

MP/M II System Guide
SCHED
ABORT
SPOOL
MPMSTAT

RSP
RSP
RSP
RSP

5.1

System Generation Overview

(N) ?
(N) ? Y
(N) ? Y
(N) ? Y

RSP
ABORT
RSP
SPOOL
MPMS'rAT RSP

CDOOH
CCOOH
CBOOH

OlOOH
OlOOH
OlOOH

BNKXIOS
BNKBDOS
BNKXDOS
TMP

SPR
SPR
SPR
SPR

B800H
9500H
9200H
8FOOH

1300H
2300H
0300H
0300H

BRS
SPOOL
MPMSTAT BRS

8700H
7900H

0800H
OEOOH

LCKLSTS DAT
CONSOLE DAT

7700H
7500H

0200H
0200H

Enter memory segment table:
Base,size,attrib,bank
Base,size,attrib,bank
Base,size,attrib,bank
Base,size,attrib,bank
*** Memory conflict Base,size,attrib,bank
MP/M II
Memseg
Memseg
Memseg

Sys
Usr
Usr
Usr

7500H
OOOOH
OOOOH
OOOOH

(75,8B,80,00) ?
(OO,CO,OO,Ol) ?
(00,CO,00,02) ?
(00,CO,00,03) ? OO,ff,O,O
segment trimmed ***
(00,75,00,00) ?

8BOOH
COOOH
COOOH
7500H

Bank
Bank
Bank
Bank

00
01
02
00

Accept new memory segment table entries (Y)

?

** GENSYS DONE **
5.2 System Generation Parameters
This section discusses the issues involved in answering each of
the GENSYS queries shown in the example above.
5.2.1

Defaults

The GENSYS program displays default entry values within
parentheses.
The base is hex unless a i character preceeds the
value to indicate a decimal base. The initial prompt determines if
the internal GENSYSdefaults are to be used, or those of the most
recently generated SYSTEM.DAT file.

All Information Presented Here is Proprietary to Digital Research
52

MP/M II System Guide
5.2.2

5.2

System Generation Parameters

Top Page of Operating System

Enter two hex ASCII digits to give the top page of the
operating system. The highest address used by MP/M II is XXFFH,
where XX is the entry.
5.2.3

Number of System Consoles

This entry determines the number of system consoles for which
Terminal Message Processes (TMP's) are created to generate user
prompts and send command I ines to the Command Line Interpreter
(CLI). A region of common memory called TMPD.DAT is reserved for
the TMP process descriptors. Four TMP process descriptors can be
placed in each page of the TMPD.DAT.
Each system console also
requires 256 bytes of memory for stack and buffer areas in a nonresident region of memory called CONSOLE.DAT. MP/M II supports up
to a maximum of 16 character I/O console devices, of which 8 can be
system consoles and have associated TMPs.
During MP/M II
initialization, an XIOS call obtains the actual maximum number of
physical consoles supported by the XIOS. This number is used if it
is less than the number specified during the GENSYS.
5.2.4

Number of Printers

This entry determines the number of physical printers which the
XIOS is capable of supporting. This number is used by the MPMSTAT
program when it displays the status of the system printers.
5.2.5

Breakpoint RST

Enter the breakpoint restart number to be used by the MP/M
debuggers. Recommended restarts are RST #1 to RST #6.
5.2.6

System Call User Stacks

I f you want to execute CP/M * .COM files, enter yes.
An
affirmative response forces a stack switch to occur when system
calls are made from a user program. BDOS calls require more stack
space under MP/M II than under CP/M. An affirmative response causes
GENSYS to allocate a region of common memory called USERSYS.STK. The
size of this region is determined by the number of user memory
segments, where 0-3 segments require 100h bytes and 4-7 segments
require 200h bytes.
Note that this affects BDOS calls only, not XDOS calls. The
XDOS is re-entrant and performs no stack switching. Therefore, if
your program makes any XDOS calls, you need to make certain that you
have allocated sufficient stack.

All Information Presented Here is Proprietary to Digital Research
53

MP/M IX System Guide

5.2.7

5.2

System Generation Parameters

Z80 CPU

An affirmative response should only be made if you do have a
Z80 cpu.
If specified, the MP/M II dispatcher saves and restores
the Z80 alternate register set.

5.2.8

Number of Ticks / Second

This entry value can be used by applications programs to
determine the number of ticks per second. This value may vary among
MP/M II systems.

5.2.9

System Disk

The drive entered here is used for a second search if the file
requested to the CLI is not found on the default drive.

5.2.10

Temporary File Drive

The drive entered here is used as the drive for temporary disk
files. This entry is used by SUBMIT when it generates the $n$.SUB
temporary file. This entry can also be accessed in the system data
page by application programs as the drive on which to create
temporary files.

5.2.11

Maximum Locked Records / Process

This entry specifies the maximum number of records that a
single process (usually one program) can lock at any given time.
This number can range from 0 to 255 and must be less than or equal
to the total locked records for the system.

5.2.12

Total Locked Records / System

This entry specifies the total number of locked records for all
the processes executing under MP/M II at any given time.
This
number can range from 0 to 255 and should be greater than or equal
to the maximum locked records per process.
It is possible to allow each process to either use up the total
system lock record space, or to allow each process to lock only a
fraction of the system total. The first technique implies a dynamic
storage region in which one process can force other processes to
block because it has consumed all available resources.

All Lnformation Presented Here is Proprietary to Digital Research
54

MP/M II System Guide
5.2.13

5.2

System Generation Parameters

Maximum Open Files / Process

This entry specifies the maximum number of files that a single
process (usually one program) can open at any given time.
This
number can range from 0 to 255 and must be less than or equal to the
total open files for the system.
5.2.14

Total Open Files / System

This entry specifies the total number of open files for all the
processes executing under MP/M II at any given time.
This number
can range from 0 to 255 and should be greater than or equal to the
maximum open files per process.
It is possible either to allow each process to use up the total
system open file space, or to allow each process to only open a
fraction of the system total. The first technique implies a dynamic
storage region in which one process can force other processes to
block because it has consumed all available resources.
5.2.15

Bank Switched Memory

If your system does not have bank-switched memory, then you
should respond with a "N".
Otherwise respond with a "Y" and
additional questions and responses (as shown in Section 5.2.2) are
required.
5.2.16

Number of User Memory Segments

The number of user memory segments must be in the range 1 to 7
and should be greater than or equal the number of system consoles.
5.2.17

Common Memory Base Page

In response to this prompt, enter the address of the lowest
page of memory common to all banks. GENSYS checks that all modules
requiring residence in common memory are located above this address.
5.2.18

Dayfile Logging at Console

An affirmative response causes the generated MP/M II system to
display the current time, file name and type, and user number of
each executed command file.

All Information Presented Here is Proprietary to Digital Research
55

MP/M II System Guide

5.2.19

5.2

System Generation Parameters

Accept System Data Page Entries

If the entries made for the first 16 queries are acceptable,
then enter yes.
Otherwise, any or all of the entries made can be
changed by re-cycling through the GENSYS queries, entering a
carriage return where values are not to be changed.

5.2.20

Select Resident System Processes

GENSYS searches the directory for all files of type RSP. Each
file found is listed and included in the generated system file if
you respond with a nyu.
Tests are performed to make certain that
the specified RSPs reside at or above the common base address.

5.2.21

Memory Segment Table

Memory segmentation is defined by the entries which are made.
You are prompted for the base, size, attributes, and bank for each
memory segment.
The GENSYS program only allows you to enter the
number of segments specified in the response to the query regarding
the number of user memory segments.
The first default entry made is for the operating system. This
becomes the segment zero entry in the memory segment table. It is
switched in during the banked MP/M II execution of the BNKXIOS,
BRS's, and the BNKBDOS.
The first entry is not counted in your
number of user memory segments.
A significant amount of error checking is performed using a
memory bit map to ensure that no memory segments overlap each other.
It will be possible to customize the GENSYS program such that nonexistent memory for a particular hardware configuration is preallocated in the bit map. .
The order of entries in the memory segment table is also
critical.
The first entry is reserved for the operating system.
The remaining entries can be specified by user.
In specifying the
user memory segments, the absolute TPA regions (segments based at
OOOOH) should be specified in order of size, from the largest to the
smallest.
Entering the segments in this \~rder causes the MP/M II
memory manager to allocate the largest a~ilable TPA region for
execution by a COM program because it linearly searchs through the
memory segment table for the first available segment based at zero.
The ordering of relocatable segments (those not based at OOOOH) is
not critical because the MP/M II memory manager does a best fit for
those segments.
wish

The attribute byte is normally defined as 00.
However, if you
to pre-allocate a memory segment, specify a value of FFH.

The bank byte value is an index which can be used by the XIOS
to obtain a value to be sent to the bank swi tching hardware to
select the specified bank. Values of 0,1,2, ••• are used to identify
All Information Presented Here is Proprietary to Digital Research
56

MP/M II System Guide

5.2

System Generation Parameters

the memory banks.
A bank byte value of 0 is used for the nonresident portion of MP/M II.
5.2.22

Accept Memory Segment Table

A negative response to this query allows memory segment entries
to be re-edited prior to acceptance.
5.3 GENSYS Execution

The GENSYS program has an automatic mode which simplifies
repetitive generation of MPM.SYS files. This is useful in a debug
mode of testing, XIOS editing, and a subsequent GENSYS execution to
produce a new MPM.SYS file.
The automatic mode is specified as
follows:
OA>GENSYS $A

The effect of the automatic mode is to simulate the entry of a
<cr> for each GENSYS query.

All Information Presented Here is Proprietary to Digital Research
57

Section 6
MP/M Loader
6.1 MP/M Loader Operation and Display

The MPMLDR program loads the MPM.SYS file and branches to the
execution address of the MP/M II operating system.
MPMLDR can be
run under CP/M or loaded from the first two tracks of a disk by the
cold start loader.
The MPMLDR displays system loading and configuration. It does
not require any operator interaction. In the following example, the
MPM.SYS file prepared by the first GENSYS example shown in Section 5
is loaded into memory and executed.
MP/M-II V2.0 Loader
Copyr ight (C) 1981, Digital Research
Nmb of consoles
=2
Breakpoint RST #
= 6
Z80 Alternate register set saved/restored by dispatcher
Memory Segment Table:
SYSTEM DAT FFOOH OIOOH
TMPD
DAT FEOOH OIOOH
USERSYS STK FDOOH OIOOH
XIOSJMP TBL FCOOH OIOOH
RESBDOS SPR FOOOH OCOOH
XDOS
SPR CEOOH 2200H
ABORT
RSP CDOOH OIOOH
Spool
RSP CCOOH OIOOH
MPMSTAT RSP CBOOH OIOOH
BNKXIOS SPR B800H l300H
BNKBDOS SPR 9500H 2300H
BNKXDOS SPR 9200H 0300H
TMP
SPR 8FOOH 0300H
Spool
BRS 8700H 0800H
Mpmstat BRS 7900H OEOOH
LCKLSTS DAT 7700H 0200H
CONSOLE DAT 7500H 0200H
MP/M II
Memseg
Memseg
Memseg

Sys
Usr
Usr
Usr

7500H
OOOOH
OOOOH
OOOOH

8BOOH
COOOH
COOOH
7500B

Bank
Bank
Bank
Bank

0
1
2
0

MP/M II V2.0
Copyright (C) 1981, Digital Research
OA>

All Information Presented Here is Proprietary to Digital Research
59

MP/M II System Guide

6.2

6.2

MPMLDR Execution

MPMLDR Execution

Two parameters may be specified to the MPMLDR.
The first
parameter is used to cause a b~eak to a CP/M debugger after the
loading is completed.
The parameter is a $Bn character string
placed in the default FCB filename field beginning at OOSDH.
The
character n is the CP/M debugger restart number.
If n is not
entered, a default of 7 is used.
An example of this parameter is
shown in Section 1.4.
The second parameter can specify an alternate filename for
loading other than the standard MPM.SYS file.
This parameter is
specified by placing a filename with a filetype of SYS in the
default FCB beginning at OOSCH, or, if the $Bn parameter is also
being specified, in the second default FCB beginning at 006CH. A
good application of this second parameter would be to incorporate a
menu-driven SYS file selection in the LDRBIOS at the SELDSK entry
point.
Thus, the operator would be prompted to select the
appropriate SYS file for his MP/M environment. Custom code at the
SELDSK entry point would prompt the operator for a file name and
then place the selected SYS file name into the default FCB beginning
at OOSCH.

All Information Presented Here is Proprietary to Digital Research
60

Appendix A
Disk Definition Macro
MP/M I I V2.0 disk re-definition library
Copyright (c) 1979, 1980, 1981
Digital Research
Box 579
Pacific Grove, CA
93950
MP/M I I logical disk drives are defined using the
macros given below, where the sequence of calls
is:
disks
n
diskdef parameter-list-O
diskdef parameter-list-l
diskdef parameter-list-n
endef
where n is the number of logical disk drives attached
to the MP/M I I system, and parameter-list-i defines the
characteristics of the ith drive (i=O,l, ••• ,n-l)
each parameter-list-i takes the form
dn,fsc,lsc, [skf] ,bls,dks,dir ,cks,ofs, [kI6], [prm]
where
dn
is the disk number O,l, ••• ,n-l
fsc
is the first sector number (usually 0 or 1)
lsc
is the last sector number on a track
skf
is optional "skew factor" for sector translate
bls
is the data block size (1024,2048, ••• ,16384)
dks
is the disk size in bls increments (word)
is the number of directory elements (word)
dir
cks
is the number of dir elements to checksum
ofs
is the number of tracks to skip (word)
is an optional 0 which forces 16K/directory entry
k16
prm
is an optional 0 which marks drive as permanent
for convenience, the form
dn,dm
defines disk dn as having the same characteristics as
a previously defined disk dm.

a standard four
disks
diskdef
dsk
set
rept

drive MP/M I I system is defined by
4
0,1,26,6,1024,243,64,64,2

o
3

All Information Presented Here is Proprietary to Digital Research
61

MP/M II System Guide
dsk

Appendix A

Disk Def Macro

set
dsk+l
diskdef %dsk,O
endm
endef

the value of "begdat" at the end of assembly defines the
beginning of the uninitialize ram area above the bios,
while the value of "enddat" defines the next location
following the end of the data area. the size of this
area is given by the value of "datsiz" at the end of the
assembly. note that the allocation vector will be quite
large if a large disk size is defined with a small block
size.
;

dskhdr

macro
dn
define
a
single disk header list
; ;
dpe&dn: dw
xlt&dn,OOOOh
;translate table
dw
OOOOh,OOOOh
;scratch area
dw
dirbuf,dpb&dn
;dir buff,parm block
dw
csv&dn,alv&dn
;check, alloc vectors
endm
;

disks
i i

ndisks
dpbase
; ;

dsknxt
dsknxt

dpbhdr
dpb&dn

macro
nd
define nd disks
set
nd
; ; for later reference
equ
;base of disk parameter blocks
$
generate the nd elements
set
0
rept
nd
dskhdr %dsknxt
set
dsknxt+l
endm
endm
macro
equ
endm

dn
;disk parm block

$

;

ddb
i ;

ddw
i ;

gcd
; i
i ;
i ;

gcdm
gcdn
gcdr

macro
data,comment
define a db statement
db
data
endm
macro
data,comment
define a dw statement
dw
data
endm

comment

comment

macro
m,n
greatest common divisor of m,n
produces value gcdn as result
(used in sector translate table generation)
set
m
;;variable for m
set
n
;ivariable for n
set
0
i;variable for r

All Information Presented Here is Proprietary to Digital Research
62

MP/M II System Guide

gcdx
gcdr

gcdm
gcdn

rept
set
set
if
exitm
endif
set
set
endm
endm

Appendix A

Disk Def Macro

65535
gcdm/gcdn
gcdm - gcdx*gcdn
gcdr = 0
gcdn
gcdr

;

diskdef macro
dn,fsc,lsc,skf,bls,dks,dir,cks,ofs,kl6
generate the set statements for later tables
; ;
cksz
set
(cks)/4
if
nul lsc
current disk dn same as previous fsc
; ;
dpb&dn equ
dpb&fsc ;equivalent parameters
als&dn equ
als&fsc ;same allocation vector size
css&dn equ
css&fsc ;same checksum vector size
xlt&dn equ
xlt&fsc ;same translate table
else
secmax set
lsc-(fsc)
;;sectors O••• secmax
sectors set
secmax+l;;number of sectors
als&dn set
(dks)/8 ;;size of allocation vector
if
((dks) mod 8) ne 0
als&dn set
als&dn+l
endif
css&dn set
cksz
;;number of checksum elements
generate the block shift value
; ;
blkval set
bls/l28 ;;number of sectors/block
blkshf set
0
;;counts right O's in blkv~l
blkmsk set
0
;;fills with lis from right
rept
16
;;once for each bit position
if
blkval=l
exitm
endif
otherwise, high order 1 not found yet
; ;
blkshf set
blkshf+l
blkmsk set
(blkmsk shl 1) or 1
blkval set
blkval/2
endm
generate the extent mask byte
; ;
blkval set
bls/1024
;;number of kilobytes/block
extmsk set
0
;;fill from right withl's
rept
16
if
blkval=l
exitm
endif
otherwise
more to shift
; i
extmsk set
(extmsk shl 1) or 1
blkval set
blkval/2
endm
may be double byte allocation
; i
if
(dks) > 256
extmsk set
(extmsk shr 1)
All Information Presented Here is Proprietary to Digital Research
63

MP/M II System Guide

i ;

extmsk
i i

dirrem
dirbks
dirblk

ii
ii

dirblk
dirrem
dirrem

; ;

xlt&dn
xlt&dn
; ;

nxtsec
nxtbas
; ;

neltst
; ;
; i

nelts
xlt&dn

Appendix A

Disk Def Macro

endif
may be optional [0] in last position
if
not nul k16
set
k16
endif
now generate directory reservation bit vector
set
dir
iii remaining to process
set
bls/32 iinumber of entries per block
set
o
iifill with l's on each loop
rept
16
if
dirrem=O
exitm
endif
not complete, iterate once again
shift right and add 1 high order bit
set
(dirblk shr 1) or 8000h
if
dirrem > dirbks
set
dirrem-dirbks
else
set
0
endif
endm
dpbhdr dn
iigenerate equ $
ddw
%sectors,<isec per track>
ddb
%blkshf,<iblock shift>
ddb
%blkmsk,<iblock mask>
ddb
%extmsk,<iextnt mask>
ddw
%(dks)-l,<idisk size-I>
ddw
%(dir)-l,<idirectory max>
ddb
%dirblk shr 8,<iallocO>
ddb
%dirblk and Offh,<iallocl>
if
nul prm
ddw
%(cks)/4,<icheck size>
else
ddw
8000h+cksz,<ipermanent disk with check size>
endif
ddw
%OfS,<ioffset>
generate the translate table, if requested
if
nul skf
equ
0
ino xlate table
else
if
skf = 0
equ
o
inO xlate table
else
generate the translate table
set
0
iinext sector to fill
set
0
iimoves by one on overflow
gcd
%sectors,skf
gcdn = gcd(sectors,skew)
set
sectors/gcdn
neltst is number of elements to generate
before we overlap previous elements
set
neltst ;icounter
equ
$
;translate table
rept
sectors ;;once for each sector

All Information Presented Here is Proprietary to Digital Research
64

MP/M II System Guide

nxtsec
nxtsec
nelts
nxtbas
nxtsec
nelts

if
ddb
else
ddw
endif
set
if
set
endif
set
if
set
set
set
endif
endm
endif
endif
endm

Appendix A

Disk Def Macro

sectors < 256
%nxtsec+(fsc)
%nxtsec+(fsc)
nxtsec+(skf)
nxtsec >= sectors
nxtsec-sectors
nelts-l
nelts = 0
nxtbas+l
nxtbas
neltst
; ; end of nul fac test
; ; end of nul bls test

;

defds
lab:

macro
ds
endm

lab,spa.ce
space

Ids

macro
defds
endm

lb,dn,val
lb&dn,%val&dn

;

endef

macro
generate the necessary ram
begdat equ
$
dirbuf: ds
128
;directory
dsknxt set
0
rept
ndisks
;;once for
Ids
alv,%dsknxt,als
Ids
csv,%dsknxt,css
dsknxt set
dsknxt+l
endm
enddat equ
$
datsiz equ
$-begdat
o
;force out
db
force:
endm
; ;

data areas
access buffer
each disk

last byte in hex file

;

All Information Presented Here is Proprietary to Digital Research

65

Appendix B
Sector Deblocking Algorithms for MP/M II
page

0

,.*********************************************************

*
*
*

,.*
i*

Sector Deblocking Algorithms for MP/M II V2.0

,.*
,.*********************************************************
smask
i ;
; ;

@y
@x
; ;

ii

@y
@x

utility macro to compute sector mask
macro
hblk
compute 10g2 (hblk) , return @x as result
(2 ** @x = hblk on return)
set
hblk
set
0
count right shifts of @y until = 1
rept
8
if
@y = 1
exitm
endif
@y is not 1, shift right one position
set
@y shr 1
set
@x + 1
endm
endm

i

0800
0200
0014
0004
0050
0003

=
=
=
=
=
=

0002

,.*****************************************************
*
,.*
;*
MP/M to host disk constants
*
*
,.*
,.*****************************************************
blksiz
hstsiz
hstspt
hstblk
cpmspt
secmsk
secshf

equ
equ
equ
equ
equ
equ
smask
equ

2048
512
20
hstsiz/128
hstblk * hstspt
hstblk-l
hstblk
@x

iMP/M a 110 cat i.o n size
ihos t disk sector size
ihost disk sectors/trk
iMP/M sects/host buff
iMP/M sectors/track
isector mask
icompute sector mask
i 10g2 (hstblk)

i

,.*****************************************************

·*
·*

I

,· *

BOOS constants on entry to write

*
*

*

I

.*****************************************************
wrall
equ
a
iwrite to allocated
I

0000 =
0001 =
0002 =

wrdir
wrual

equ
equ

1
2

iwrite to directory
iwrite to unallocated

i

,.*****************************************************
All Information Presented Here is Proprietary to Digital Research
67

MP/M II System Guide

,· *
,· *

,· *
,· *

Appendix B

Sector Deblocking

The BDOS entry points given below show the
code which is relevant to deblocking only.

*
*
*
*

,.*****************************************************
0000

=

dpbase

DISKDEF macro, or hand coded tables go here
equ
$
idisk param block base

boot:
wboot:

0000
0001
0004
0007

ienter here on system boot to initialize
xra
a
;0 to accumulator
sta
hstact
;host buffer inactive
sta
unacnt
;clear" unalloc count
ret

AF
326901
326801
C9
;

home:

0008
OOOB
OOOC
OOOF

;home the selected disk
Ida
hstwrt
;check for pending write
ora
a
jnz
homed
sta
hstact
;clear host active flag

3A6AOI
B7
C21200
326901
homed:

0012 C9

ret
;

seldsk:

0013
0014
0017
0018

;select
mov
sta
mov
mvi
rept
dad
endm
DAD
DAD
DAD
DAD
lxi
dad
ret

79
326001
6F
2600

001A+29
001B+29
001C+29
001D+29
001E 110000
0021 19
0022 C9

disk
a,c
sekdsk
l,a

iselected disk number
;seek disk number
;disk number to HL

h,O
;multiply by 16

4
h
H
H
H
H

d ,dpbase
d

;base of parm block
;hl=.dpb(curdsk)

;

settrk:

0023
0024
0025
0028

;set track given by registers BC
mov
h,b
mov
l,c
shld
sektrk
itrack to seek
ret

60
69
226101
C9
;

setsec:

0029 79
002A 326301
002D C9

;set sector given by register c
mov
a,c
sta
seksec
isector to seek
ret

All Information Presented Here is Proprietary to Digital Research

68

MP/M II System Guide

Appendix B

Sector Deblocking

setdma:
002E
002F
0030
0033

;set dma address given by BC
mov
h,b
mov
l,e
shld
dmaadr
ret

60
69
227401
C9
;

sectran:
;translate sector number BC
mov
h,b
mov
l,e
ret

0034 60
0035 69
0036 C9
;

.*****************************************************

I

·*
·*

I
I

·*

I

The READ entry point takes the place of
the previous BIOS defintion for READ.

*
*

*

.*
*
.*****************************************************

I

I

read:
;read the selected MP/M sector
xra
a
sta
unacnt
;unacnt = 0
inr
a
sta
readop
;read operation
rsf1ag
;must read data
st~
a,wrual
mvi
sta
wrtype
;treat as unalloc
jmp
rwoper
; to perform the read

0037 AF
0038 326BOI
0038 3C
003C 327201
003F 327101
0042 3E02
0044 327301
0047 C3B500
;

.*****************************************************

I

·*

I

·*

I

·.**

I

The WRITE entry point takes the place of
the previous BIOS defintion for WRITE.

I

*
*
**

.*****************************************************

I

write:
004A AF
0048 327201
004E 79
004F 327301
0052 E602
0054 CA6EOO

;write the selected MP/M sector
xra
a
;0 to accumulator
sta
readop
;not a read operation
mov
a,c
;write type in c
sta
wrtype
ani
wrua1
;write unallocated?
;check for unalloc
jz
chkuna

0057
0059
005C
005F
0062
0065
0068
0068

write to unallocated, set parameters
rnvi
a,blksiz/128
;next unalloc recs
sta
unacnt
Ida
sekdsk
;disk to seek
unadsk
sta
;unadsk = sekdsk
sektrk
lhld
shld
unatrk
;unatrk = sectrk
seksec
Ida
sta
una sec
;unasec = seksec

3EI0
326801
3A6001
326COI
2A6101
226D01
3A6301
326F01

All Information Presented Here is Proprietary to Digital Research
69

MP/M II System Guide

Appendix B

Sector Deblocking

;

chkuna:
006E 3A6B01
0071 B7
0072 CAADOO

;check for write to unallocated sector
Ida
unacnt
;any una1loc remain?
ora
a
al10c
;skip if not
jz

0075
0076
0079
007C
007F
0080

more unallocated records remain
dcr
a
iunacnt = unacnt-1
sta
unacnt
Ida
sekdsk
;same disk?
1xi
h,unadsk
cmp
m
isekdsk = unadsk?
alloc
jnz
iskip if not

3D
326801
3A6001
216C01
BE
C2ADOO

0083 216D01
0086 CD5201
0089 C2ADOO

disks are the same
lxi
h,unatrk
call
sektrkcmp
jnz
a1loc

008C
008F
0092
0093

3A6301
216F01
BE
C2ADOO

tracks are the same
Ida
seksec
lxi
h,unasec
cmp
m
jnz
alloc

0096
0097
0098
009A

34
7E
PESO
DAA600

match, move to next sector for future ref
inr
m
;unasec = unasec+1
mov
a,m
iend of track?
cpi
cpmspt
icount MP/M sectors
jc
noovf
;skip if no overflow

009D
009F
00A2
00A3

3600
2A6D01
23
226D01

overflow to next track
mvi
m,O
lhld
unatrk
inx
h
unatrk
shld

;sektrk = unatrk?
;skip if not
; same. sector?
iseksec = unasec?
;skip if not

;unasec

= 0

;unatrk

= unatrk+1

;

noov f:
;match found, mark as unnecessary read
xra
a
;0 to accumulator
sta
rsflag
;rsflag = 0
jmp
rwoper
ito perform the write

00A6 AF
aOA7 327101
OOAA C3B500
;

al1oc:
;not an unallocated record, requires pre-read
;0 to aecum
xra
a
;unacnt = 0
sta
unacnt
;1 to accum
inr
a
sta
rsflag
;rsflag = 1

OOAD AF
OOAE 326B01
00B1 3C
00B2 327101
;

,.*****************************************************
,-*
*
;*

,. *

Common code for READ and WRITE follows

*

*

All Information Presented Here is Proprietary to Digital Research
70

MP/M II System Guide

00B5 AE'
00B6 327001
00B9 3A6301

00BC+B7
00BD+1F
00BE+B7
00BF+1F
OOCO 326801

Appendix B

Sector Deblocking

,.*****************************************************
rwoper:
;enter here to perform the read/write
xra
a
;zero to accum
sta
erflag
;no errors (yet)
Ida
seksec
;compute host sector
rept
secshf
ora
a
;carry = 0
rar
ishift right
endm
ORA
A
;CARRY = 0
RAR
iSHIFT RIGHT
A
ORA
;CARRY = 0
RAR
iSHIFT RIGHT
sta
sekhst
;host sector to seek
active host sector?
lxi
h,hstact
mov
a,m
mvi
m,l
ora
a
jz
filhst

00C3 216901
00C6 7E
00C7 3601
00C9 B7
OOCA CAF100

;host active flag
;always becomes 1
;was it already?
;fill host if not

i

OOCD
0000
0003
0004

host buffer active, same as seek buffer?
Ida
sekdsk
lxi
h,hstdsk
;same disk?
cmp
m
isekdsk = hstdsk?
jnz
nomatch

3A6001
216401
BE
C2EAOO

0007 216501
OODA CD5201
0000 C2EAOO

same disk, same track?
lxi
h,hsttrk
call
sektrkcmp
jnz
nomatch

OOEO
00E3
00E6
00E7

same disk, same track, same buffer?
Ida
sekhst
lxi
h,hstsec
;sekhst = hstsec?
cmp
m
match
jz
iskip if match

3A6801
216701
BE
CAOE01

;sektrk = hsttrk?

nomatch:
iproper
Ida
ora
cnz

OOEA 3A6A01
OOED B7
OOEE C45E01

disk, but not correct sector
hstwrt
ihost written?
a

writehst

;clear host buff

;

filhst:
00F1
00F4
00F7
OOFA
OOFD
0100
0103

3A6001
326401
2A6101
226501
3A6801
326701
3A7101

imay have to fill the host buffer
Ida
sekdsk
sta
hstdsk
1hld
sektrk
shld
hsttrk
Ida
sekhst
sta
hstsec
Ida
rsflag
;need to read?

All Information Presented Here is Proprietary to Digital Research
71

MP/M II System Guide
ora
cnz
xra
sta

0106 B7
0107 C45FOI
010A AF
010B 326AOI

Appendix B

a
readhst
a
hstwrt

Sector Deblocking

jyes, if 1
to c3ccum
jno pending write

jO

j

match:

0110 117601
0120 19
0121 EB
0122 2A7401
0125 OE80
0127 3A7201
012A B7
012B C23401

jCopy data to or from buffer
Ida
seksec
jmask buffer number
ani
secmsk
ileast signif bits
mov
1,a
iready to shift
mvi
h,O
;double count
rept
7
ishift left 7
dad
h
endm
DAD
H
DAD
H
DAD
H
DAD
H
DAD
H
DAD
H
H
DAD
hI has relative host buffer address
lxi
d,hstbuf
ihl = host address
dad
d
jnow in DE
xchg
dmaadr
iget/put MP/M data
Ihld
;length of move
c,128
mvi
jwhich way?
Ida
readop
ora
a
iskip if read
jnz
rwmove

012E 3EOI
0130 326AOI
0133 EB

write operation, mark and switch direction
mv i
a, 1
sta
hstwrt
ihstwrt = 1
;source/dest swap
xchg

010E
0111
0113
0114

3A6301
E603
6lt"'
2600

0116+29
0117+29
0118+29
0119+29
011A+29
0118+29
011C+29

rwmove:
0134
0135
0136
0137
0138
0139

lA
13
77
23
OD
C23401

iC initially 128, DE is source, HL is dest
;source character
Idax
d
inx
d
jto dest
mav
m,a
inx
h
dcr
c
iloop 128 times
rwmove
jnz

013C
013F
0141
0144

3A7301
E601
3A7001
C8

data has been moved to/from host buffer
jwrite type
Ida
wrtype
ito directory?
ani
wrdir
jin case of errors
Ida
erf1ag
ino further processing
rz

0145 B7
0146 CO
0147 AF

clear host buffer for directory write
ora
a
jerrors?
rnz
iskip if so
xra
a
jO to accum

All Information Presented Here is Proprietary to Digital Research
72

MP/M II System Guide
0148
014B
014E
0151

sta
call
Ida
ret

326AOI
CD5EOI
3A7001
C9

Appendix B
hstwrt
writehst
erflag

Sector Deblocking

;buffer written

;

,.*****************************************************
,· *
*
,· *
Utility subroutine for 16-bit compare
*
,· *
*
,.*****************************************************
0152
0153
0156
0157
0158

EB
216101
1A
BE
CO

0159
015A
015B
015C
015D

13
23
1A
BE
C9

sektrkcmp:
;HL = .unatrk or .hsttrk, compare with sektrk
xchg
lxi
h,sektrk
1dax
d
;low byte compare
cmp
m
;same?
rnz
;return if not
low bytes equal, test high Is
inx
d
inx
11
ldax
d
cmp
m
;sets flags
ret

,

,.*****************************************************
,· *
*
,· *
WRITEHST performs the physical write to
*

,· *
the host disk, READHST reads the physical
*
,· *
disk.
*
*
,.*
,.*****************************************************

015E C9

writehst:
;hstdsk = host disk i, hsttrk = host track #,
;hstsec = host sect I. write "hstsiz" bytes
;from hstbuf and return error flag in erflag.
;return erflag non-zero if error
ret
;

readhst:

015F C9

;hstdsk = host disk #, hsttrk = host track I,
;hstsec = host sect I. read "hstsiz" bytes
;into hstbuf and return error flag in erflag.
ret

;

,.*****************************************************
*
,.*
;*
Unitialized RAM data areas
*
*
,.*
,.*****************************************************
;

0160
0161
0163

sekdsk: ds
sektrk: ds
seksec: ds

1
2
1

;seek disk number
;seek track number
;seek sector number

0164

hstdsk: ds

1

;host disk number

All Information Presented Here is Proprietary to Digital Research
73

MP/M II System Guide

Appendix B

Sector Deblocking

0165
0167

hsttrk: ds
hstsec: ds

2
1

;host track number
;host sector number

0168
0169
016A

sekhst: ds
hstact: ds
hstwrt: ds

1
1
1

;seek shr secshf
;host active flag
;host written flag

016B
016C
016D
016F

unacnt:
unadsk:
unatrk:
unasec:

ds
ds
ds
ds

1
1
2
1

;unalloc rec cnt
;last unalloc: disk
;last unalloc track
;last unalloc sector

0170
0171
0172
0173
0174
0176

erflag:
rsflag:
readop:
wrtype:
dmaadr:
hstbuf:

ds
ds
ds
ds
ds
ds

1

1
1
1
2
hstsiz

;error reporting
iread sector flag
; 1 if read operation
iwrite operation type
;last dma address
;host buffer

;

i

,.*****************************************************
*
,.*
,. *
The ENDEF macro invocation goes here
*
,. *
,.******************************************************
0376

end

OOAD ALLOC
0050 CPMSPT
OOFI FILHST
0004 HSTBLK
0200 HSTSIZ
010E MATCH
015F READHST
00B5 RWOPER
0160 SEKDSK
0152 SEKTRKCMP
0023 SETTRK
016D UNATRK
004A WRITE

0800 BLKSIZ
0174 DMAADR
0008 HOME
0176 HSTBUF
0014 HSTSPT
OOEA NOMATCH
0172 READOP
0003 SECMSK
0168 SEKHST
0013 SELDSK
016B UNACNT
0000 WBOOT
015E WRITEHST

0000 BOOT
0000 DPBASE
0012 HOMED
0164 HS'fDSK
0165 HSTTRK
00A6 NOOVF
0171 RSFLAG
0002 SECSHF
0163 SEKSEC
002E SETDMA
016C UNADSK
0000 WRALL
0173 WRTYPE

006E CHKUNA
0170 ERFLAG
0169 HSTACT
0167 HSTSEC
016A HSTWRT
0037 READ
0134 RWMOVE
0034 SECTRAN
0161 SEKTRK
0029 SETSEC
016F UNASEC
0001 WRDIR
0002 WRUAL

All Information Presented Here is Proprietary to Digital Research
74

Appendix C
Sample MP/M II Loader BIOS
page
title

o
'Skeleton MP/M-80 V2.0 Ldrbios'

Copyright (C) 1978, 1979, 1980, 1981
Digital ,Research
Box 579, Pacific Grove
California, 93950
0000 =
FFFF =

false
true

1700
0080

=

buff

equ
equ

o
not false

org

\ 1700h

equ

,0080h

;default buffer address

jump vector for indiviual routines
1700 C33317
1703 C33317
1706 C33617
1709 C33417
170C C33517
170F C33917
1712 C33817
1715 C33717
1718 C33C17
171B C33B17
171E C33D17
1721 C33E17
1724 C33F17
1727 C34117
172A C34217
172D C33A17
1730 C34017

wboote:

jmp
jmp
jmp
jmp
jrnp
jrnp
jrnp
jmp
jrnp
jrnp
jrnp
jrnp
jrnp
jrnp
jrnp
jmp

jmp

boot
wboot
const
conin
conout
list
punch
reader
home
seldsk
settrk
setsec
setdma
read
write
list$st
sect$tran

list status poll
sector translation

boot:
wboot:
gocpm:
1733 C9

ret
crtin:

1734 C9

crt:

crtout:
1735 C9

input

ret
crt: output
ret

All Information Presented Here is Proprietary to Digital Research
75

MP/M II System Guide

Appendix C

.

, crt: status

crtst:
1736 C9

MP/M Loader BIOS

ret
ttyin:

1737 C9

i tty: input
ret

ttyout:
1738 C9

i tty: output

ret
1ptout:

1739 C9

i lpt: output

ret
1pt$st:

173A C9

ret

1734 =
1736 =
1735 =
1737 =
1738 =
1739 =
173A =

conin
const
conout
reader
punch
list
1istst

173BC9

seldsk: iselect disk given by register c
ret

equ
equ
equ
equ
equ
equ
equ

crtin
crtst
crtout
ttyin
ttyout
lptout
1ptst

i

173C C9

imove to home position
ret

1730 C9

settrk: ;set track number given by c
ret

173E C9

setsec: iset sector number given by c
ret

home:
i

i

i
setd~a:

173F C9

iset dma address given by regs b,c
ret

i

1740 C9

sect$tran:
ret

i

translate the sector # in <c

i

read:
1741 C9

iread next disk record (assuming disk/trk/sec/
ret

i

write:
1742 C9

idisk write function
ret

;

1743

end

All Information Presented Here is Proprietary to Digital Research

76

Appendix D
Simple X10S Source Listing
page
title
cseg
maclib

o
'MP/M II V2.0

DSC-2 Basic & Extended I/O

diskdef

bios for micro-2 computer

=

o

=

false
true

equ
equ

not false

FFFF =
FFFF =

debug
ldcmd

equ
equ

true
true

FFFF

=

MHz4

equ

true

0086

=

0000
FFFF

if
dlycnst equ
else
dlycnst equ
endif

;pdisp
;xdos

MHz4
086h
054h

org

OOOOh

equ
equ

$-3
pdisp-3

jump vector for individual subroutines
jmp
coldstart
;cold start
jmp
commonbase

0000 C34900
wboo t:
0003 C35AOO
0006 C35FOO
0009 C36800
OOOC C37100
OOOF C3DFOO
0012 C38100
0015 C38100
0018 C3CA02
OOIB C3DB02
OOIE C30503
0021 C32203
0024 C33A03
0027 C34003
002A C34503
002D C30101
0030 C32803

jmp
jmp
jmp
jmp
jmp
jmp
jmp
jmp
jmp
jmp
jmp
jmp
jmp
jmp
jmp
jmp

warmstart
const
conin
conout
list
rtnempty
rtnempty
home
seldsk
settrk
setsec
setdma
read
write
pollpt
sectran

;warm start
;console status
;console character in
;console character out
;list character out
;punch not implemented
;reader not implemente
;move head to home
;select disk
;set track number
;set sector number
;set dma address
;read disk
;write disk
;list status
;sector translate

All Information Presented Here is Proprietary to Digital Research
77

MP/M II System Guide
jmp
jmp
jmp
jmp
jmp
jmp
jmp
db
jmp

0033 C30C02
0036 C3F301
0039 C30D02
003C C31302
003F C31802
0042 C31F02
0045 C32202
0048 00

Appendix D
selmemory
polldevice
startclock
stopclock
exitregion
maxconsole
systeminit

o
idle

Simple XIOS Source

; select memory
poll device
start clock
stop clock
exit region
i maximum console numb
system initializatio
force use of interna
idle procedure

;

0049 C35AOO
004C C30000
004F C30000
0052 C30000
0055 C30000
0058 0000

commonbase:
jmp
swtuser: jmp
swtsys:
jmp
pdisp:
jmp
xdos:
jmp
sysdat:
dw

coldstart
$-$
$-$
$-$
$-$
$-$

005A OEOO
005C C35500

coldstart:
warmstart:
mvi
jmp

c,O
xdos

system reset, termin

;

;1/0 handlers
Console Bios

MP/M II V2.0
;

0003

=

nmbcns

equ

number of consoles

3

0083 =
0086 =
0089 =
008B =
008D =
0090 =

poll
equ
makeque equ
readque equ
writeque equ
xdelay equ
create equ

131
134
137
139
141
144

0000 =
0001 =
0002 =
0003 =
0004 =

pllpt
plcoO
plco2
plco3
plci3

1
2
"3

=

plciO

0005

equ
equ
equ
equ
equ
if
equ
endif

o

4
debug
5

; XDOS poll function
XDOS make queue function
XDOS read queue function
XDOS write queue function
XDOS delay function
XDOS1 create process function
poll
poll
poll
poll
poll

printer
console
console
console
console

out #0
out #1
out #2 (Port 3)
in #2 (Port 3)

poll console in #0

;

const:
005F
0062
0064
0066

CD7AOO
8EOO
0901
C301

call
dw
dw
dw

ptbljmp
ptOst
pt2st
pt3st

Console
compute
console
console
console

Status
and jump to hndlr
#0 status routine
#1 (Port 2) status r
#2 (Port 3) status r

All Information Presented Here is Proprietary to Digital Research
78

MP/M II System Guide

Appendix D

conin:
0068
006B
006D
006F

CD7AOO
9000
9901
CBOI

0071
0074
0076
0078

C07AOO
C200
A701
0701

Simple XIOS Source

call
dw
dw
dw

ptbljmp
ptOin
pt2in
pt3in

Console
compute
console
console
console

Input
and jump to hndlr
iO input
il (Port 2) input
i2 (Port 3) input

call
dw
dw
dw

ptbljmp
ptOout
pt20ut
pt30ut

Console
compute
console
console
console

Output
and jump to hndlr
*0 output
*1 (Port 2) output
#2 (Port 3) output

conout:

;

ptbljmp:
007A 7A
007B FE03
007D OA8300
0080 Fl
0081 AF
0082 C9
0083
0084
0085
0086
0088
0089
008A
0088
008C
0080

compute and jump to handler
d = console *
do not destroy d

mov
cpi
jc
pop
rtnempty:
xra
ret
tbljmp:
add
pop
mov
mvi
dad
mov
inx
mov
xchg
pchl

87
El
SF
1600
19
5E
23
56
EB
E9

a,d
nmbcns
tbljmp
psw

throwaway table address

a
compute and jump to handler
a = table index
double table index for adr 0
return adr points to jump tb

a
h

e,a
d,O
d

e,m

add table index * 2 to tbl b
get handler address

h

d,m
jump to computed cns handler

ASCII Character Equates
005F
007F
0020
0008
005F

=

=
=

=
=

;

uline
rubout
space
backsp
altrub

equ
equ
equ
equ
equ

5fh
7fh
20h
8h
uline

; Input / Output Port Address Equates
0040 =
0041 =
0041 =
0048 =
0049 =
0049 =
0050 =
0051 =

;

dataO
stsO
cdO
datal
stsl
cdl
data2
sts2

equ
equ
equ
equ
equ
equ
equ
equ

40h
dataO+l
stsO
48h
datal+1
stsl
SOh
data2+1

All Information Presented Here is Proprietary to Digital Research
79

MP/M II System Guide
0051 =
0058 =
0059 =
0059 =

cd2
data3
sts3
cd3

equ
equ
equ
equ

Appendix D

Simple XIOS Source

sts2
58h
data3+1
sts3

;

; Poll Console #0 Input
;

if

debug

if
Ida
ora
mvi
rnz
endif

ldcmd
ptOcntr
a
a,O

in
ani
rz
mvi
ret

stsO

if
lxi
mov
ora
jz
dcr
Ihld
mov
inx
shld
ret

ldcmd
h,ptOcntr
a,m
a
IdcmdOempty
m

db

IdcmdOempty-ptOldcmd

polciO:
ptOst:
008E
0091
0092
0094

3AAFOO
87
3EOO
CO

0095 DB41
0097 E602
0099 C8
009A 3EFF
009C C9

2

a,Offh

;

ptOin:
009D 21AFOO
OOAO 7E
OOAI B7
00A2 CAB600
00A5 35
00A6 2ABOOO
00A9 7E
OOAA 23
OOAB 22BOOO
OOAE C9

ptOptr
a,m
h

ptOptr

ptOcntr:
OOAF 04
ptOptr:
OOBO B200
0082 746F6420

dw
ptOldcmd:
db
IdcmdOempty:
endif
mvi
mvi
call
in
ani
ret

00B6 OE83
00B8 lE05
OOBA CD5500
OOBD DB40
OOBF E67F
OOCI C9

ptOldcmd
'tod '

c,poll
e,plciO
xdos
dataO
7fh

else
ptOst:
return Offh if ready,
OOOh if not
All Information Presented Here is Proprietary to Digital Research
80

MP/M II System Guide
lda
ora
rz
mvi

Appendix D

Simple XIOS Source

cOinmsgcnt
a

a,Offh

r-et

Console #0 Input
;

cOinpd:
dw
db
db
dw
db
db
db
ds

36

dw
dw
dw
dw

Oc7c7h,Oc7c7h,Oc7c7h
Oc7c7h,Oc7c7h,Oc7c7h
Oc7c7h,Oc7c7h,Oc7c7h
cOinp
starting address

c2inpd

; pI
; status
32
; priority
cOinstk+18 ; stkptr
'cOin
' ; name
o
console
Of fh
; memseg

o

cOinstk:

cOinq:
dw
db
dw
dw
ds
cOinmsgcnt:
ds
ds

; ql
'cOinque • ; name
1
; msglen
4
; nmbmsgs
8
0

msgcnt
buffer

2

4

cOinqcb:
dw
dw

cOinq
chOin

db

0

; pointer
msgadr

chOin:
cOinuqcb:
dw
dw
charOin:
db

; pointer
cOinq
charOin
msgadr

o

cOinp:
mvi
lxi
call
cOinloop:
mvi
mvi
call

c,makeque
d,cOinq
xdos
; make the cOinq
c,flagwait
e,6

xdos

; wait for cO in intr flag

All Information Presented Here is Proprietary to Digital Research
81

MP/M II System Guide
mvi
lxi
call
jmp

Appendix D

Simple XIOS Source

c,writeque
d,cOinqcb
xdos
write cOin queue
cOinloop

ptOin:
mvi
lxi
call
Ida
ani
ret

; return character in reg A
c,readque
d,cOinuqcb
xdos
r~ad from cO in queu
get character
charOin
7fh
; strip parity bit

endif
Console #0 Output
;

ptOout:
;

00C2 DB41
00C4 E601
00C6 C2D200
00C9 C5
OOCA OE83
OOCC IEOI
OOCE CD5500
OODI Cl

in
ani
jnz
push
mvi
mvi
call
pop

Reg C = character to output

stsO
Olh
txOrdy
b

c,poll
e,plcoO
xdos

poll console #0 output

b

txOrdy:
mov
out
ret

00D2 79
00D3 D340
00D5 C9

a,c
dataO

poll console #0 output
polcoO:
00D6
00D8
OODA
OODB
OODD

in
ani
rz
mvi
ret

DB41
E601
C8
3EFF
C9

stsO
Olh
a,Offh

Line Printer Driver:

TI 810 Serial Printer
TTY Model 40

;

OODE 00

initflag:
db

o

printer initialization flag
List Output

list:
ptlout:

; Reg c = Character to print
OODF 3ADEOO
00E2 B7

Ida
ora

initflag

a

All Information Presented Here is Proprietary to Digital Research
82

MP/M II System Guide
00E3
00E6
00E8
OOEA

C2EDOO
3E27
D349
32DEOO

Appendix D

jnz
mvi
out
sta

ptlxx
a,27h
49h
initflag

in
ani
jnz
push
mvi
mvi
call
pop

stsl
Olh
txlrdy
b
c,poll
e,pllpt
xdos
b

mov
out
ret

a,c
datal

Simple XIOS Source

TTY Model 40 init

ptlxx:
OOED DB49
OOEF E601
OOFI C2FDOO
00F4 C5
00F5 OE83
00F7 IEOO
00F9 CD5500
OOFC Cl

poll printer output

txlrdy:
OOFD 79
OOFE D348
0100 C9

char to register a

Poll Printer Output
;

pollpt:
return Offh if ready,
OOOh if not
0101
0103
0105
0106
0108

DB49
E601
C8
3EFF
C9

in
ani
rz
mvi
ret

stsl
Olh
a,Offh

Poll Console #1

(Port 2) Input

;

pt2st:
;
;

0109 3A6FOl
OlOC B7
OlOD C8
OlOE 3EFF
0110 C9

Ida
ora
rz
mvi
ret
Console *1

return Offh if ready,
OOOh if not

c2inmsgcnt
a
a,Offh
(Port 2)

Input

;

c2inpd:
0111
0113
0114
0115
0117
OllF
0120
0121

0000
00
22
5701
6332696E20
02
FF

dw
db
db
dw
db
db
db
ds

0
; pI
0
; status
34
; priority
c2instk+18, ; stkptr
'c2in
; name
console
2
Offh
; memseg
36

dw
dw

Oc7c7h,Oc7c7h,Oc7c7h
Oc7c7h,Oc7c7h,Oc7c7h

c2instk:
0145 C7C7C7C7C7
014B C7C7C7C7C7

All Information Presented Here is Proprietary to Digital Research
83

MP/M II System Guide
0151 C7C7C7C7C7
0157 7FOI

dw
dw
c2inq:

0159
0158
0163
0165
0167

0000
6332696E71
0100
0400

016F
0171

dw
db
dw
dw
ds
c2inmsgcnt:
ds
ds

Appendix D

Simple XIOS Source

Oc7c7h,Oc7c7h,Oc7c7h
c2inp
starting address

o

'c2inque
1
4

; ql
I

;
name
msglen
nmbmsgs

8

msgcnt
buffer

2

4

c2inqcb:
0175 5901
0177 7901

dw
dw

c2inq
ch2in

db

0

; pointer
msgadr

ch2in:
0179 00
017A 5901
017C 7EOI
017E 00

c2inuqcb:
dw
dw
char2in:
db

pointer
c2inq
char2in ; msgadr

o

c2inp:
mvi
Ixi
call

017F OE86
0181 115901
0184 CD5500
0187
0189
0188
018E
0190
0193
0196

OE84
lE08
CD5500
OE88
117501
CD5500
C38701

c2inloop:
mvi
mvi
call
mvi
lxi
call
jmp

c,makeque
d,c2inq
xdos
make the c2inq
c,flagvvait
e,8
xdos
; wait for c2 in intr flag
c,writeque
d,c2inqcb
xdos
; write c2in queue
c2inloop

pt2in:
0199
0198
019E
01Al
01A4
01A6

OE89
117AOI
CD5500
3A7EOI
E67F
C9

mvi
Ixi
call
Ida
ani
ret

; return character in reg A
c,readque
d,c2inuqcb
read from c2 in queu
xdos
get character
char2in
strip parity bit
7fh

Console 11 (Port 2) Output
pt2out:
01A7 DB51
01A9 E601

in
ani

sts2
Olh

Reg C = character to output

All Information Presented Here is Proprietary to Digital Research
84

MP/M II System Guide
OIAB C2B701
OIAE C5
OlAF OE83
OlBl lE02
01B3 CD5500
01B6 Cl

Appendix D

jnz
push
mvi
mvi
call
pop

tx2rdy
b
c,poll
e,plco2
xdos
b

mov
out
ret

a,c
data2

Simple XIOS Source

poll console #1 output

tx2rdy:
01B7 79
01B8 D350
OIBA C9

poll console #1 output
;

polco2:
OIBB DB5l
OlBD E60l
OlBF C8
OICO 3EFF
01C2 C9

in
ani

sts2
Olh

rz
mvi
ret

a,Offh

Poll Console #2 (Port 3) Input
;

polci3:
pt3st:
01C3 DB59
01C5 E602
01C7 C8
01C8 3EFF
OICA C9

return Offh if ready,
OOOh if not
in
ani

sts3
2

rz
mvi
ret

a,Offh

Console #2 (Port 3) Input
;

pt3in:
OICB OEB3
OlCD lE04
OlCF CD5500
01D2 DB58
01D4 E67F
01D6 C9

; return character in reg A
mvi
mvi
call
in
ani
ret

c,poll
e,plci3
xdos
data3
7fh

poll console #0 inpu
read character
strip parity bit

Console #2 (Port 3) Output
;

pt30ut:
01D7 D859
0109 E601
OIDB C2E701
OIDE C5
OIDE' OE83
OlEl lE03
01E3 CD5500
01E6 Cl

in
ani
jnz
push
mvi
mvi
call
pop

sts3
Olh
tX3rdy
b
c,poll
e,plco3
xdos
b

mov
out

a,c
data3

; Reg C = character to output

poll console #2 (Por

tx3rdy:
01E7 79
01E8 D358

transmit character

All Information Presented Here is Proprietary to Digital Research
85

MP/M II System Guide

Appendix D

Simple XIOS Source

ret

OlEA C9

Poll Console #2

(Port 3) Output

;

polco3:
;

OIEB DB59
OIED E60l
OIEF C8
OIFO 3EFF
01F2 C9

in
ani
rz
mvi
ret
MP/M II V2.0

return Offh if ready,
OOOh if not

sts3
Olh
a,Offh

Xios

;

polldevice:
Reg C = device # to be polle
return Offh if ready,
OOOh if not
01F3
OlF4
01F6
01F9

79
FE06
DAFBOI
3E06

mov
cpi
jc
mvi

a,c
nmbdev
devok
a,nmbdev;

call

tbljmp

jump to dev poll code

dw
dw
dw
dw
dw
if
dw
endif
equ
dw

pollpt
polcoO
polco2
polco3
polci3
debug
polciO

poll
poll
poll
poll
poll

if dey # )= nmbdev,
set to nmbdev

devok:
OIFB CD8300
devtbl:
OIFE 0101
·0200 D600
0202 BBOI
0204 EBOI
0206 C30l
0208 8EOO
0006 =
020A 8100

nmbdev

printer
console
console
console
console

output
#0 output
itl output
*2 output
#2 input

poll console #0 input

($-devtbl)/2
; number of devices to
rtnemptYi bad device handler

Select / Protect Memory
;

selmemory:

020C C9

Reg BC = adr of mem descript
BC -) base
1 byte,
size
1 byte,
attrib 1 byte,
bank
1 byte.
;
this hardware does not have memory protection or
bank switching
ret
Start Clock

All Information Presented Here is Proprietary to Digital Research
86

MP/M II System Guide

Appendix 0

Simple XIOS Source

;

startclock:
will cause flag #1 to be set
at each system time unit ti
0200 3EFF
020F 322F04
0212 C9

mvi
sta
ret

a,Offh
tickn

Stop Clock
;

stopclock:
will stop flag #1 setting at
system time unit tick
0213 AF
0214 322F04
0217 C9

xra
sta
ret

a
tickn

Exit Region
;

exitregion:
EI if not preempted or in di
0218
021B
021C
0210
021E

3A3104
B7
CO
FB
C9

Ida
ora
rnz
ei
ret

preemp
a

Maximum Console Number
;

021F 3E03
0221 C9

maxconsole:
mvi
ret

a,nmbcns

;

System Initialization
;

systeminit:
;

This is the place to insert code to initialize
the time of day clock, if it is desired on each
booting of the system.

;

0222
0224
0227
022A

3EC3
323800
214702
223900

mvi
sta
lxi
shld

a,Oc3h
0038h
h, inthnd
0039h
c,create
debug
d,c2inpd

0232 CD5500

mvi
if
lxi
else
lxi
endif
call

xdos

0235 3A3004

Ida

intmsk

0220 OE90
022F' 111101

JMP INTHNO at 0038H

d,cOinpd

All Information Presented Here is Proprietary to Digital Research
87

MP/M II System Guide

Appendix D

Simple XIOS Source

0238 D360

out

60h

init interrupt mask

023A ED56

db

Oedh,056h

Interrupt Mode I
** Z80 Instruction

023C
023D
0240
0242
0244

ei
call
mvi
mvi
jmp
ret

FB
CDCA02
OE84
IE05
C35500

home
c,flagwait
e,5
xdos

*

clear first disk int
& return

Idle procedure
;

;idle:
;

ret

;

-orei
hIt
ret
MP/M II V2.0

0084 =
0085 =
008E =

flagwait equ
flagset equ
dsptch equ

; for full interrupt s
Interrupt Handlers
132
133
142

inthnd:
Interrupt handler entry poin
All interrupts gen a RST 7
Location 0038H contains a j
to INTHND.
0247 222904
024A EI
024B 222D04
024E F5
024F 210000
0252 39
0253 222B04
0256 312904
0259 D5
025A C5

shld
pop
shld
push
lxi
dad
shld
lxi
push
push

svdhl
h
svdret
psw
h,O
sp
svdsp
sp,lstintstk
d
b

025B 3EFF
025D 323104

mvi
sta

a,Offh
preemp

0260 DB60
0262 E640
0264 C28F02

in
ani
jnz

60h
01000000b
clk60hz

read interrupt mask
test & jump if clk i

0267 DB80

in

stat

read disk status por

save users stk ptr
lcl stk for intr hnd

set preempted flag

All Information Presented Here is Proprietary to Digital Research
88

Appendix D

MP/M II System Guide
0269 E608
0268 C27802

026E D851
0270 E602
0272 C28002

ani
jnz

08h
diskintr

if
in
ani
jnz
endif

not debug
stsO
2
conOin

in
ani
jnz

sts2

Simple XIOS Source

2

con2in
test/handle other in

jmp

0275 C38502
0278
0279
0278
027D

AF
D380
lE05
C38702

diskintr:
xra
out
mvi
jmp

intdone

a
cmdl

; reset disk interrupt

e,5
concmn

set flag #5

if

not debug

in
sta
mvi
jmp
endif

dataO
chOin
concmn

set flag #6

in
sta
mvi
jmp

data2
ch2in
e,8
concmn

set flag #8

mvi
call
jmp

c,flagset
xdos
intdone

028F 3A2F04
0292 87

Ida
ora

tickn
a

0293
0296
0298
029A

jz
mvi
mvi
call

notickn
c,flagset
e,l
xdos

lxi
dcr
jnz

m

conOin:

e,6

con2in:
0280 D850
0282 327901
0285 lE08
concmn:
0287 OE85
0289 CD5500
028C C38502
clk60hz:
60 Hz clock interrup

CA9D02
OE85
lEOl
CD5500

test tickn, indicate
delayed process(es)

set flag #1 each tic

notickn:
029D 210004
02AO 35
02Al C2AD02

h,cnt60
dec 60 tick cntr

notlsec

All Information Presented Here is Proprietary to Digital Research
89

MP/M II System Guide
02A4 363C
02A6 OE85
02A8 lE02
02AA CD5500

Appendix D

mvi
mvi
mvi
call

m,60
c, flagset
e ,,2
xdos

xra
out
Ida
out
jmp

a
60h
intmsk
60h
intdone

Simple XIOS Source

set flag #2 @ 1 sec

notlsec:
02AD AF
02AE D360
02BO 3A3004
02B3 D360

; ack clock interrupt

Other interrupt handlers
i

intdone:
02B5 AF
02B6 323104
02B9 CI
02BA Dl
02BB 2A2B04
02BE F9
02BF Fl
02CO 2A2D04
02C3 E5
02C4 2A2904

xra
a
sta
preemp ; clear preempted flag
pop
b
pop
d
lhld
svdsp
sphl
restore stk ptr
pop
psw
lhld
svdret
push
h
lhld
svdhl
The following dispatch call will force round robin
scheduling of processes executing at the same prior
each 1/60th of a second.
Note: Interrupts are not enabled until the dispatche
resumes the next process.
This prevents interrupt
over-run of the stacks when stuck or high frequency
interrupts are encountered.
jmp
pdisp
i MP/M dispatch

02C7 C35200

Disk I/O Drivers
Disk Port Equates
;

0080
0080
0081
0082
0083

=
=
=
=
=

cmdl
stat
haddr
1addr
cmd2

equ
equ
equ
equ
equ

80h
80h
81h
82h
83h

j

home:

02CA CDDA03
02CD 3600
02CF DB80
02D1 E604
02D3 C8

imove to the track 00 position of current driv
call
head10ad
i h,l point to word with track for selected disk
homel:
mvi
iSet current track ptr back to
m,OO
in
stat
jread fdc status
ani
itest track 0 bit
4
rz
ireturn if at 0

All Information Presented Here is Proprietary to Digital Research
90

MP/M II System Guide
stc
call
jmp

02D4 37
02D5 CDC203
02D8 C3CD02

Appendix D

step
homel

Simple XIOS Source

;direction=out
;step one track
;loop

;

seldsk:
02DB
02DE
02DF
02El

210000
79
FE02
DO

02E2
02E3
02E6
02E7
02E9
02EC

AF
323A04
79
E607
323904
4F

02ED
02FO
02F2
02F3
02F5

3A3C04
E6FO
Bl
F608
323C04

02F8 69
02F9 29
02FA 29
02FB 29
02FC 29
02FD 113F04
0300 19
0301 226E04
0304 C9

;drive number in c
lxi
h,O
iOOOO in hI produces select er
mov
a,c
;a is disk number 0 ••• ndisks
cpi
ndisks ;less than ndisks?
rnc
;return with HL = 0000 if not
;make sure dummy is 0 (for use in double add to h,l)
xra
a
sta
dummy
mov
a,c
ani
07h
iget only disk select bits
sta
diskno
mov
c, a
;set up the second command port
Ida
port
iclear out old disk select bit
ani
OfOh
;put in new disk select bits
ora
c
ori
OSh
i force double density
sta
port
proper disk number, return dpb element address
mov
l,c
dad
h
;*2
dad
h
;*4
dad
h
;*8
dad
h
; *16
d,dpbase
lxi
dad
d
;HL=.dpb
shld
tran
;translate table base
ret
;

0305 CDDA03
0308 79
0309 BE
030A C8
030B CDC203
030E 79
030F BE
0310 C20B03

0313 3E14

settrk: ;set track given by register c
call
headload
;h,l reference correct track indicator according to
;selected disk
;desir"ed track
mov
a,c
cmp
m
rz
;we are already on the track
settkx:
call
step
;step track-carry has directio
;Step will update trk indicato
mov
a,c
cmp
rn
;are we where we want to be
settkx ;not yet
jnz
;have stepped enough
seekrt:
;need 10 msec delay for final step time and head settl
rnvi
a,20d
call
delay
ret
;end of settrk routine

All Information Presented Here is Proprietary to Digital Research
91

MP/M II System Guide

i

delay:
0315 C5

Appendix D

Simple XIOS Source

idelay fqr c[A] X .5 milliseconds
push
b

delayl:
0316 OE86

mvi

c,dlycnst iconstant adjusted to .5 ms

dcr
jnz
dcr
jnz
pop
ret

c
delay2
a
delayl

delay2:
0318
0319
031C
031D
0320
0321

OD
C21803
3D
C21603
Cl
C9

0322
0323
0324
0327

OC
79
323604
C9

b

iend of delay routine

setsec: iset sector given by register c
inr
c
a,c
mov
sta
sector
ret
i

sectran:

isector number in c
itranslate logical to physical sector
Ihld
tran
ihl= •• translate
mov
e,m
iE=low(.translate)
inx
h
mov
d,m
iDE=.translate
mov
a,e
izero?
d
ora
iOO or 00 = 00
mvi
h,O
mov
l,c
iHL = untranslated sector
rz
iskip if so
xchg
b,d
mov
i8C=00ss
iHL=.translate(sector)
dad
b
mov
I,m
mov
h,d
iHL=translate(sector)
ret

0328 2A6E04
0328 5E
032C 23
032D 56
032E 78
032F 82
0330 2600
0332 69
0333 C8
0334 E8
0335 42
0336 09
0337 6E
0338 62
0339 C9
i

033A 69
0338 60
033C 223704
033F C9

setdma: iset dma address given by registers band c
mov
l,c
;low order address
mov
h,b
ihigh order address
shld
dmaad
isave the address
ret
i

read:
0340 0640
0342 C34703
i

write:
0345 0680

iperform read operation.
ithis is similar to write, so set up read
i command and use common code in write
mvi
b,040h iset read flag
jmp
waitio ito perform the actual I/O
iperform a write operation
mvi
b,080h
iset write command

All Information Presented Here is Proprietary to Digital Research
92

MP/M II System Guide

Appendix D

Simple XIOS Source

;

waitio:
;enter here from read and write to perform the actual
; I/O operation.
return a OOh in register a if the
; operation completes properly, and Olh if an error
; occurs during the read or write

0347 3EOA
0349 323804
034C C5
034D CDDA03
0350 Cl
0351 4E
0352 3E27
0354 89
0355 DA5C03
0358 3ElO
035A 80
0358 47
035C 2A3704
035F C5
0360 28
0361 5E
0362
0365
0367
0369
036C

;in this case, the disk number saved in 'diskno'
the track number in 'track'
the sector number in 'sector'
the dma address in 'dmaad'
;b still has r/w flag
mvi
a,lOd
;set error count
sta
errors
;retry some failures 10 times
;before giving up
tryagn:
push
b
call
headload
;h,l point to track byte for selected disk
pop
b
c,m
mov
decide whether to allow disk write precompenstation
mvi
a,39d
;inhibit precomp on trks 0-39
cmp
c
jc
allowit
;inhibit precomp
mvi
a,lOh
ora
b
mov
b,a
;goes out on the same port
; as read/write
allowit:
lhld
dmaad
;get buffer address
push
b
;b has r/w code
c has track
dcx
h
;save and replace 3 bytes belo
;buf with trk,sctr,adr mark
mov
e,m
;figure correct address mark

3A3C04
E608
3EFB
CA6E03
E60F

Ida
ani
mvi
jz
ani

port
08h
a,Ofbh
sin
Ofh

;was double
;Obh is double density
;Ofbh is single density

sin:
036E 77
036F 28
0370 56
0371 3A3604
0374 77

mov
;fill in sector
dcx
mov
Ida
mov
;fill in track

m,a
h
d,m
sector

;note that invalid sector numb
iwill result in head unloaded
ierror, so dont check

m,a

All Information Presented Here is Proprietary to· Digital Research
93

MP/M II System Guide

Appendix D

dcx
pop
mov
mov
mov
mov
out
mov
out
mov
out

a "c
c,m
m,a
a,h
haddr
a,l
laddr
a,b
cmdl

0383 C5
0384 D5
0385 E5

push
push
push

b
d
h

0386 OE84
0388 lE05
038A CD5500

mvi
mvi
call

c,flagwait
e,5
xdos

038D El
038E Dl
038F Cl
0390 71
0391 23
0392 72
0393 23
0394 73
0395 0880
0397 E6FO
0399 C8

pop
pop
pop
mov
inx
mov
inx
mov
in
ani
rz

h
d
b

0375 28
0376 Cl
0377 79
0378 4E
0379 77
037A 7C
0378 D38l
0370 7D
037E D382
0380 78
0381 0380

Simple XIOS Source

h
b

iset up fdc dma address
ihigh byte
iloW byte
iget r/w flag
istart disk read/write

rwwait:

039A F5
0398 213804
039E 35
039F C2A603
03A2 Fl
03A3 3EOI
03A5 C9
03A6 Fl
03A7 E6EO
03A9 C24C03
03AC C5
03AD 113204
0380 2A3904

m,c

wait for disk intrpt

irestore 3 bytes below buf

h

m,d
h

m,e
stat
OfOh

itest for errors
ia

will be 0 if no errors

; error from disk
push
psw
;save error condition
;check for 10 errors
lxi
h,errors
dcr
m
jnz
redo
;not ten yet. do a retry
;we have too many errors. print out hex number for las
;received error type. cpm will print perm error messag
pop
psw
;get code
;set error return for operating system
mvi
a,l
ret
redo:
ib still has read/write flag
pop
psw
iget error code
ani
OeOh
iretry if not track error
jnz
tryagn;
;was a track error so need to reseek
push
b
isave
read/write indicator
;figure out the desired track
Ix i
d, track
lhld
diskno iselected disk

All Information Presented Here is Proprietary to Digital Research
94

MP/M II System Guide
0383 19
0384 7E
0385 F5
0386 CDCA02
0389 Fl
038A 4F
0388 CD0503
038E Cl
03BF C34C03

dad
mov
push
call
pop
mov
call
pop
jmp

Appendix D
d

a,m
psw
home
psw
c,a
settrk
b
tryagn

Simple XIOS Source

ipoint to correct trk indicato
idesired track
isave it

iget read/write indicator

i

step:

03C2 DAD503
03C5 34
03C6 3E04
03C8 F602
03CA D380
03CC E6FD
03CE D380
03DO 3ElO
03D2 C3l503

istep head out towards zero
iif carry is seti else
istep in
h,l point to correct track indicator word
jc
outx
iincrement current track byte
inr
m
mvi
a,04h
iset direction = in
dostep:
ori
2
out
cmdl
iPulse step bit
ani
Ofdh
out
cmdl
iturn off pulse
ithe fdc-2 had a stepp ready line. the fdc-3 relies on
isoftware time out
mvi
a,16d
idelay 8 ms
delay
jmp
ret
outx:

03D5 35
03D6 AF
03D7 C3C803

dcr
xra
jmp

m
a
dostep

iupdate track byte

i

03DA
03DD
03DE
03DF
03EO
03El

2l3D04
46
28
7E
23
77

03E2 F6l0
03E4 D383
03E6 E6EF
03E8 113204
03E8 2A3904
03EE 19

headload:
iselect and load the head on the correct drive
lxi
h,prtout
iold slect info
mov
b,m
dcx
h
inew select info
mov
a,m
inx
h
m,a
mov
ori

10h

i

enable interrupt

out
cmd2
iselect the drive
ani
Oefh
iset up h.l to point to track byte for selected disk
lxi
d,track
lhld
diskno
dad
d
inoW check for needing a 35 ms delay
iif we have changed drives or if the head is unloaded
iwe need to wait 35 ms for head settle

All Information Presented Here is Proprietary to Digital Research
95

Appendix D

MP/M II System Guide
03EF B8
03FO C2F803
03F3 DB80
03F5 E680
03F7 C8
03F8 AF
03F9 D380
03FB 3E46
03FD C31503

Simple XIOS Source

cmp
b
iare we on the same drive
jnz
needdly
iwe are on the same drive
iis the head loaded?
stat
in
80h
ani
ialready loaded
rz
needdly:
xra
a
out
iload the head
cmdl
a,70d
mvi
jmp
delay
ret
i
i

BIOS Data Segment
i

0400 3C

cnt60: db
intstk:
0401 C7C7C7C7C7
dw
040B C7C7C7C7C7
dw
0415 C7C7C7C7C7
dw
dw
041F C7C7C7C7C7
Istintstk:
0429 0000
svdhl: dw
svdsp: dw
042B 0000
042D 0000
svdret: dw
tickn: db
042F 00
if
0430 44
intmsk: db
else
intmsk: db
endif
0431 00
preemp: db

60

i 60 tick cntr = 1 sec

local intrpt stk
Oc7c7h,Oc7c7h,Oc7c7h,Oc7c7h,Oc7c7h
Oc7c7h,Oc7c7h,Oc7c7h,Oc7c7h,Oc7c7h
Oc7c7h,Oc7c7h,Oc7c7h,Oc7c7h,Oc7c7h
Oc7c7h,Oc7c7h,Oc7c7h,Oc7c7h,Oc7c7h
;

0
0
0
0
debug
44h

;

i

intrpt msk, enables clk intr

54h

i

intrpt msk, enables clk intr

0

·, preempted boolean
,· start of scratch area
i current trk on drive 0
,· current trk on drive 1

i

0432 00
0433 00
0434 00
0435 00
0436 00
0437 0000
0439 00
043A 00
043B 00
043C 00
043D 00
043E 00
043F+=
043F+00000000
0443+00000000
0447+70045F04
044B+I005F004

scrat:
track:
trakl:
trak2:
trak3:
sector:
dmaad:
diskno:
dummy:
errors:
port:
prtout:
dnsty:
DPBASE
DPEO:

saved Regs HL during int hnd

; saved SP during int hndl
saved return during int hndl
i ticking boolean, true = delay

;

db
db
db
db
db
dw
db
db
db
db
db
db

0
0
0
0
0
0
0
0
0
0
0
0

disks
EQU

2
$
iBASE OF DISK PARAMETER BLOCKS
XLTO,OOOOH
:TRANSLATE TABLE
OOOOH,OOOOH
:SCRATCH AREA
:DIR BUFF,PARM BLOCK
DIRBUF,DPBO
iCHECK, ALLOC VECTORS
CSVO,ALVO

DW
DW
DW
DW

;

currently selected sctr

i current dma address
i current disk number
i must be 0 for dbl add

All Information Presented Here is Proprietary to Digital Research
96

Appendix D

MP/M II System Guide
044F+00000000
0453+00000000
0457+70045F04
045B+50053005
0800 =
0010 =
OOFF =

DPEl:

bpb
rpb
maxb

045F+=
045F+3AOO
0461+04
0462+0F
0463+00
0464+FFOO
0466+7FOO
0468+CO
0469+00
046A+2000
046C+0200
0000+=

DPBO

045F+=
0020+=
0020+=
0000+=

DPBl
ALSI
CSSI
XLTI

046E

tran:

XLTO

Simple XIOS Source

XLTl,OOOOH
;TRANSLATE TABLE
DW
OOOOH,OOOOH
;SCRATCH AREA
DW
DIRBUF,DPBl
;DIR BUFF,PARM BLOCK
DW
CSVl,ALVl
;CHECK, ALLOC VECTORS
DW
2*1024 ;bytes per block
equ
equ
bpb/128 ;records per block
255
;max block number
equ
diskdef 0,1,58"bpb,maxb+l,128,128,2,0
$
;DISK PARM BLOCK
EQU
58
;SEC PER TRACK
DW
4
;BLOCK SHIFT
DB
15
;BLOCK MASK
DB
o
;EXTNT MASK
DB
255
;DISK SIZE-l
DW
127
;DIRECTORY MAX
DW
192
;ALLOCO
DB
o
;ALLOCI
DB
32
;CHECK SIZE
DW
2
; OFFSET
DW
EQU
o
;NO XLATE TABLE
diskdef 1,0
;EQUIVALENT PARAMETERS
EQU
DPBO
EQU
;SAME ALLOCATION VECTOR SIZE
ALSO
CSSO
;SAME CHECKSUM VECTOR SIZE
EQU
;SAME TRANSLATE TABLE
EQU
XLTO

;

ds

2

;

endef
EQU
DS
DS
DS
DS
DS
EQU
EQU
DB

128
32
32
32
32

o

;FORCE'OUT LAST BYTE IN HEX FI

0571 00

db

o

;force out last byte in hex fi

0572

end

0470+=
0470+
04FO+
0510+
0530+
0550+
0570+=
0100+=
0570+00

BEGDAT
DIRBUF:
ALVO:
CSVO:
ALVl:
CSVl:
ENDDAT
DATSIZ
FORCE:

$

;DIRECTORY ACCESS BUFFER

$

$-BEGDAT

All Information Presented Here is Proprietary to Digital Research
97

Appendix E
Sample MP/M II Banked XIOS

page
TITLE

o
'XIOS200, Copyright 1980, ALTOS COMPUTER SY

i---------------------------------------------------------ALTOS COMPUTER SYSTEMS
2360 BERING DRIVE
SAN JOSE, CALIFORNIA 95131
Copyright 1980, ALTOS COMPUTER SYSTEMS
This program is a copyright program product of
ALTOS COMPUTER SYSTEMS and is distributed to the
owners of ALTOS SUN SERIES 8000 computers for
use on those systems only. Any other use of this
software constitutes a breach of the copyright
license to the purchaser. However, permission is
granted to use this listing as a sample for the
construction of the reader's own XIOS.

:
:
:

:

:

VERSION NUMBER: 1.12*
VERSION DATE:
June 28, 1980
Add support for CP/M version 2.0
Add support for Hard disk drives
Add support for disk MODE selection
Provide compatability MODE for 1.4 operatio
Remove CTC/1791 counter reset
CORRECT HARD DISK SEEK PROBLEM
Add code to recover from WD1791 going to 51
Initialize parallel port for Centronics pri
VERSION DATE:
March 17, 1981
Virtual disk in banks 1,2,3: M DISK 1:
VERSION DATE:
April 11, 1981
Conditional assembly for virtual disks
Conditional assembly for MP/M 2.0
VERSION DATE:
April 14, 1981
Equates added for LDRBIOS hooks
VERSION DATE:
April 16, 1981
Testing for bank setup added

j---------------------------------------------------------,._--------------------------------------------------------:
Mode

o

IBM single density
ALTOS double density Version 2.0

1

All Information Presented Here is Proprietary to Digital Research
99

Appendix E

MP/M II System Guide

ALTOS double density Version 1.4
ALTOS hard disk Version 2.0 (8 MEG
ALTOS HARD DISK VERSION 2.0 (8 MEG
ALTOS HARD DISK VERSION 2.0 (8 MEG
ALTOS HARD DISK VERSION 2.0 (4 MEG

2
3
4

i
i
i

MP/M Banked XIOS

5

6

i~---------------------------------------------------- -----

j---------------------------------------------------------ASSEMBLER CONTROL STATEMENTS

i---------------------------------------------------------MACLIB
MACLIB

DISKDEF
Z80S

FFFF =
0000 =

TRUE
FALSE

EQU
EQU

OFFFFH
NOT TRUE

iVALUE FOR TRUE
iVALUE FOR FALSE

0000
FFFF

=
=

mdisk
mpm20

equ
equ

false
true

iVirtual Disk cond asm bool
iMP/M 2.0 cond asm boolean

1700

=

ldrbiosbase equ l700h

0037
OOBB

=
=

density$mask$offset equ 37h ;density mask offset from LDRBI
misc$params$offset equ Obbh ;misc. parameters offset from L

i----------------------------------------------------------

for M

i---------------------------------------------------------THE FOLLOWING EQUATES ARE USER MODIFIABLE BASED ON
PARTICULAR USER SYSTEM AND OPTIONS SELECTED.

i---------------------------------------------------------FFFF =
FFFF =

DMA
HARDSK

EQU
EQU

TRUE
TRUE

;DMA HARDWARE SUPPORT ??
;HARD DISK SUPPORT

i---------------------------------------------------------THE FOLLOWING CONSTANTS APPLY TO THE DEBLOCKING OF
SECTORS LARGER THAN 128 FOR THE ALTOS DOUBLE DENSIT
AND THE ALTOS HARD DISK.

i---------------------------------------------------------4000
0400
0010
0008
0080
0007
0003

=
=
=
=
=
=
=

BLKSIZ
HSTSIZ
HSTSPT
HSTBLK
CPMSPT
SECMSK
SECSHF

EQU
EQU
EQU
EQU
EQU
EQU
EQU

16384
1024
16
HSTSIZ/128
HSTBLK * HSTSPT
HSTBLK - 1
3

; CP/M ALLOCATION SIZE
;HOST DISK SECTOR SIZE
;HOST DISK SECTORS PER TRAC
; CP/M SECTORS PER HOST BUFF
; CP/M SECTORS PER TRACK
;SECTOR MASK
;LOG2(HHSTBLK)

All Information Presented Here is Proprietary to Digital Research
100

Appendix E

MP/M II System Guide

MP/M Banked XIOS

PAGE

i---------------------------------------------------------THE FOLLOWING EQUATES APPLY TO THE RELOCATABILITY
OF THE CBIOS AND SHOULD NOT BE USER ALTERED.

i---------------------------------------------------------FFFF

=

RELOC

EQU

TRUE

:RELOCATABLE VERSION ??

i---------------------------------------------------------maxdsk
OOOC

=

MAXDSK
MAXDSK

0000

0000

=

BASE

if
equ
else
IF
EQU
ELSE
EQU
ENDIF
endif

mdisk
13
HARDSK
12

:MAXIMUM NUMBER OF LOGICAL

4

:MAXIMUM NUMBER OF LOGICAL

IF
ORG
ELSE
ORG
ENDIF

RELOC
OOOOH

EQU

$

OCOOOH

,

e _________________________________________________________ _

a

0000
0001
0002

=

=
=

WRALL
WRDIR
WRUAL

EQU
EQU
EQU

1

0004

=

NMBCNS

EQU

4

NUMBER OF CONSOLES

0083
0084
0085

=
=
=

POLL
FLAGWT
FLAGST

EQU
EQU
EQU

131
132
133

XDOS POLL FUNCTION
XDOS FLAG WAIT FUNCTION
XDOS FLAG SET FUNCTION

2

0005 =
0006 =

HDFLAG EQU
FPYFLAG EQU

5
6

0000 =
0001 =
0002 =
0003 =
0004 =
0005 =
0006 =

PLLPT
PLCOO
PLCOI
PLC02
PLC03
PLCIO
PLCII

PLLPT+l
PLCOO+l
PLCOl+l
PLC02+1
PLC03+1
PLCIO+l

EQU
EQU
EQU
EQU
EQU
EQU
EQU

:WRITE TO ALLOCATED
:WRITE TO DIRECTORY
:WRITE TO UNALLOCATED

:HARD DISK FLAG FOR WAIT & SET
:FLOPPY DISK FLAG FOR WAIT & SET

a

POLL PRINTER
POLL CONSOLE OUT #0 (CRT:)
POLL CONSOLE OUT #1 (CRT:)
POLL CONSOLE OUT #2 (CRT:)
POLL CONSOLE OUT #3 (CRT:)
POLL CONSOLE IN #0 (CRT:)
POLL CONSOLE IN #1 (CRT:)

All Information Presented Here is Proprietary to Digital Research
101

Appendix E

MP/M II System Guide
0007 =
0008 =

PLCI2
PLCI3

EQU
EQU

0009 =
0002 =

MEMPORT EQU
MEMSK
EQU

PLCIl+l
PLCI2+1
009H
002H

MP/M Banked XIOS

POLL CONSOLE IN #2 (CRT:)
POLL CONSOLE IN #3 (CRT:)
; MEMORY SELECT PORT
MEMORY SELECT MASK

PAGE

.i----------------------------------------------------------

,
;

JUMP VECTORS FOR ENTRIES TO CBIOS ROUTINES

;

i---------------------------------------------------------;

EXTERNAL JUMP TABLE (BELOW XIOS BASE)

;PDISP
;XDOS

EQU
EQU

$-3
PDISP-3

if
jmp
else
JMP
endif

mpm20
commonbase
COLDSTART

;COLD START

JMP
JMP
JMP
JMP
JMP

WARMSTART
CONST
CONIN
CONOUT
LIST

;WARM START
;CONSOLE STATUS
;CONSOLE CHARACTER IN
;CONSOLE CHARACTER OUT
;LIST CHARACTER OUT - THIS
;
"CLIST" IF SETUP PROGRAM
PARALLEL PRINTER PORT

JMP
JMP
JMP
JMP
JMP
JMP
JMP
JMP
JMP
JMP
JMP

RTNEMPTY
RTNEMPTY
HOMEIT
SELDSK
SETTRK
SET SEC
SETDMA
READ
WRITE
POLLPT
SECTRAN

;PUNCH NOT IMPLEMENTED
;READER NOT IMPLEMENTED
;MOVE HEAD TO HOME
;SELECT DISK
;SET TRACK NUMBER
;SET SECTOR NUMBER
iSET DMA ADDRESS
;READ DISK
iWRITE DISK
;LIST STATUS
iSECTOR TRANSLATE

0000 C3040B

WBOTE:
0003 C3l50B
0006 C3790B
0009 C3840B
OOOC C38FOB
OOOF C3A90C
;

0012 C3lAOB
0015 C3lAOB
0018 C3F902
001B C30302
OOIE C36D02
0021 C37302
0024 C35502
0027 C38B02
002A C39602
0020 C3BCOC
0030 C3D605

EXTENDED I/O SYSTEM JUMP VECTOR
0033 C3E90C
0036 C3CBOC
0039 C3050D
003C C30BOD
003F C3100D
0042 C3170D

JMP
JMP
JMP
JMP
JMP
JMP

SELMEMORY
POLLDEVICE
STARTCLOCK
STOPCLOCK
EXITREGION
MAXCONSOLE

.i SELECT MEMORY

, POLL DEVICE

START CLOCK
STOP CLOCK
; EXIT REGION
i MAXIMUM CONSOLE NUMBER

All Information Presented Here is Proprietary to Digital Research
102

MP/M II System Guide

Appendix E

MP/M Banked XIOS

0045 C39D12
0048 00
0049 00
004A 00

JMP
NOP
NOP
NOP

SYSTEMINIT

i

004B C3Al02
004E C3EE02

JMP
JMP

SETMOD
RETMOD

iROUTINE TO SET DISK MODE
iROUTINE TO RETURN CURRENT

if
COLDSTART:
WARMSTART:
MVI

SYSTEM INITIALIZATION
NO JMP HERE
i FOR MP/M DELAY

not mpm20
C,O
XDOS

SEE SYSTEM INIT
COLD & WARM START INCLUDE
FOR COMPATIBILITY WITH CP
SYSTEM RESET, TERMINATE P

A

NOT USED

i

i

JMP
RTNEMPTY:
XRA
RET
endif
LAST:
ORG

OOSE
005E
0060
0062
0064
0066
0068
006A
006C
006E

470B
lCOB
lCOB
lCOB
lAOD
lCOB
5EOB
lCOB
lCOB

INTERUPT:
DW
DW
DW
DW
DW
DW
DW
DW
DW
if
NULL$INT:
EI
RETI
endif

«(LAST-BASE)+OA2H) AND OFFOOH) +OSEH
FLOPPY$INT
NULL$INT
NULL$INT
NULL$INT
INTlHND
NULL$INT
HARD$INT
NULL$INT
NULL$INT

iFLOPPY DISK INTERR
i

iCTC INTERRUPT
i

iHARD DISK INTERRUP

not mpm20

PAGE

i----------------------------------------------------- ----WORK AND CONTROL AREAS FOR CBIOS SERVICES

i----------------------------------------------------- ----0070 FFFFFFFFFFTRKO:

DB

OFFH,OFFH,OFFH,OFFH,OFFH,OFFH,OFFH,OFFH,OFF
\

All Information Presented Here is Proprietary to Digital Research
103

Appendix E

MP/M II System Guide

MP/M Banked XIOS

007C 0408102010SELO:
0088 0000000003MODE:
0094 OOOOOOOOOOTCNT:
OOAO OOOOOOOOOOPCNT:

DB
DB
DB
DB

004H,008H,010H,020H,010H,010H,010H,020H,020
000H,000H,000H,000H,003H,004H,005H,003H,004
OOOH,OOOH,OOOH,OOOH,OOOH,OOOH,OOOH,OOOH,OOO
OOOH,OOOH,OOOH,OOOH,OOOH,OOOH,OOOH,OOOH,OOO

OOAC 00
OOAD 00
OOAE 00
OOAF 0000
00B1 00
00B2 0000
00B4 0000
00B6 0000
00B8 10
00B9 20

DB
DB
DB
DW
DB
DW
DW
DW
DB
DB

OOOH
OOOH
OOOH
OOOH
OOOH
OOOH
OOOH
OOOH
10H
20H

DISKNO:
TRAKNO:
HEADNO:
DMAADR:
SECTNO:
DPEPTR:
DBLKAD:
MPARMS:
HTK1:
HTK2:

.

,

iCURRENT DR
; CURRENT TR
iCURRENT HE
; CURRENT DM
iCURRENT SE
iCURRENT DP
iCURRENT EX
;MISC. PARA
iHARD DISK
iHARD DISK

PARAMETER FLAGS
;
;

.,

;

0100H = DOUBLE HEADED DRIVES
0200H = CENTRONICS PRINTER FOR LIST DEVICE
0400H = FOUR DRIVE SYSTEM [ ABC D ]

;-------------~--------------------------------------- -----

i---------------------------------------------------------;
;
;

NOTE:
NO CHANGES ARE TO BE MADE TO THE ABSOLUTE LOCATIONS
ANY FIELDS PRIOR TO THIS POINT. EXTERNAL PROGRAMS A
DEPENDENT UPON THE LOCATION OF THE PRECEEDING DATA.

;----------------~------------------------------------ -----

IF
NMIRTN: DB
ENDIF

NOT DMA
OEDH,OA2H,OEDH,04SH

;FAKE INI A

DMAS1: DB
DMASA: DW
DMALEN: DW

OC3H,07DH
OOOH
1025 .... 1

iFIRST PART
;ADDRESS FO
iLENGTH FOR

OOCO 54CE68CEA5DMAS2H: DB

054H,OCEH,068H,OCEH,OA5H,020H

;HARD DISK

00C6 14288507

DMAS2F: DB

014H,028H,085H,007H

jFLOPPY DIS

OOCA 8ACF01CF
OOCE 01
OOCF CF87

DMAS3: DB
DMAS3F: DB
DB

08AH,OCFH,001H,OCFH
001H
OCFH,087H

;LAST PART
;OOl=READ,
iSETUP DMA,

OOBA C37D
OOBC 0000
OOBE 0004

PAGE
;-------------------------------~-------------~-----------i

CONTROL BLOCKS FOR DISK DRIVER

i---------------------------~------------------------- -----

All Information Presented Here is Proprietary to Digital Research
104

MP/M II System Guide

Appendix E

MP/M Banked XI OS

0001 =

OPBASE

EQU

$

~START

0001 B5010000
0005 00000000
0009 90120400
0000 3E081E08

OPEO:

OW
OW
OW
OW

XLTO,OOOOH
OOOOH,OOOOH
OIRBUF,OPBO
CSVO,ALVO

TABLE ANO WORK A
~ SCRATCH AREA
~OIR BUFF, PARM BLOCK
;CHECK VECTOR, ALLOC VECTOR

00E1 B5010000
00E5 00000000
00E9 90120400
OOEO 7E085E08

OPEl:

OW
OW
OW
OW

XLTO,OOOOH
OOOOH,OOOOH
OIRBUF,OPBO
CSV1,ALV1

~TRANSLATE TABLE
~SCRATCH AREA

00F1 B5010000
00F5 00000000
00F9 90120400
OOFO BE089E08

OPE2:

OW
OW
OW
OW

XLTO,OOOOH
OOOOH,OOOOH
OIRBUF,OPBO
CSV2,ALV2

~TRANSLATE TABLE ANO WORK A
;SCRATCH AREA
;OIR BUFF, PARM BLOCK
;CHECK VECTOR, ALLOC VECTOR

0101 B5010000
0105 00000000
0109 90120400
0100 FE08DE08

OPE3:

OW
OW
OW

ow

XLTO,OOOOH
OOOOH,OOOOH
OIRBUF,OPBO
CSV3,ALV3

IF

HARDSK

OW
OW
OW
OW

OOOOH,OOOOH
OOOOH,OOOOH
OIRBUF,OPB3
CSV4,ALV4

BLOCK
;CHECK VECTOR, ALLOC VECTOR

OF OISK PARAMETER BL

~TRANSLATE

~OIR

ANO WORK A

BUFF, PARM BLOCK
VECTOR, ALLOC VECTOR

~CHECK

TABLE ANO WORK A
AREA
~OIR BUFF, PARM BLOCK
~CHECK VECTOR, ALLOC VECTOR
~TRANSLATE

~SCRATCH

0111
0115
0119
0110

00000000
00000000
9012010E
5E091E09

OPE4:

0121
0125
0129
0120

00000000
00000000
9012100E
9E095E09

OPE5:

OW
OW
DW
OW

OOOOH,OOOOH
OOOOH,OOOOH
OIRBUF,DPB4
CSV5,ALV5

;TRANSLATE TABLE AND WORK A
;SCRATCH AREA
;OIR BUFF, PARM BLOCK
~CHECK VECTOR, ALLOC VECTOR

0131 00000000
0135 00000000
0139 90121FOE
013D OE099E09

OPE6:

OW
DW
OW
OW

OOOOH,OOOOH
OOOOH,OOOOH
OIRBUF,DPB5
CSV6,ALV6

~TRANSLATE TABLE
~SCRATCH AREA

~OIR BUFF, PARM BLOCK
;CHECK VECTOR, ALLOC VECTOR

0141 00000000
0145 00000000
0149 9012010E
0140 1EOAOE09

OPE7:

OW
OW
OW
OW

OOOOH,OOOOH
OOOOH,OOOOH
OIRBUF,OPB3
CSV7,ALV7

;TRANSLATE TABLE ANO WORK A
~SCRATCH AREA
~OIR BUFF, PARM BLOCK
~CHECK VECTOR, ALLOC VECTOR

0151
0155
0159
015D

00000000
00000000
9D12100E
5EOA1EOA

OPE8:

OW
OW
DW
DW

OOOOH,OOOOH
OOOOH,OOOOH
DIRBUF,DPB4
CSV8,ALV8

TABLE ANO WORK A
AREA
iOIR BUFF, PARM BLOCK
iCHECK VECTOR, ALLOC VECTOR

0161
0165
0169
016D

00000000
00000000
9D121FOE
9EOA5EOA

OPE9:

DW
DW
OW
DW

OOOOH,OOOOH
OOOOH,OOOOH
DIRBUF,OPB5
CSV9,ALV9

~TRANSLATE TABLE
~SCRATCH AREA

~TRANSLATE

TABLE ANO WORK A

~ SCRATCH AREA
~OIR BUFF, PARM

ANO WORK A

~TRANSLATE
~SCRATCH

AND WORK A

~DIR BUFF, PARM BLOCK
iCHECK VECTOR, ALLOC VECTOR

All Information Presented Here is Proprietary to Digital Research
105

Appendix E

MP/M II System Guide

MP/M Banked XIOS

0171 00000000
0175 00000000
0179 9D122EOE
017D C20A9EOA

DPEA:

DW
DW
DW
DW

OOOOH,OOOOH
OOOOH,OOOOH
DIRBUF,DPB6
CSVA,ALVA

iTRANSLATE TABLE AND WORK A
iSCRATCH AREA
iDIR BUFF, PARM BLOCK
iCHECK VECTOR, ALLOC VECTOR

0181 00000000
0185 00000000
0189 9D122EOE
018D E60AC20A

DPEB:

DW
DW
DW
DW

OOOOH,OOOOH
OOOOH,OOOOH
DIRBUF,DPB6
CSVB,ALVB

;TRANSLATE TABLE AND WORK A
;SCRATCH AREA
iDIR BUFF, PARM BLOCK
iCHECK VECTOR, ALLOC VECTOR

if

mdisk
Virtual disk parameter header

DW
DW
DW
DW
endif

OOOOH,OOOOH
OOOOH,OOOOH
DIRBUF,DPB7
CSVC,ALVC

ENDIF
i

DPEC:

;TRANSLATE TABLE AND WORK A
iSCRATCH AREA
iDIR BUFF, PARM BLOCK
;CHECK VECTOR, ALLOC VECTOR

e __________________________________________________________

I

0191 B5010000
0195 00000000
0199 9D12D40D

MODLO:

DW
DW
DW

XLTO,OOOH
OOOH,OOOH
DIRBUF,DPBO

; MODEL DPE FOR MODE 0

019D CFOlOOOO
01Al 00000000
01AS 9D12E30D

MODLl:

DW
DW
DW

XLTl,OOOOH
OOOOH,OOOOH
DIRBUF,DPBl

; MODEL DPE FOR MODE 1

01A9 CFOI0000
01AD 00000000
01Bl 9012F20D

MODL2:

DW
OW
DW

XLT2,OOOOH
OOOOH,OOOOH
DIRBUF,DPB2

; MODEL DPE FOR MODE 2

;
;

i

i---------------------------------------------------------01B5 01070D1319XLTO:
01C2 02080E141A

DB
DB

1,7,13,19,25,5,11,17,23,3,9,15,21
2,8,14,20,26,6,12,18,24,4,10,16,22

DB
DB
DB
DB

01,02,03,04,05,06,07,08,09,10,11,12,13
14,15,16,17,18,19,20,21,22,23,24,25,26
27,28,29,30,31,32,33,34,35,36,37,38,39
40,41,42,43,44,45,46,47,48,49,50,51,52

XLTl:
XLT2:
OlCF 0102030405
01DC OEOFI01112
01E9 1B1CID1E1F
01F6 28292A2B2C

PAGE

i----------------------------------------------------- ----;

;

.,

DISK ACCESS ROUTINES

All Information Presented Here is Proprietary to Digital Research
106

MP/M II System Guide

Appendix E

MP/M Banked XI OS

i---------------------------------------------------------SELDSK:
MOV
CPI
JRNC
DB
MOV
ANI
PUSH
MVI
MOV
LXI
DAD
MOV
MOV

0203 79
0204 FEOC
0206+303A

0208
020A
020B
020E
020F
0210

0211
0213
0216
0217
0218

1600
59
214602
19
4E
79

0600
217COO
09
7E
A7

0219+2827
021B 79
021C FE04
021E+380F
0220 7E
0221 D320
0223 C5
0224 OE01
0226 CD8207
0229 C1
022A DB24
022C 17
022D+3013
022F 79

A,C
MAXDSK
SELERR
030H,SELERR-$-1
A,E
1
PSW
D,O
E,C
H,DTBLT

i

C,M
A,C
mdisk
12
VIRTUAL

POP
;
JRNZ
SETDSK:
MVI
LXI
DAD
MOV
ANA
JRZ
DB
MOV
CPI
JRC
DB
CHKHRD: MOV
OUT
PUSH
MVI
CALL
POP
IN
RAL
JRNC
DB
SELSDP:
MOV

PSW
SELSDP

INVALID DRIVE

i---- FAKE JRNC INSTRUCTION
i
i

TEST FOR INITIAL SELECT
E = 0 IS FIRST TIME
TRANSLATE TABLE
FOR LOGICAL TO PHYSICAL

D

if
CPI
JZ
endif

if

iLIMIT SELECT TO REAL OPTIO

i

C = PHYSICAL DRIVE
M translates to the 12 di

i
i

RESTORE TEST
BYPASS SELECT

B,O
H,SELO
B
A,M

BASE OF SELECT MASKS

GET SELECT BYTE
CHECK FOR VALID DRIVE
SELERR
i
DRIVE NOT CONFIGURED
028H,SELERR-$-1 i - - - - FAKE JRZ INSTRUCTION
A,C
i
4
i CHECK FOR FLOPPY
SELSDP
i
038H,SELSDP-$-1 i - - - - FAKE JRC INSTRUCTION
A,M
i RESTORE SELECT BYTE
,
20H
A

i

·

B

C,l
DELAY
B

24H

·

,
i
i

·

,

DELAY FOR 1 MS
CHECK FOR HARD DISK READY
80H = READY

SELERR
030H,SELERR-$-1 i - - - - FAKE JRNC INSTRUCTION
A,C

i

mdisk

VIRTUAL:
endif
0230 32E60A
0233 2600

STA
MVI

NEWDSK
H,O

iSAVE FOR I/O LATER

All Information Presented Here is Proprietary to Digital Research
107

Appendix E

MP/M II System Guide
0235 69
0236 29
0237 29
0238 29
0239 29
023A 11D100
023D 19
023E 22B200
0241 C9

MOV
DAD
DAD
DAD
DAD
LXI
DAD
SHLD
RET

0242 210000
0245 C9

SELERR: LXI
RET

.,

L,C
H
H

H
H

D,DPBASE
D

DPEPTR
H,O

MP/M Banked XI OS

;COMPUTE DP HEADER ADDRESS
;* 2
;* 4
;* 8
;* 16 (DP HEADER SIZE)
;START OF DP HEADERS
;POINT TO CORRECT ONE
;SAVE ADDRESS OF CURRENT DP
; INDICATE ERROR
AND RETURN

DB

A,B,C,D,E,F,G,H,I,J, K, L,M ,N,O
0,1,2,3,4,5,6,7,8,9,10,11,12,0,0

0255 60
0256 69
0257 22AFOO

MOV
MOV
SHLD

H,B
L,C
DMAADR

025A 23
025B 7D
025C B4
025D CO
025E 21FOOA
0261 7E
0262 3600
0264 B7
0265 C8
0266 CD6D04
0269 B7
026A C8
026B E1

if
inx
mov
ora
rnz
1xi
mov
mvi
ora
rz
call
ora
rz
pop
endif

026C C9

ret

0246 0001020304DTBLT:
SETDMA:

iTO ALLOW SAVING

mpm20
h

a,l

itest for flush buffers

h

h,hstwrt
a,m
m,O
a
writehst

;HL = FFFFh is flush buffer

;flush host write if pendin

a

;return if no error
h

SETTRK:
026D 60
026E 69
026F 22E70A
0272 C9

MOV
MOV
SHLD
RET

H,B
L,C
NEWTRK

MOV
STA
RET

A,C
NEWSEC

LXI
LHLD
MVI

D,SELO
NEWDSK
H,OOOH

;TO ALLOW SAVE
;

;SAVE NEXT TRACK NUMBER
;RETURN TO CALLER

SETSEC:
0273 79
0274 32E90A
0277 C9

;FOR SAVE
;

;RETURN TO CALLER

SETDEN:
0278 117COO
027B 2AE60A
027E 2600

;START OF SELECT/DENSITY MA
iNEXT DRIVE ADDRESS
;ENSURE ZERO FOR SINGLE BYT

All Information Presented Here is Proprietary to Digital Research
108

Appendix E

MP/M II System Guide
DAD
MOV
ANI
MOV
MOV
ANI

0280 19
0281 79
0282 E601
0284 4F
0285 7E
0286 E6FE
0288 Bl
0289 77
028A C9

D

A,C
OOOOOOOIB
C,A
A,M
11111110B

ORA

C

MOV
RET

M,A

if
MREADSECTOR:
call
di
call
lxi
lxi
Ihld
Idir
mvi
out
ei
lxi
Ihld
xchg
lxi
Idir
xra
ret
mbankno
addroff
localbuf

dad
dad
dad
mov
mov
dad
dad
Ida

iPOINT TO CORRECT MASK
iISOLATE DENSITY BIT
i

iSAVE FOR NOW
;LOAD SELECT DENSITY MASK
iRESET CURRENT DENSITY SETT
iSET NEW VALUE
iRESTORE MASK IN TABLE
;RETURN TO CALLER

mdisk
compbank

;compute bank

chgbank
b,128
d,localbuf
addroff
iblock move into the dma ar
i select bank 0

a,02h
09h
b,128
dmaadr
h,localbuf

a
db
dw
ds

compbank:
Ida
mov
ani
mov
mov
mvi
ani
rar
inr
sta

MP/M Banked XIOS

0
0
128

newtrk
h,a
Ofh
isave track rem 16
l,a
a,h
irestore track
h,O
OfOh
bank is high order nibble
rar ! rar
rar
a
mbankno
; which bank we want
h

itrk 0-15

h
h

;

i

e,l
d,h

* 2
* 4

d
d

* 24:

newsec

figure offset within the

All Information Presented Here is Proprietary to Digital Research
109

Appendix E

MP/M II System Guide
mov
mvi
dad
dad
shld
ret
endif

e,a
d,O

if
LOA
CPI

mdisk
NEWDSK
12
MREADSECTOR

d

h ! dad h
addroff

MP/M Banked XIOS

: add sector offset within
dad h ! dad h ! dad h ! dad h
(track * 24 + sector) * 1

READ:

JZ

:VIRTUAL DISK ?

endif
CALL
CPI
JC
JMP

028B CDEE02
028E FE03
0290 DAE40S
0293 C36B03

if
mwritesector:
call
Ihld
lxi
lxi
Idir
di
call
lxi
lxi
Ihld
xchg
Idir
mvi
out
ei
xra
ret

RETMOD
003H
READSOFT
READHARD

:WHAT TYPE OF I/O ??

:
:.FLOPPY DISK DRIVE ••••
:HARD DISK I/O

mdisk
compbank
dmaadr
d,localbuf
b,128
chgbank
d,localbuf
b,128
addroff
a,02h
09h

select bank 0

a

chgbank:
Ida
ral
ral
ral
ani
ori
out
ret
endif

mbankno

if
Ida
cpi

mdisk
newdsk
12

Ol8h
memsk
009h

WRITE:

All Information Presented Here is Proprietary to Digital Research
110

MP/M II System Guide

0296 CDEE02
0299 FE03
029B DAF205
029E C37E03

Appendix E

jz
endif

mwritesector

CALL
CPI
JC
JMP

RETMOD
003H
WRITESOFT
WRITEHARD

MP/M Banked XIOS

;WHAT TYPE OF I/O ??
;

;FLOPPY DISK
;HARD DISK I/O

PAGE

i---------------------------------------------------------ROUTINES TO SET AND RETURN THE CURRENT DRIVE MODE

i---------------------------------------------------------SETMOD:
02Al 2lE60A
02A4 7E
02A5 F5
02A6 70
02A7 C5
02A8 48
02A9 CD0302
02AC Cl
02AD 7C
02AE B5
02AF+2832
02Bl 68
02B2 2600
02B4 78
02B5 FE04
02B7+302A
02B9 118800
02BC 19
02BD 71
02BE E5
02BF 79
02CO B7
02Cl OEOO
02C3+2802
02C5 OEOI
02C7 CD7802
02CA El
02CB 6E
02CC 2600
02CE 7D
02CF 29
02DO 29
02Dl E5
02D2 29

LXI
MOV
PUSH
MOV
PUSH
MVI
MOV
CALL
POP
MOV
ORA
JRZ
DB
MOV
MVI
MOV
CPI
JRNC
DB
LXI
DAD
MOV
PUSH
MOV
ORA

MVI
JRZ
DB
MVI
SETSEL: CALL
POP
MOV
MVI
MOV
DAD
DAD
PUSH
DAD

H,NEWDSK
A,M
PSW
M,B

; SAVE NEWDSK IN STACK

·
·;
,

,

B

;

E,O
C,B
SELDSK
B
A,H

INDICATE INITIAL SELECT
; CALL DISK SELECT
; CHECK FOR BAD SELECT

·;

L

,

SMERR
028H,SMERR-$-1
L,B
H,OOOH
A,B
004H
SMERR
030H,SMERR-$-1
D,MODE

YES
ABORT CHANGING
;---- FAKE JRZ INSTRUCTION
; BAND L = DRIVE i
;

;CHECK MODE SET VALIDITY
;ONLY VALID FOR FLOPPY DISK
;INVALID DRIVE FOR MODE SET
;---- FAKE JRNC INSTRUCTION
;START OF MODE BYTES

D

;

M,C

;SAVE NEW MODE BYTE
;SAVE MODE BYTE ADDRESS
;SETUP FOR DENSITY CHANGE

H

A,C
A

;

C,OOOH
SETSEL
028H,SETSEL-$-1
C,OOlH
SET DEN
H
L,M
H,OOOH
A,L
H

;ASSUME SINGLE DENSITY MODE
;VERIFY ASSUMPTION
;---- FAKE JRZ INSTRUCTION
;SET FOR DOUBLE DENSITY MOD
;SET DENSITY BASED ON LOW B
; RESTORE
;PICKUP MODE AGAIN
;FOR SINGLE BYTE PRECISION
;SAVE MODE IN ACCUMULATOR F

H
H
H

;* 2
;* 4
;SAVE

;* 8

* 4

All Information Presented Here is Proprietary to Digital Research
III

Appendix E

MP/M II System Guide
0203 01
0204 19
0205 119101
0208 19
0209 EB
02DA 2AB200
0200 EB
02DE 010COO
02E1+EDBO
02E3 F1
02E4 E5
02E5 32E60A
02E8 4F
02E9 CD0302
02EC E1
02ED C9

SMERR:

POP
DAD
LXI
DAD
XCHG
LHLD
XCHG
LXI
LDIR
DB
POP
PUSH
STA
MOV
CALL
POP
RET

o
o

MP/M Banked XIOS

;REGAIN

* 4

;* 12

D,MODLO

o

DPEPTR
B,12
OEDH,OBOH
PSW
H

NEWDSK
C,A
SELDSK
H

;FIRST MODEL OPE
;POINT TO THIS ONE
;SETUP TEMPORARILY AS DESTI
iADDRESS OF CURRENTLY SELEC
iSETUP TO ALTER
;LENGTH FOR MOVE
iDO MOVE
i---- FAKE LDIR INSTRUCTION
i
i

RESTORE ORIGINAL NEWDSK

;
;
;

iRETURN TO CALLER

RETMOD:
02EE 118800
02F1 2AE60A
02F4 2600
02F6 19
02F7 7E
02F8 C9

LXI
LHLD
MVI
DAD
MOV
RET

D,MODE
NEWDSK
H,OOOH

o
A,M

iSTART OF MODE BYTES
iNEXT DRIVE FOR I/O
;RESET FOR SINGLE BYTE QUAN
;POINT TO IT ••••
;LOAD IT FOR CALLER
iRETURN, WITH CURRENT MODE

PAGE

.,i---------------------------------------------------------THIS IS THE HOME DEVICE ROUTINE
i
;---------------------------------~------------------- -----

02F9 3AE60A
02FC FEOC
02FE C20803
0301 AF
0302 67
0303 6F
0304 22E70A
0307 C9
0308 FE04
030A+380E
030C 4F
0300 0600
030F 217000
0312 09
0313 7E
0314 FEFF
0316 3EOO
0318 CO
0319 77

HOMEIT: LOA
CPI
JNZ
XRA
MOV
MOV
SHLD
RET
REALDISK:
CPI
JRC
DB
MOV
MVI
LXI
DAD
MOV
CPI
MVI
RNZ
MOV

NEWDSK
12
REALDISK
A
H,A
L,A
NEWTRK
4
HOME
038H,HOME-$-1
C,A
B,O
H,TRKO
B
A,M
OFFH
A,O

; CHECK FOR FIRST HOME
; CHECK FOR VIRTUAL DISK
; VIRTUAL DISK
i SET TRACK TO ZERO

;

CHECK FOR FLOPPY
NOT BYPASS FLOPPY HOM
FAKE JRC INSTRUCTION

i
DO
i---i

POINT TO PRESENT TRACK ST
i

CHECK IF INITIALIZED

i

YES

RETURN WITH NO ER

M,A

All Information Presented Here is Proprietary to Digital Research
112

Appendix E

MP/M II System Guide

MP/M Banked XIOS

HOME:
031A 3AE60A
031D FE04

LDA
CPI
JRNC
DB

031F+3022
0321 CD5205
0324 3AF60A
0327 B7
0328+2016
032A CDB305
032D 3600
032F CD1905
0332 3EOA
0334 CD6307

HOMESOFT:
CALL
LDA
ORA
JRNZ
DB
CALL
MVI
CALL
MVI
CALL
i

0337 CD3A07
033A 3AFCOA
033D E698
033F C8
0340 3E01
0342 C9

HOMEI:

CALL
LDA
ANI
RZ
HOME1A: MVI
RET

0343 CD5205
0346 CDB30S
0349 3600
034B EB
034C 7E
0340 E6FO
034F 77
0350 D320
0352 3E20
0354 CD2107

HOMEHARD:
IF
CALL
CALL
MVI
XCHG
MOV
ANI
MOV
OUT
MVI
CALL

NEWDSK
iGET VALUE OF DRIVE FOR HOM
004H
iIS IT A HARD DISK ??
HOMEHARD
iYES, PROCESS ••••
030H,HOMEHARD-$-1
i---- FAKE JRNC INS
DSKSEL
ERFLAG
A

HOMEIA
020H,HOMEIA-$-1
POINT
M,OOOH
DBL$UPDATE
A,OOAH
FINTFIX
FPYWAIT
STATUS
10011000B
A,001H

HARDSK
DSKSEL
POINT
M,OOOH
A,M
11110000B
M,A
020H
A,020H
INTFIX

i

0357 CDl707
035A OEl4
035C CD8207
035F AF
0360 D322

HOME2:

i

0362 3AFCOA
0365 E65D
0367 C8
0368 3EOI
036A C9

CALL
MVI
CALL
XRA
OUT
LXI
CALL
LDA
ANI
RZ
MVI
ENDIF
RET

WAITO
C,20
DELAY
A

022H
H,MHM
MSPRT
STATUS
01011101B

.iSELECT CORRECT DRIVE (IN A

,

iCHECK FOR ERRORS DURING SE
iEXIT IF ERRORS
i - - - - FAKE JRNZ INSTRUCTION
iPOINT TO TRACK REGISTER SA
iRESET TO TRACK ZERO

.,

iHOME COMMAND ••••
iCLEAR ANY PENDING INTERRUP
iAND ISSUE COMMAND
iWAIT UNTIL I/O COMPLETE
iPICKUP STATUS BYTE
iCHECK STATUS
iRETURN WITH GOOD ESULT
iSET ERROR ON HOME
i AND RETURN ••••

iSELECT CORRECT DRIVE (IN A
iPOINT TO SAVE AREA
iSET TO TRACK ZERO
iPOINT TO SELECT WORD
iLOAD SELECT MASK
iRESET HEAD MASK
iSAVE
iWRITE HEAD/SELECT MASK
iHOME COMMAND
iCLEAR ANY PENDING INTERRUP
iAND ISSUE COMMAND
;WAIT UNTIL I/O COMPLETE
iDELAY FOR 20 MILLISECONDS
i

;SET NEW TRACK REGISTER TO
iFOR CONTROLLER
i***DEBUG***
i***DEBUG***
iPICKUP STATUS BYTE
iCHECK STATUS
;

A,OOlH

iSET ERROR ON HOME
iAND RETURN

PAGE

All Information Presented Here is Proprietary to Digital Research
113

Appendix E

MP/M II System Guide

MP/M Banked XIOS

i---------------------------------------------------------;

;
;

THESE ARE THE HARD DISK UNBLOCK/REBLOCK AND READ AN
ROUTINES CALLED BY THE BDOS SOFTWARE.

;

j---------------------------------------------------------036B AF
036C 32FlOA
036F 3EOI
0371 32F80A
0374 32F"70A
0377 3E02
0379 32F90A

READHARD:
IF
XRA
STA

MVI
STA
STA
MVI
STA
JR
DB
ENDIF

037C+1864

037E AF
037F 32F80A
0382 79
0383 32F90A

WRITEHARD:
IF
XRA
STA
MOV
STA
if
ani
JRZ
DB
else
CPI
JRNZ
endif

0386 E602
0388+2817

;
;
;

038A 3E80
038C 32FlOA
038F 3AE60A
0392 32F20A
0395 2AE70A
0398 22F30A
039B 3AE90A
039E 32F50A

HARDSK
A

;RESET UNALLOCATED COUNT

UNACNT
A,OOlH
READOP
RSFLAG
A,WRUAL
WRTYPE
RWOPER
018H,RWOPER-$-1

;

;READ THE SELECTED CP/M SEC
;

;MUST READ DATA
;

;TREAT AS UNALLOCATED
;TO PERFORM THE READ
;---- FAKE JR INSTRUCTION -

HARDSK
A

READOP
A,C
WRTYPE

;WRITE THE SELECTED CP/M SE
;NOT A READ OPERATION
;WRITE TYPE IS PASSED IN RE

mpm20
WRUAL
;IS IT WRITE UNALLOCATED ??
CHKUNA
;CHECK FOR UNALLOCATED
028H,CHKUNA-$-1 ;---- FAKE JRZ INSTRUCTION
WRUAL
CHKUNA

;IS IT WRITE UNALLOCATED ??
;CHECK FOR UNALLOCATED

WRITE TO UNALLOCATED, SET PARAMETERS
MVI
STA
LDA
STA
LHLD
SHLD
LDA
STA

A,BLKSIZ/128
UNACNT
NEWDSK
UNADSK
NEWTRK
UNATRK
NEWSEC
UNASEC

iNEXT UNALLOC RECS
i

;DISK FOR I/O
;UNADSK = NEWDSK
i

iUNATRK = NEWTRK
iUNASEC

= NEWSEC

;

CHECK FOR WRITE TO UNALLOCATED SECTOR
;

CHKUNA:
03Al 3AFIOA
03A4 B7

LDA
ORA

UNACNT

iANY UNALLOCATED REMAIN ??

A

;

All Information Presented Here is Proprietary to Digital Research
114

Appendix E

MP/M II System Guide
JRZ
DB

03A5+2833

ALLOC
028H,ALLOC-$-1

MP/M Banked XIOS

iSKIP IS NOT
i---- FAKE JRZ INSTRUCTION

MORE UNALLOCATED RECORDS REMAIN
03A7 3D
03A8 32FlOA
03AB 3AE60A
03AE 2lF20A
03Bl BE

DCR
STA
LDA
LXI
CMP
JRNZ
DB

03B2+2026

A

iUNACNT = UNACNT - 1

UNACNT
NEWDSK
H,UNADSK

iSAME DISK ??

M

ALLOC
020H,ALLOC-$-1

i
i

iNEWDSK = UNADSK ??
iSKIP IF NOT
i - - - - FAKE JRNZ INSTRUCTION

i

DISKS ARE THE SAME
03B4 2lF30A
03B7 CD6l04
03BA+20lE

LXI
CALL
JRNZ
DB

H,UNATRK
NEWTRKCMP
ALLOC
020H,ALLOC-$-1

i

iNEWTRK = UNATRK ??
iSKIP IF NOT
i---- FAKE JRNZ INSTRUCTION

TRACKS ARE THE SAME
03BC 3AE90A
03BF 2lF50A
03C2 BE
03C3+20l5

LDA
LXI
CMP
JRNZ
DB

NEWSEC
H,UNASEC
M

ALLOe
020H,ALLOC-$-1

iSAME SECTOR ??
i

iNEWSEC = UNASEC ??
iSKIP IF NOT
i---- FAKE JRNZ INSTRUCTION

MATCH, MOVE TO NEXT SECTOR FOR FUTURE REFERENCE
03C5 34
03C6 7E
03C7 FE80
03C9+3809

INR
MOV
CPI
JRC
DB

M

A,M
CPMSPT
NOOVF
038H,NOOVF-$-1

iUNASEC = UNASEC + 1
iEND OF TRACK ??
iCOUNT CP/M SECTORS
iSKIP IF NO OVERFLOW
i---- FAKE JRC INSTRUCTION

OVERFLOW TO NEXT TRACK
03CB
03CD
03DO
03Dl

3600
2AF30A
23
22F30A

MVI
LHLD
INX
SHLD

M,OOOH
UNATRK
H

UNATRK

iUNASEC = 0
i

iUNATRK = UNATRK + 1

MATCH FOUND, MARK AS UNNECESSARY READ
All Information Presented Here is Proprietary to Digital Research
115

Appendix E

MP/M II System Guide

MP/M Banked XIOS

NOOVF:
XRA
STA
JR
DB

03D4 AF
03D5 32F70A
03D8+1808

A
RSFLAG
RWOPER
018H,RWOPER-$-1

iZERO TO ACCUMULATOR
iRSFLAG = 0
iTO PERFORM THE WRITE
i---- FAKE JR INSTRUCTION -

NOT AN UNALLOCATED RECORD, REQUIRES PRE-READ
ALLOC:
03DA AF
03DB 32FI0A
03DE 3C
03DF 32F70A

XRA
STA
INR
STA

A

UNACNT
A

RSFLAG

iZERO TO ACCUMULATOR
iUNACNT = 0
iONE TO ACCUMULATOR
iRSFLAG = 1

i---------------------------------------------------------THE FOLLOWING CODE IS COMMON TO BOTH READ AND WRITE

i---------------------------------------------------------RWOPER:
03E2 AF
03E3 32F60A
03E6 3AE90A

XRA
STA
LDA
REPT
ORA
RAR
ENDM
ORA
RAR
ORA
RAR
ORA
RAR
STA

03E9+B7
03EA+IF
03EB+B7
03EC+IF
03ED+B7
03EE+IF
03EF 32EEOA

i
03F2 21EFOA
03F5 7E
03F6 3601
03F8 B7

i

iZERO TO ACCUMULATOR
iNa ERRORS yET ••••
iCOMPUTE HOST SECTOR
iCOMPUTE HOST SECTOR
iCARRY = 0
iSHIFT RIGHT

A

iCARRY = 0
iSHIFT RIGHT
iCARRY = 0
iSHIFT RIGHT
iCARRY = 0
iSHIFT RIGHT
iHOST SECTOR TO SEEK

A
A
NEWHST

ACTIVE HOST SECTOR ??
LXI
MOV
MVI
ORA
JRZ
DB

03F9+2821

A
ERFLAG
NEWSEC
SECSHF
A

H,HSTACT
iHOST ACTIVE FLAG
A,M
M,OOlH
iALWAYS BECOMES 1
iWAS IT ALREADY??
A
FILLHST
iFILL HOST IF NOT
028H,FILLHST-$-1
i---- FAKE JRZ INST

HOST BUFFER ACTIVE, SAME AS SEEK BUFFER

All Information Presented Here is Proprietary to Digital Research
116

Appendix E

MP/M II System Guide
03FB 3AE60A
03FE 21EAOA
0401 BE

LDA
LXI
CMP
JRNZ
DB

0402+2011

MP/M Banked XIOS

NEWDSK
i
H,HSTDSK
iSAME DISK ??
M
iNEWDSK = HSTDSK ??
NOMATCH
i
i - - - - FAKE JRNZ INS
020H,NOMATCH-$-1

SAME DISK, SAME TRACK ??
0404 21EBOA
0407 CD6104

LXI
CALL
JRNZ
DB

040A+2009

H,HSTTRK
i
NEWTRKCMP
iNEWTRK = HSTTRK ??
NOMATCH
i
020H,NOMATCH-$-1
i---- FAKE JRNZ INS

i

SAME DISK, SAME TRACK, SAME BUFFER ??
i

040C 3AEEOA
040F 21EDOA
0412 BE

LDA
LXI
CMP
JRZ
DB

0413+2824

NEWHST
H,HSTSEC

i

M

.,iNEWHST = HSTSEC ??

MATCH
028H,MATCH-$-1

i----

iSKIP IF MATCH
FAKE JRZ INSTRUCTION

i
i

PROPER DISK, BUT NOT CORRECT SECTOR

NOMATCH:
0415 3AFOOA
0418 B7
0419 C46D04

LDA
ORA
CNZ

HSTWRT

iHOST WRITTEN ??

A

i

WRITEHST

iCLEAR HOST BUFFER

MAY HAVE TO FILL HOST BUFFER
FILLHST:
041C 3AE60A
041F 32EAOA
0422 2AE70A
0425 22EBOA
0428 3AEEOA
042B 32EDOA
042E 3AF70A
0431 B7
0432 C47F04
0435 AF
0436 32FOOA

LDA
STA
LHLD
SHLD
LDA
STA
LDA
ORA
CNZ
XRA
STA

NEWDSK
HSTDSK
NEWTRK
HSTTRK
NEWHST
HSTSEC
RSFLAG
A
READHST
A
HSTWRT

LDA
ANI
MOV

NEWSEC
SECMSK
L,A

i
iNEED TO READ ??
i
iYES, IF 1
iZERO TO ACCUMULATOR
iNO PENDING WRITE

MATCH:
0439 3AE90A
043C E607
043E 6F

iMASK BUFFER NUMBER
iLEAST SIGNIF BITS
iREADY TO SHIFT

All Information Presented Here is Proprietary to Digital Research
117

Appendix E

MP/M II System Guide
043F 2600

MVI
REPT
DAD
ENDM
DAD
DAD
DAD
DAD
DAD
DAD
DAD

0441+29
0442+29
0443+29
0444+29
0445+29
0446+29
0447+29

H,OOOH
7
H

MP/M Banked XIOS

iDOUBLE COUNT

H
H
H
H
H
H
H

HL NOW HAS RELATIVE HOST BUFFER ADDRESS
0448 119COE
044B 19
044C EB
044D 2AAFOO
0450 EB

LXI
DAD
XCHG
LHLD
XCHG
LXI
LDA
ORA
JNZ

0451 3AF80A
0454 B7
0455 C23DOE

.

,
0458 3E01
045A 32FOOA
045D EB
045E C33DOE

D,HSTBUF
D
DMAADR
B,128
READOP
A
RWMOVE

i

iHL = HOST ADDRESS
iNOW IN DE
iGET/PUT CP/M DATA
iSET FOR Z80 LDIR INSTRUCTI
iLENGTH OF MOVE
iWHICH WAY??

.,

iSKIP IF READ

WRITE OPERATION, MARK AND SWITCH DIRECTION
MVI
STA
XCHG
jmp
endif

A,OOlH
HSTWRT

i

iHSTWRT = 1
iSWAP DIRECTION

rwmove

PAGE

i---------------------------------------------------------UTILITY SUBROUTINE FOR 16 BIT COMPARE

i---------------------------------------------------------0461 EB
0462 21E70A
0465 1A
0466 BE
0467 CO
0468 13
0469 23
046A 1A

IF
NEWTRKCMP:
XCHG
LXI
LDAX
CMP
RNZ
INX
INX
LDAX

HARDSK
H,NEWTRK
D
M
D
H
D

iHL = .UNATRK OR .HSTTRK
i

iLOW BYTE COMPARE
iSAME ??
iRETURN IF NOT
iTO CHECK HIGH BYTE

All Information Presented Here is Proprietary to Digital Research
118

Appendix E

MP/M II System Guide
CMP
RET

046B BE
046C C9

M

MP/M Banked XIOS

;SETS FLAGS

PAGE

i---------------------------------------------------------;

;

;

WRITEHST PERFORMS THE PHYSICAL WRITE TO THE HOST DI
READHST PERFORMS THE PHYSICAL READ FROM THE HOST DI
HSTDSK = HOST DISK NUMBER
HSTTRK = HOST TRACK NUMBER
HSTSEC = HOST SECTOR NUMBER
RETURN ERROR FLAG IN ERFLAG

i---------------------------------------------------------046D 3E05
046F 32CEOO
0472 3E02
0474 32FAOA
0477 219BOE
047A 22BCOO
047D+1810

WRITEHST:
MVI
STA
MVI
STA
LXI
SHLD
JR
DB

A,005H
DMAS3F
A,002H
CMD
H,HSTBUF-l
DMASA
HRWO
018H,HRWO-$-1

iSETUP DMA FOR WRITE
;

iWRITE COMMAND
;SAVE FOR LATER
iWRITE MUST WRITE CONTROL B
i
i----

FAKE JR INSTRUCTION -

READHST:
047F 3EOI
0481 32CEOO
0484 3E04
0486 32FAOA
0489 219COE
048C 22BCOO

MVI
STA
MVI
STA
LXI
SHLD

A,OOlH
DMAS3F
A,004H
CMD
H,HSTBUF
DMASA

;SETUP DMA FOR READ

MVI
STA
MVI
STA

A,05
T$RETRIES
A,OFFH
HOME$TOGGLE

iFIVE RETRIES
;SETUP TEMPORARY RETRIES CO
;INIT TOGGLE SO THAT NO HOM
;ALTERNATE RETRIES WILL BE
iOTHER RETRIES WILL BE DONE

LDA
STA
LDA
CALL
CALL
XCHG
MVI
ANA
MOV
PUSH
CALL
MOV

HSTSEC
SECTNO
HSTDSK
DSKSEL
POINT

iHOST SECTOR NUMBER
iSAVE SECTOR NUMBER
;PICKUP DRIVE ID FOR SELECT
iSELECT CORRECT DRIVE FOR I
;POINT TO TRACK REGISTER SA
;POINT TO SELECT MASK
;TO REMOVE CURRENT HEAD SEL

i

iREAD COMMAND
iSAVE FOR LATER
iREAD ONLY DATA BYTES

HRWO:
048F
0491
0494
0496

3E05
32020B
3EFF
32030B
HRWl:

0499 3AEDOA
049C 32BI00
049F 3AEAOA
04A2 CD5205
04A5 CDB305
04A8 EB
04A9 3EFO
04AB A6
04AC 77
04AD E5
04AE CD3205
04Bl 7D

A,11110000B
M

M,A

;

H

;SAVE MASK ADDRESS
iCOMPUTE CORRECT HEAD NUMBE
iTRACK NUMBER AFTER HEAD CA

SETHED
A,L

All Information Presented Here is Proprietary to Digital Research
119

Appendix E

MP/M II System Guide
STA
POP
LDA
ORA
MOV
ANI
OUT
MVI
CALL

04B2 32ADOO
04B5 El
04B6 3AAEOO
04B9 B6
04BA 77
04BB E67F
04BD D320
04BF OEOI
04Cl CD8207

MP/M Banked XIOS

TRAKNO

;

H

;RESTORE MASK ADDRESS
;TO OR IN NEW HEAD NUMBER

HEADNO
M

.,

M,A
07FH
020H
C,l
DELAY

;SAVE NEW DRIVE/HEAD SELECT
; MASK OFF LARGE DRIVE FLAG
;WRITE IT TO SELECT NEW HEA
;DELAY FOR 1 MILLISECOND

POINT
TRAKNO

;IS A SEEK NECESSARY??
; CHECK
;WELL ??
;NO SEEK NECESSARY •••
;---- FAKE JRZ INSTRUCTION

HRW2:
CALL
LDA
CMP
JRZ
DB

M

OUT
MOV
MOV
MOV
OUT
MVI
CALL

022H
B,M
M,A
A,B
02lH
A,OlOH
INTFIX

CALL
MVI
CALL

WAITO
C,20
DELAY

LDA
OUT

SECTNO
02lH

;SET SECTOR

H,DMASI
B,0600H

,

04FC+EDB3

LXI
LXI
OUTIR
DB
LXI
LXI
OUTIR
DB
LXI
LXI
OUTIR
DB

OEDH,OB3H

;---- FAKE OTIR INSTRUCTION

04FE 3AFAOA
0501 CD2l07

LDA
CALL

CMD
INTFIX

CALL

WAITO

;PICKUP I/O COMMAND
;CLEAR ANY PENDING INTERRUP
;AND ISSUE COMMAND
;WAIT FOR COMPLETION

MVI

A,OlOlllOlB

;SETUP STATUS AND MASK

04C4 CDB305
04C7 3AADOO
04CA BE
04CB+2814

HRW5
028H,HRW5-$-1

HRW3:
04CD D322
04CF 46
04DO 77
04Dl 78
04D2 D32l
04D4 3ElO
04D6 CD2l07
;

04D9 CD1707
04DC OE14
04DE CD8207

HRW4:

;WRITE NEW TRACK NUMBER
;SAVE TEMPORARILY
;UPDATE TRACK REGISTER SAVE
;OLD TRACK NUMBER
;TO OLD TRACK REGISTER
;SEEK COMMAND
;CLEAR ANY PENDING INTERRUP
;AND ISSUE COMMAND
;WAIT FOR I/O
;DELAY AFTER SEEK FOR 20 MI

HRW5:
04El 3ABIOO
04E4 D32l
HRW6:
04E6 2lBAOO
04E9 010006
04EC+EDB3
04EE 2lCOOO
04Fl 010006
04F4+EDB3
04F6 2lCAOO
04F9 010007

OEDH,OB3H
H,DMAS2H
B,0600H

0507 3E5D

HRW7:

;---- FAKE OTIR INSTRUCTION
;
;

OEDH,OB3H
H,DMAS3
B,0700H

;---- FAKE OTIR INSTRUCTION
;

;

0504 CD1707

.;SETUP DMA FOR HARD DISK 1/

All Information Presented Here is Proprietary to Digital Research
120

Appendix E

MP/M II System Guide
0509 32FBOA
050C CDAE06
050F C8

STA
CALL
RZ

MASK
CHECK$STAT

0510 3A030B
0513 2F
0514 32030B

LDA
CMA
STA

HOME $ TOGGLE

0517+1880

JR
DB
ENDIF

HRWI
018H,HRWl-$-1

MP/M Banked XIOS

iSAVE FOR STATUS CHECK
iCHECK STATUS FROM I/O
iOK ??

.,
iCHANGE TOGGLE SO THAT HOME

HOME$TOGGLE
iRETRY I/O

,._--- FAKE JR INSTRUCTION -

PAGE
i-----~----------------------------------------------- -----

DOUBLE SIDED TRACK REGISTER UPDATE ROUTINE
i
;---------~------------------------------------------- -----

0519 3AB600
051C E601
051E C8
051F 3AACOO
0522 FE04
0524 DO
0525 E602
0527 7E
0528+2804
052A 2B
052B 2B
052C+1802

DBL$UPDATE:
LDA
ANI
RZ
LDA
CPI
RNC
ANI
MOV
JRZ
DB
DCX
DCX
JR
DB

MPARMS
1

iCHECK FOR DOUBLE SIDED DRI
i
IS FLAG SET
i
NO - SO RETURN
DISKNO
iCURRENT DISK DRIVE
004H
iIS IT A FLOPPY
iNO, RETURN WITHOUT UPDATE
00000010B
iIS THIS DRIVE 2 OR 3 ??
A,M
iWE WERE CALLED WITH (HL) P
DBL$LOW
iIT MUST BE DRIVE ZERO OR 0
028H,DBL$LOW-$-1
i---- FAKE JRZ INST
H
iBACKUP TO OTHER SIDE POINT
H
i
DBL$SAVE
i
018H,DBL$SAVE-$-1
:---- FAKE JR INSTR

DBL$LOW:
QS2E 23
052F 23

INX
INX

0530 77
0531 C9

DBL$SAVE:
MOV
RET

H

iBUMP UP TO DRIVE TWO OR TH

H

M,A

iUPDATE OTHER SIDE REGISTER

PAGE
;----------------~------------------------------------ -----

;
i

i

ROUTINE TO COMPUTE HEAD NUMBER FROM TRACK NUMBER
TRACK NUMBER IS IN HL ON ENTRY

i---------------------------------------------------------IF

HARDSK

SETHED:
All Information Presented Here is Proprietary to Digital Research
121

Appendix E

MP/M II System Guide
0532 2AEBOA
0535 E680
0537 7D

LHLD
ANI
MOV
JRZ
DB
ANI

0538+2806
053A E607
053C OE03
053E+1804
0540 E603
0542 OE02
0544 32AEOO
0547 B7
0548 7C
0549 IF
054A 67
054B 7D
054C IF
054D 6F
054E OD
054F+20F6
0551 C9

MVI

JR
DB
SETH14: ANI
MVI

SETDVD: STA
SHDI:
ORA
MOV
RAR
MOV
MOV
RAR
MOV
DCR
JRNZ
DB
RET
ENDIF

HSTTRK
80H
A,L
SETH14
028H,SETH14-$-1
OOOOOIIIB
C,3
SETDVD
018H,SETDVD-$-1
OOOOOOIIB
C,2
HEADNO
A

A,H
H,A
A,L
L,A
C

SHDI
020H,SHDI-$-1

MP/M Banked XIOS

:CP/M TRACK NUMBER (0-800)
: CHECK FOR LARGE DRIVE
:LOW ORDER
: SMALL DRIVE
:---- FAKE JRZ INSTRUCTION
:GET TRACK MOD 8 (HEAD NUMB
:LIMIT LOOP FOR DIVIDE BY E

:

:---- FAKE JR INSTRUCTION :GET TRACK MOD 4 (HEAD NUMB
:LIMIT LOOP FOR DIVIDE BY F
:SAVE AS HEAD NUMBER
:ENSURE CARRY IS ZERO
:FOR SHIFT
:ONE BIT

:
:LOW ORDER
:CARRY PARTICIPATES FROM HI

:

:END OF DIVIDE YET ??
:NO, CONTINUE
:---- FAKE JRNZ INSTRUCTION
:RETURN TO CALLER, TRACK IN

PAGE

i----------------------------------------------------------

:
;

;
;
;
;

DISK DRIVE SELECT ROUTINE
ON ENTRY, THE ACCUMULATOR CONTAINS THE DRIV
RETURNS CARRY SET FOR HARD DISK SELECTED
RETURNS CARRY RESET FOR FLOPPY DISK SELECTE

i---------------------------------------------------------DSKSEL:
0552 FE04

CPI
JRNC
DB

0554+3045

004H
;IS IT HARD DISK ??
SELHARD
:YES, GO PROCESS ••••
030H,SELHARD-$-1
:---- FAKE JRNC INS

SELSOFT:
0556 21ACOO
0559 BE

LXI
CMP
JRZ
DB
MOV

055A+2819
055C 77

H,DISKNO
M

SLS3
028H,SLS3-$-1
M,A

:CURRENT DRIVE NUMBER
iSAME DRIVE AS LAST TIME ??
iYES, DONT BOTHER WITH UNLO
:---- FAKE JRZ INSTRUCTION
iUPDATE WITH CURRENT DRIVE

,.----------~------------------------------------------ ----;
i

.,

WE WILL NOW FORCE THE HEAD TO UNLOAD PRIOR TO THE S
TO ENSURE THAT WHEN WE RETURN TO THIS DISK WE WILL
LOAD AND WAIT FOR THE HEAD TO SETTLE •

i----------------------------------------------------- -----

All Information Presented Here is Proprietary to Digital Research
122

MP/M II System Guide

Appendix E

MP/M Banked XIOS

SLSl:
055D DB04
055F IF
0560+38FB
0562 DB05
0564 D307

IN
RAR
JRC
DB
IN
OUT

0566 3E12
0568 CD6307

MVI
CALL

056B CD3A07
056E 3AFCOA
0571 E698

.,
SLS2:

0573+2020

CALL
LDA
ANI
JRNZ
DB

004H

iENSURE FLOPPY PORT NOT BUS

SLS1
038H,SLSl-$-1
005H
007H

i
i----

FAKE JRC INSTRUCTION
iREAD THE TRACK REGISTER
iENSURE WE DONT MOVE THE HE

iSEEK AND UNLOAD HEAD
iCLEAR ANY PENDING INTERRUP
AND ISSUE COMMAND
i
iWAIT HERE FOR INTERRUPT
FPYWAIT
STATUS
iHOW DID THE I/O GO?
CHECK
10011000B
i
SLSERR
iEXIT IF ERROR
020H,SLSERR-$-1 i---- FAKE JRNZ INSTRUCTION
A,012H
FINTFIX

i----------------------------------------------------- ---~-

WE WILL NOW LOAD THE SELECT MASK AND SELECT THE DRI
EVEN IF ITS THE SAME DRIVE BECAUSE THE DENSITY MAY
HAVE CHANGED.

i---------------------------------------------------------SLS3:
'CALL
XCHG
LDA
CPI
MVI
JRNC
DB
MVI

0575 CDB305
0578 EB
0579 3AADOO
057C FE02
057E 3EFF
0580+3002
0582 3EFE

POINT
TRAKNO
002H
A,1111l11lB
SLS4
030H,SLS4-$-1
A,lllll110B

iPOINT TO TRACK SAVE AREA
iPOINT TO SELECT MASK
iNEXT TRACK FOR I/O
iIS IT TRACK ZERO OR ONE
iASSUME NO ••••
iVERIFY ASSUMPTION
i - - - - FAKE JRNC INSTRUCTION
iFORCE SINGLE DENSITY FOR 0

M
D08H
004H

iLOAD MASK AND CORRECT IF N
;SELECT IT
i I S DRIVE READY?

SLS4:
0584 A6
0585 D308
0587 DB04
0589 17
058A+3809
058C EB
058D 7E
058E D305
0590 AF
0591 32F60A
0594 C9

ANA
OUT
IN
RAL
JRC
DB
XCHG
MOV
OUT
XRA
STA
RET

0595 AF
0596 3C
0597 32F60A
059A C9

SLSERR: XRA
INR
STA
RET

i

SLSERR
i IF NOT ••• BRANCH
038H,SLSERR-$-1 i - - - - FAKE JRC INSTRUCTION
;RESTORE TRACK REGISTER ADD
A,M
iPICK UP TRACK NUMBER
005H
iGIVE IT TO CONTROLLER
;ENSURE CARRY IS RESET
A
ERFLAG
iALSO ZERO ERROR INDICATOR
A
A
ERFLAG

;ENSURE CARRY IS RESET
iSET TO 1 FOR ERROR FLAG
iSHOW ERROR

All Information Presented Here is Proprietary to Digital Research
123

Appendix E

MP/M II System Guide

MP/M Banked XIOS

.,i---------------------------------------------------------;
;

THIS ROUTINE SETS UP THE HARD DISK BY SELECTING THE
DRIVE AND RELOADING THE HEAD AND TRACK REGISTERS IN
HARD DISK CONTROLLER READY FOR I/O LATER •

.,

-----------------------------~----------------------- -----

SELHARD:
059B 2lACOO
059E BE
059F C8
05AO 77

IF
LXI
CMP
RZ
MOV

HARDSK
H,DISKNO
M

CALL
XCHG
MOV
OUT
XCHG
MOV
OUT
MVI
CALL
STC
ENDIF
RET

POINT

;CURRENT DRIVE SELECTED
;SAME ??
;YES, NO NEW SELECT NECESSA
;UPDATE DISKNO

M,A

SJ:,HI:
05AI CDB305
05A4 EB
05A5 7E
05A6 D320
05A8 EB
05A9 7E
05AA D322
05AC OEl4
05AE CD8207
05Bl 37
05B2 C9

;TRACK SAVE REGISTER
;POINT TO SELECT MASK
;LOAD DRIVE/HEAD VALUE
iWRITE IT TO SELECT PORT
iREGAINADDRESS OF TRACK RE
iLOAD OLD TRACK NUMBER
iWRITE IT TO OLD TRACK REGI
iDELAY FOR 20 MILLISECONDS

A,M
020H
A,M
022H
C,20
DELAY

i

iSET CARRY TO SHOW HARD DIS
iRETURN TO CALLER

PAGE
;--------------------~------------------~------------- -----

i

SUBROUTINE TO POINT TO CURRENT TRACK REGISTER SAVE

,

e _________________________________________________________ _

POINT:
05B3 2AACOO
05B6 7D
05B7 2600
05B9 117000
05BC 19
05BD 54
05BE 5D
05BF OIOCOO
05C2 09
05C3 FE04
05C5+380D
05C7 3E10
05C9 A6
05CA+2805

LHLD
MOV
MVI
LXI
DAD
MOV
MOV
LXI
DAD
IF
CPI
JRC
DB
MVI
ANA
JRZ
DB

DISKNO
A,L
H,O
D,TRKO
D

D,H
E,L
B,12
B

iPICKUP CURRENT DISK
i

iRESET HIGH ORDER HALF
iLOAD TRACK POINTER
iPOINT TO CURRENT TRACK PTR
i DE = TRACK
i

HL = SELECT

HARDSK
4

i

PNTFN
i FLOPPY DISK
038H,PNTFN-$-1 i---- FAKE JRC INSTRUCTION
A,lOH
;
M
i CHECK DRIVE SELECT
PNTH2
i
MUST BE DRIVE # 2
028H,PNTH2-$-1 i---- FAKE JRZ INSTRUCTION

All Information Presented Here is Proprietary to Digital Research
124

MP/M II System Guide

OSCC IlB800
OSCF+1803
OSDI IlB900
OSD4 EB
OSDS C9

PNTH2:
PNTFN:

LXI
JR
DB
LXI
ENDIF
XCHG
RET

Appendix E

MP/M Banked XIOS

D,HTKI
~ POINT TO DRIVEl
PNTFN
~
018H,PNTFN-$-1 ~---- FAKE JR INSTRUCTION POINT TO DRIVE 2
D,HTK2
SWITCH
HL = TRACK

DE = SELECT

i---------------------------------------------------------~

ROUTINE TO TRANSLATE SECTOR NUMBER

;-------------------------------------~--------------- -----

OSD6 EB
OSD7 7C
OSD8 BS

SECTRAN:

05D9+2807

XCHG
MOV
ORA
JRZ
DB

ADDRESS IS IN DE (NO
THERE A TABLE ADDRESS?

~TABLE

L

.,

STRN2
028H,STRN2-$-1

~----

B,OOOH

~ENSURE

B

~ADD SECTOR NUMBER
~LOAD TRANSLATED VALUE

A,H

~IS

JUST RETURN ENTERED QU
FAKE JRZ INSTRUCTION

~NO,

STRNl:
OSDB 0600
05DD 09
05DE 6E
05DF 2600
OSEI C9

MVI
DAD
MOV
MVI
RET

L,M
H,OOOH

OK FOR SINGLE BYTE

~

~NEW

VALUE RETURNED IN HL

STRN2:
05E2 09
05E3 C9

DAD
RET

~RETURN

B

SAME VALUE AS ENTER

i---------------------------------------------------------~

ROUTINES TO DO FLOPPY I/O

,

e __________________________________________________________

05FO+180F

READSOFT:
MVI
STA
MVI
STA
MVI
JR
DB

A,09FH
MASK
A,OOlH
DMAS3F
A,08CH
SRWI
O18H,SRWl-$-1

05F2 3EFF
OSF4 32FBOA
05F7 CD6BOE
OSFA 3E05
05FC 32CEOO
05FF 3EAC

WRITESOFT:
MVI
STA
CALL
MVI
STA
MVI

A,OFFH
MASK
MVDTB
A,OOSH
DMAS3F
A,OACH

05E4
05E6
OSE9
OSEB
05EE

3E9F
32FBOA
3EOI
32CEOO
3E8C

~MASK

FOR READ STATUS

~

~SETUP

DMA FOR READ

~READ

COMMAND

i----

FAKE JR INSTRUCTION -

~MASK

FOR WRITE STATUS

~

~SETUP

DMA FOR WRITE

~

~WRITE

COMMAND

All Information Presented Here is Proprietary to Digital Research

125

Appendix E

MP/M II System Guide

MP/M Banked XIOS

SRWl:
0601 32FAOA
0604 211D13
0607 22BCOO
060A 3AE60A
060D CD5205
0610 3AF60A
0613 B7
0614 CO

STA
LXI
SHLD
LDA
CALL
LDA
ORA
RNZ

CMD
H,FPYBUF
DMASA
NEWDSK
DSKSEL
ERFLAG
A

i
i
i

iSELECT DRIVE FOR I/O
iCHECK FOR SELECT ERROR
i

iRETURN IF ERROR

SRW2:
0615 3EOA
0617 32020B
061A AF
061B 32030B
061E DB08
0620 E602
0622+20lF
0624 DB05
0626 D307
0628 3EIA
062A CD6307
062D CD3A07
0630 3AFCOA
0633 E698

MVI
STA
XRA
STA
LOAD$HEAD:
IN
ANI
JRNZ
DB
IN
OUT
MVI
CALL

0635+2044
0637 OEI0
0639 CD8207
063C CDB305
063F 36FE
0641+1807
0643 21FAOA
0646 3EFB
0648 A6
0649 77

iSET NUMBER OF TRIALS
iSAVE FOR RETRY ROUTINE

A

HOME $ TOGGLE

iFORCE HOME PRIOR TO EACH R

CALL
LDA
ANI
JRNZ
DB

008H
iIS HEAD LOADED ??
OOOOOOlOB
iCHECK IT ••••
REMOVE$LD
iYES, ITS LOADED, DONT RELO
020H,REMOVE$LD-$-1
i---- FAKE JRNZ INS
005H
iDUMMY SEEK TO START HEAD L
007H
iKEEP IT SHORT ••••
A,OlAH
iSTART HEAD LOADING
FINTFIX
iCLEAR ANY PENDING INTERRUP
iAND ISSUE COMMAND
FPYWAIT
iWAIT FOR I/O TO COMPLETE
STATUS
iHOW DID IT GO?
10011000B
iCHECK
CHECKIT
iDO NOT GO ON IF ERROR
020H,CHECKIT-$-1
;---- FAKE JRNZ INS

MVI
CALL
CALL
MVI
JR
DB

C,16
DELAY
POINT
M,254
TRKTST
018H,TRKTST-$-1

.,

LDHl:

A,lO
T$RETRIES

REMOVE$LD:
LXI
MVI
ANA
MOV

H,CMD
A,111l1011B
M

M,A

iWAIT HERE FOR 16 MS
iCALL WAIT ROUTINE
iREESTABLISH TRACK REGISTER
iENSURE FURTHER SEEK AND DE
i

;---- FAKE JR INSTRUCTION ;POINT TO I/O COMMAND
;REMOVE HEAD LOAD BIT
iDO IT ••••
iSAVE IT BACK INTO CMD

TRKTST:
064A CDB305
064D 3AE70A
0650 32ADOO
0653 BE
0654+281A
0656 77
0657 D307

CALL
LDA
STA
CMP
JRZ
DB
MOV
OUT

POINT
; RESTORE TRACK REGISTER POI
NEWTRK
iGET NEW TRACK NUMBER
TRAKNO
iSAVE IN COMMON PLACE
M
iSAME AS LAST TIME ??
FSECSET
iYES, DONT BOTHER WITH SEEK
028H,FSECSET-$-1
;---- FAKE JRZ INST
M,A
iSAVE IT
007H
iALSO SEND IT TO CONTROLLER

All Information Presented Here is Proprietary to Digital Research
126

Appendix E

MP/M II System Guide
0659 CD1905

CALL

065C 3EIA
065E CD6307

FLOPPY$SEEK:
MVI
CALL

DBL$UPDATE

MP/M Banked XIOS

:DOUBLE SIDED SUPPORT

0669+2010

CALL
LDA
ANI
JRNZ
DB

:SEEK COMMAND WITH HEAD LOA
iCLEAR ANY PENDING INTERRUP
:AND ISSUE COMMAND
FPYWAIT
:WAIT FOR I/O TO COMPLETE
STATUS
:HOW DID IT GO?
10011000B
: CHECK
CHECKIT
:DO NOT GO ON IF ERROR
020H,CHECKIT-$-1
:---- FAKE JRNZ INS

066B OEI0
066D CD8207

MVI
CALL

C,16
DELAY

:SET FOR 16 MS DELAY

LDA
STA
OUT

NEWSEC
SECTNO
006H

:SET SECTOR
:SAVE IN COMMONN PLACE

:

CALL

FLOPPYIO

:DO I/O

CALL
LDA
CZ
RZ
JR
DB

CHECK$STAT
ERFLAG
MVDFB

:CHECK STATUS OF I/O
:SETUP TO RETURN TO BDOS

0661 CD3A07
0664 3AFCOA
0667 E698

:

FPSl:

A,OlAH
FINTFIX

FSECSET:
0670 3AE90A
0673 32BI00
0676 D306
0678 CD8706
CHECKIT:
067B CDAE06
067E 3AF60A
0681 CC7EOE
0684 C8
0685+1897

.

,

:EITHER OK OR PERMANENT ERR
LOAD$HEAD
: ERROR, JUST RETRY THIS SAM
018H,LOAD$HEAD-$-1
:---- FAKE JR INSTR

PAGE

i---------------------------------------------------------:

THIS IS THE ROUTINE THAT DOES THE FLOPPY DISK I/O

i---------------------------------------------------------FLOPPYIO:
IF
LXI
LXI
LXI
LDIR

FRD

NOT DMA
H,066H
D,SAVEI
B,004H

iMOVE

DATA FROM 066H TO SAV

:

: MOVE IT

LXI
LXI
LXI
LDIR

H,NMIRTN
D,066H
B,004H

LDA
ANI
JZ
LXI
MVI
EQU
ENDIF

CMD
20H
FRD
H,067H
M,OA3H
$

:SET NMI ROUTINE TO NMI ADD

:
:
:MOVE IT
:IS IT A WRITE ??
i

:NO, LEAVE INI CMD IN LOW M
iPOINT TO COMMAND AREA
:MAKE IT AN OTI CMD ••••
: LABEL

All Information Presented Here is Proprietary to Digital Research
127

Appendix E

MP/M II System Guide

IF
LXI
LXI
OUTIR
DB
LXI
LXI
OUTIR
DB
LXI
LXI
OUTIR
DB
ENDIF

0687 21BAOO
068A 010006
068D+EDB3
Q68F 21C600
0692 010004
069S+EDB3
0697 21CAOO
069A 010007
069D+EDB3
069F OE07
06A1 211D13
06A4 3AFAOA
06A7 CD6307
06AA CD3A07

i

FWT1:

06AD C9

DMA
H,,DMAS1
B,0600H
OEDH,OB3H
H,DMAS2F
B,Q400H

MP/M Banked XIOS

iINITIALIZE DMA
i

iWRITE TO DMA
i---- FAKE OTIR INSTRUCTION
i
i
i WRITE TO DMA
i - - - - FAKE OTIR

OEDH,OB3H
H,DMAS3
B,0700H

;
;

OEDH,OB3H

i WRITE TO DMA
i---- FAKE OTIR

MVI
LXI
LDA
CALL

C,007H
H,FPYBUF
CMD
FINTFIX

CALL

FPYWAIT

IF
LXI
LXI
LXI
LDIR
ENDIF

NOT DMA
H,SAVE1
D,066H
B,004H

INSTRUCTION

INSTRUCTION

iPORT ADDRESS FOR I/O
iDMA ADDRESS
i I/O COMMAND
iCLEAR ANY PENDING INTERRUP
iAND ISSUE COMMAND
iWAIT HERE FOR I/O TO COMPL
iSETUP TO REPLACE DATA
iCOPIED FROM NMI LOCATION
i

iMOVE IT ••••

RET

iRETURN, I/O COMPLETED

;--------------------------------~-------------------- -----

i
i

.,

WE WILL NOW CHECK THE STATUS OF THE I/O OPERATION
RETURN WITH CONDITION CODE ZERO = NO RETRY
RETURN WITH CONDITION CODE NON ZERO = RETRY

i----------------------------------------------------------

06AE 21F60A
06B1 3600
06B3 21FCOA
06B6 3AFBOA
06B9 A6
06BA 77
06BB C8

CHECK$STAT:
LXI
MVI

H,ERFLAG
M,OOOH
H,STATUS
MASK

LXI
LDA
ANA
MOV
RZ

M

CALL
CPI
LXI
MOV
JRNC

RETMOD
003H
H,STATUS
A,M
CHKS2

M,A

iPOINT TO ERROR INDICATOR
iASSUME OK
iCHECK STATUS
iMASK FOR UNWANTED BIT REMO
iSAVE CLEANED STATUS
iOK, SO RETURN

CHKSO:
06BC CDEE02
06BF FE03
06C1 21FCOA
06C4 7E

i

iHARD DISK ??

.,

iRELOAD STATUS BYTE
iYES, CHECK FOR DRIVE READY

All Information Presented Here is Proprietary to Digital Research
128

Appendix E

MP/M II System Guide
06C5+3006

MP/M Banked XIOS

DB

030H,CHKS2-$-1

i----

CPI
JRZ
DB
JR
DB

080H
BADIO
028H,BADIO-$-1
CHKS3
018H,CHKS3-$-1

iIS FLOPPY DISK NOT READY 1

CPI
JRZ
DB
ANI
JRZ
DB
CALL
XCHG
MOV
ORI
OUT
MOV
OUT
MVI
CALL

OOOH
BADIO
028H,BADIO-$-1
OlOOOOOOB
CHKS3
028H,CHKS3-$-1
POINT

FAKE JRNC INSTRUCTION

CHKS1:
06C7 FE80
06C9+283D
06CB+1819

iYES, DONT BOTHER WITH RETR
i---- FAKE JRZ INSTRUCTION

iGO TO BAD MESSAGE ROUTINE
i---- FAKE JR INSTRUCTION -

CHKS2:
06CD FEOO
06CF+2837
06D1 E640
0603+2811
0605 COB305
06D8 EB
06D9 7E
06DA F640
06DC D320
06DE 7E
06DF D320
06E1 OE14
06E3 CD8207

A,M
OlOOOOOOB
020H
A,M
020H
C,20
DELAY

iIS HARD DISK NOT READY 11
iYES, BYPASS ERROR MESSAGE
i---- FAKE JRZ INSTRUCTION
iIS IT WRITE FAULT ??
iNO, CONTINUE ON
i---- FAKE JRZ INSTRUCTION
iPOINT TO TRACK REGISTER
iPOINT TO SELECT MASK
i

iTURN ON WRITE FAULT CLEAR

.,

iRESET CLEAR
i

iDELAY JUST TO BE SAFE

CHKS3:
06E6 3A030B
06E9 B7

HOME$TOGGLE

06EA+200B

LDA
ORA
JRNZ
DB

06EC 3AFCOA
06EF F5
06FO CD1A03
06F3 F1
06F4 32FCOA

LDA
PUSH
CALL
POP
STA

STATUS
PSW
HOME
PSW
STATUS

06F7 119400
06FA CDOF07
06FD 21020B
0700 35
0701 CO

LXI
CALL
LXI
DCR
RNZ

D,TCNT
ADDERRORS
H,T$RETRIES

0702 11AOOO
0705 CDOF07

LXI
CALL

D,PCNT
ADDERRORS

iBUMP PERMANENT ERROR COUNT

LXI

H,ERFLAG
M,OOlH

iSET PERMANENT ERROR
iDO IT ••••
iRESET TO PRECLUDE RETRIES
iRETURN TO CALLER

A

iIS A HOME NEEDED ON THIS R

CHKS4
020H,CHKS4-$-1

i----

FAKE JRNZ INSTRUCTION

.,iSAVE STATUS OVER HOME
iRESET DEVICE TO HOME
i

iSAVE FOR ERROR MESSAGE

CHKS4:

M

iBUMP TEMP ERROR COUNT
i

iPICKUP RETRY COUNT
iDECREMENT COUNT OF RETRIES

BADIO:
0708 21F60A
070B 3601
070D AF
070E C9

MVI
XRA
RET

A

.

ADDERRORS:
All Information Presented Here is Proprietary to Digital Research
129

Appendix E

MP/M II System Guide
070F 2AACOO
0712 2600
0714 19
0715 34
0716 C9

LHLD
MVI
DAD
INR
RET

DISKNO
H,OOOH
0
M

MP/M Banked XIOS

iBUMP COUNT OF DISK ERRORS
i

iPOINT TO ERROR REGISTER
i

PAGE

·, ,. ., ., ., ., ., ., ., ., ., ., ., ., ,.., ., ,.., ,. ,.., ,.., ,.., ., ., ., ., ,.., ., ,.., ., ., ,. ,.., ., ., ., ,.., ., ., ,.., ., ., ., ., ., ., ., ., ., .,
i
i

THIS IS HARD DISK WAIT ENTRY

,·.........................................................
, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , .,
;

WAITO:
0717 CS
0718 OE84
071A 1EOS
071C CD100B
071F C1

PUSH

B

, SAVE RETRY COUNT

MVI
MVI
CALL
POP

C,FLAGWT
E,HDFLAG
XDOS
B

;
;

FUNCTION FLAG WAIT
DEVICE IS HARD DISK

;

RESTORE RETRY COUNTER IN

"-

READ OR WRITE IS OK, ACCUMULATOR CONTAINS ZERO

;

RET

0720 C9

·.. . . .. .. . ... ... .... .. .. ... .. . .. . .. . . . . . .. ... . ... . . . . . .. . . .
,

,

,

,

,

,

,

;
;

,

, # ,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

,

THE FOLLOWING CODE GUARANTEES THAT HARD DISK FLAG I
IT APPEARS THAT WE OCCASIONALLY GET FLAG SET AS A R
OF AN INTERRUPT FROM THE HARD DISK, WHEN WE DO
NOT EXPECT IT.

··, .. .. .. .. ... . . . . . .. .. . ... .. . . . .. . . . . . . .. . . .. .... . . . . . .. . . . .
", """""""" " " " " " " " " " " " " " , """""",
INTFIX:
0721 F5
0722 CS
0723 05
0724 ES

PUSH
PUSH
PUSH
PUSH

PSW
B
0
H

0725 OE8S
0727 1EOS
0729 CD100B

MVI
MVI
CALL

C,FLAGST
E,HDFLAG
XDOS

072C OE84
072E 1EOS
0730 CD100B

MVI
MVI
CALL

C,FLAGWT
E,HDFLAG
XDOS

0733 E1
0734 01

POP
POP

H
0

;

;EITHER FLAG 5 WILL BE SET
;IT IS ALREADY SET - IN WHI
;THIS REQUEST WILL BE IGNOR

;NOW CLEAR THE FLAG

All Information Presented Here is Proprietary to Digital Research
130

Appendix E

MP/M II System Guide

MP/M Banked XIOS

0735 Cl
0736 Fl

POP
POP

B
PSW

;RESTORE REGISTERS

0737 D323

OUT

023H

;ISSUE COMMAND TO HARD DISK

0739 C9

RET
PAGE

·. . . . . . . . .. . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

""""""""""""""""""""""""""""",
THIS IS FLOPPY DISK WAIT ENTRY

· . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

""""""""""""""""""""""""""""",
FPYWAIT:
073A C5
073B E5
073C OES4
073E lE06
0740 CDI00B
0743 F5
0744 3ADOOD
0747 B7

PUSH
PUSH
MVI
MVI
CALL
PUSH
LDA
ORA
JRNZ
DB

074S+2015

075F Fl
0760 El
0761 Cl

IN
ANI
OUT
MVI
CALL
ORI
OUT
LDA
STA
NOFPYRST:
POP
POP
POP

0762 C9

RET

074A DB09
074C E6lS
074E D309
0750 OEOI
0752 CDS207
0755 F602
0757 D309
0759 3AE60A
075C 32ACOO

B

;SAVE RETRY COUNT

H

C,FLAGWT
E,FPYFLAG
XDOS
PSW
FPYTlME

; FUNCTION IS FLAG WAIT
; WAIT FOR FLOPPY
;DID WD1791 GO TO SLEEP?

A

;

NOFPYRST
;IF STILL AWAKE, SKIP RESET
020H,NOFPYRST-$-1
;---- FAKE JRNZ INS
009H
OOOllOOOB
009H
L

C ,l

DELAY
00000010B
009H
NEWDSK
DISKNO

;GET CURRENT BANK NUMBER
;REMOVE OTHER INFO
;RESET WD1791
;DELAY 1 MILLISEC

.,

;END RESET
;MAKE SURE CURRENT DISK AND
; THE SAME

PSW
H

;RESTORE RETRY COUNT IN <C>

B

· . .. . . ..... . . .. ... . . ........ . . . ... . ... ... ... . ...... . .... . . .
""""""""""""""""""""""""""""",

THE FOLLOWING CODE GUARANTEES THAT FLOPPY DISK FLAG

·......................................................... .

""""""""""""""""""""""""""""",
FINTFIX:
0763 F5
0764 C5
0765 D5
0766 E5

PUSH
PUSH
PUSH
PUSH

PSW
B
D
H

All Information Presented Here is Proprietary to Digital Research
131

MP/M II System Guide

Appendix E

0767 OE85
0769 lE06
076B CDlOOB

MVI
MVI
CALL

C,FLAGST
E,FPYFLAG
XDOS

076E OE84
0770 lE06
0772 CDlOOB

MVI
MVI
CALL

C,FLAGWT
E,FPYFLAG
XDOS

0775 210301
0778 22DOOD

LXI
SHLD

H,00103H
FPYTIME

077B El
077C Dl
077D Cl
077E Fl

POP
POP
POP
POP

H
D
B

077F D304

OUT

004H

0781 C9

RET
not mpm20

DW

o

DW
endif

o

FPYTCNT:

;SET TIME OUT INDICATOR ON
; TIME TO BE BETWEEN 2 AND

PSW

if
FPYTIME:

MP/M Banked XIOS

;ISSUE COMMAND TO FLOPPY DI

PAGE

.,i---------------------------------------------------------;

THIS IS THE DELAY ROUTINE. IT WILL LOOP HERE FOR TH
NUMBER OF MILLISECONDS SPECIFIED IN REGISTER C.

;e _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

,
0782 0664
0784 00
0785 29
0786 29
0787 05
0788 C28407
078B OD
078C C28207
078F C9

DELAY:
DELI:
DEL2:

MVI
NOP
DAD
DAD
DCR
JNZ
DCR
JNZ
RET

B,lOO
H
H
B
DEL2
C
DELI

;FORCE DELAY FOR 1 MILLISEC
;INSTRUCTIONS TO FILL IN TI
;

;AT ONE MILLISECOND YET ??
;NO, KEEP ON LOOPING
;END OF REQUESTED INTERVAL
;NO, KEEP ON
;RETURN TO CALLER

,.********************************************
,.* NOTE: THE INITIALIZATION CODE WILL BE
,. *
OVERWRITTEN BY DIRBUF & FPYBUF
,.********************************************
All Information Presented Here is Proprietary to Digital Re§earch
132

Appendix E

MP/M II System Guide

DIRBUF

if
EQU
endif

MP/M Banked XIOS

not mpm20
$

i------------~~--------------------------------------- -----

DISK CONFIGURATION TABLE

,

e _________________________________________________________ _

IF

HARDSK
PIN C

0790
0798
07AO
07A8
07BO
07B8
07CO
07C8

OOOOOOOOOODSCNO:
1000000000
9090900000
0000000000
1000002000
0000000000
9090902000
909090AOAO

DB
DB
DB
DB
DB
DB
DB
DB
ENDIF

OOH,OOH,OOH,OOH,OOH,OOH,OOH,OOH
10H,00H,00H,00H,00H,00H,10H,00H
90H,90H,90H,OOH,00H,00H,00H,00H
OOH,OOH,OOH,OOH,OOH,OOH,OOH,OOH
10H,00H,00H,20H,00H,00H,10H,20H
OOH,OOH,OOH,OOH,OOH,OOH,OOH,OOH
90H,90H,90H,20H,00H,00H,00H,20H
90H,90H,90H,OAOH,OAOH,OAOH,OH,OH

i

,.-------------~----------------~---------------------- ----i

SET UP DISK CONFIGURATON
[ THIS CODE EXECUTED ONLY ONCE ]

.,i---------------------------------------------------------0700 217EOO
0703 3AB600
0706 E60S
0708 C3DE07
07DB 77
07DC 23
07DD 77
07DE 118000
07E1 DB2S
07E3 E607
07ES 17
07E6 17
07E7 17
07E8 0600
07EA 4F
07EB 219007
07EE 09
07EF 0608
07F1 7E
07F2 12
07F3 13

SDCONF: LXI
LOA
ANI
JMP
MOV
INX
MOV
SDDBL:
LXI
IF
IN
ANI
RAL
RAL
RAL
MVI
MOV
LXI
DAD
MVI
SOLI:
MOV
STAX
SDOK:
INX

H,SELO+2
MPARMS
OSH
SDDBL
M,A
H
M,A

iPOINT TO DRIVE C:

D,SELO+4
HARDSK
02SH
07H

iPOINT TO DRIVE E:

B,O
C,A
H,DSCNO
B
B,8
A,M
0
0

i
i

TEST FOR FOUR FLOPPIES
YES SKIP THE ZAP

i

ZAP C: AND

0:

iREAD CONFIGURATION PORT
iSTRIP OFF HIGH PART

.,
iPOINT TO CONFIGURATION TAB
i
i

INDEX TO RIGHT ENTRY
CHANGE ALL SELECT MASKS
NEXT

All Information Presented Here is Proprietary to Digital Research
133

MP/M II System Guide
07F4 23
07F5+10FA

SDL2:

INX
DJNZ
DB
ENDIF
IF
XCHG
MVI
XRA
MOV
INX
DJNZ
ENDIF

Appendix E
H
SOLI
OIOH,SDLl-$-l

B,8
A
M,A
H
SDL2

RET

07F8 =

INITEND EQU

$

07F8 E5
07F9 79
07FA B7
07FB OEOO

XETMOD: PUSH
MOV
ORA
MVI
JRZ
DB
MVI
XETSEL: CALL
POP
MOV
MVI
MOV
DAD
DAD
PUSH
DAD
POP
DAD
LXI
DAD
XCHG
LHLD
XCHG
LXI
LDIR
DB
RET

H
A,C
A
C,OOOH
XETSEL
628H,XETSEL-$-1
C,OOIH
SETDEN
H
L,M
H,OOOH
A,L
H
H
H
H
0
0
D,MODLO
0

081B+EDBO
081D C9

DRIVE
i----

FAKE DJNZ INSTRUCTION

NOT HARDSK

07F7 C9

07FD+2802
07FF OEOI
0801 CD7802
0804 El
0805 6E
0806 2600
0808 70
0809 29
080A 29
080B E5
080C 29
0800 01
080E 19
080F 119101
0812 19
0813 EB
0814 2AB200
0817 EB
0818 010COO

MP/M Banked XIOS

DPEPTR
B,12
OEDH,OBOH

i

.i ZAP ALL HARD DRIVES

,
i
i

iSAVE MODE BYTE ADDRESS
iSETUP FOR DENSITY CHANGE

i

iASSUME SINGLE DENSITY MODE
iVERIFY ASSUMPTION
f~- FAKE JRZ- INSTRUCTION
iSET FOR DOUBLE DENSITY MOD
iSET DENSITY BASED ON LOW B
iRESTORE
iPICKUP MODE AGAIN
iFOR SINGLE BYTE PRECISION
iSAVE MODE IN ACCUMULATOR F

i* 2
i* 4

* 4
iREGAIN * 4

iSAVE

i* 8

i* 12
iFIRST MODEL OPE
iPOINT TO THIS ONE
iSETUP TEMPORARILY AS DESTI
:ADDRESS OF CURRENTLY SELEC
iSETUP TO ALTER
i LENGTH FOR MOVE
iDO MOVE
:---- FAKE LDIR INSTRUCTION
iRETURN TO CALLER

PAGE
i----------------------------------~------------------ -----

THE FOLLOWING AREA CONTAINS THE DISK/WORK SAVE AREA
USED BY THE CBIOS IN THE NORMAL COURSE OF ACTIVITY.

i----------------------------------------------------- ----All Information Presented Here is Proprietary to Digital Research
134

Appendix E

MP/M II System Guide
if
; tempbuf

MP/M Banked XIOS

mpm20
equ

(dirbuf-base)+128
else
TEMPBUF EQU
(DIRBUF-BASE) +256
ORG TEMPBUF+«INITEND-BASE)/TEMPBUF)*«INITEND-BASE
endif
08lE =
08lE
083E
085E
087E
089E
08BE
08DE
08FE
09lE
095E
095E
099E
099E
09DE
09DE
OAIE
OAIE
OA5E
OA5E
OA9E
OA9E
OAC2
OAC2
OAE6

BEGDAT EQU
;DIRBUF:
DS
ALVO:
DS
CSVO:
ALVl:
DS
CSVl:
DS
ALV2:
DS
DS
CSV2:
ALV3:
DS
CSV3:
DS
IF
DS
ALV4:
CSV4:
DS
ALV5:
DS
CSV5:
DS
DS
ALV6:
DS
CSV6:
DS
ALV7:
CSV7:
DS
DS
ALV8:
CSV8:
DS
ALV9:
DS
CSV9:
DS
ALVA:
DS
CSVA:
DS
ALVB:
DS
CSVB:
DS
endif

$
DS
32
32
32
32
32
32
32
32
HARDSK
64
0
64
0
64
0
64
0
64
0
64
0
36
0
36
0

if
DS
OS
endif

mdisk
32
0

ALVC:
CSVC:

OAE6
OAE7
OAE9

128

;START OF BDOS AREA
;OVERLAYS SYSTEMINIT CODE

;VIRTUAL DISK

if
if
DS
HSTBUF: DS
DS
ENDIF

not mpm20
hardsk
1
1024
1

; MUST PRECEDE HSTBU
;HOST BUFFER AREA
; MUST FOLLOW HSTBUF

FPYBUF

DIRBUF+128

;

1
2
1

; SEEK DISK NUMBER
; SEEK TRACK NUMBER
; SEEK SECTOR NUMBER

EQU
endif

NEWDSK: DS
NEWTRK: DS
NEWSEC: DS

FLOPPY I/O BUFFER

All Information Presented Here is Proprietary to Digital Research
135

MP/M II System Guide

Appendix E

MP/M Banked XIOS

OAEA
OAEB
OAED

HSTDSK: DS
HSTTRK: DS
HSTSEC: DS

1
2
1

:HOST DISK NUMBER
:HOST TRACK NUMBER
:HOST SECTOR NUMBER

OAEE
OAEF
OAFO

NEWHST: DS
HSTACT: DS
HSTWRT: DS

1
1
1

:SEEK SHR SECSHF
:HOST ACTIVE FLAG
:HOST WRITTEN FLAG

OAFI
OAF2
OAF3
OAFS

UNACNT:
UNADSK:
UNATRK:
UNASEC:

DS
DS
DS
DS

1

:UNALLOCATED RECORD
:LAST UNALLOCATED D
:LAST UNALLOCATED T
:LAST UNALLOCATED S

OAF6
OAF7
OAFS
OAF9

ERFLAG:
RSFLAG:
READOP:
WRTYPE:

DS
DS
DS
DS

OAFA 00
OAFB 00
OAFC 00

CMD:
DB
MASK:
DB
STATUS: DB

OAFD 00000000
OBOI 00
OB02 00

SAVEl: DB
P$RETRIES: DB
T$RETRIES: DB
HOME$TOGGLE:
DB

OB03 00

.,

1

2
1

1
1

:ERROR REPORTING
:READ SECTOR FLAG
:1 IF READ OPERATIO
:WRITE OPERATION TY

o

o
o

:COMMANDS FOR NEXT
:STATUS MASKS BUFFE
:STATUS SAVE LOCATI

OOOH,OOOH,OOOH,OOOH
OOOH
OOOH

:SAVE AREA FOR NMI
:COUNTER FOR PERMAN
:COUNTER FOR TEMPOR

OOOH

iINDICATOR TO TELL
: •• IF HOME SHOULD

1
1

page
if

mpm20

: *********************************************************

,. *

M P / M 2. 0

*

COMMON

BAS E

*

*********************************************************

OB04 C31S0B
OB07 C30000
OBOA C30000
OBOD C30000 .
OBI0 C30000
OB13 0000
OBIS OEOO
OB17 C3100B

commonbase:
jmp
swtuse.r: jmp
swtsys:
jmp
pdisp:
jmp
xdos:
jmp
sysdat: dw
COLDSTART: '
WARMSTART:
MVI

C,O

JMP

XDOS

coldstart
$-$
$-$
$-$
$-$
$-$
SEE SYSTEM INIT
COLD & WARM START INCLUDE
: FOR COMPATIBILITY WITH CP
: SYSTEM RESET, TERMINATE P

All Information Presented Here is Proprietary. to Digital Research
136

Appendix E

MP/M II System Guide

OBIA AF
OBIB C9
OBIC FB
OBID+ED4D

rtnempty:
xra
ret
NULL$INT:
EI
RETI
DB
endif

MP/M Banked XIOS

a

OEDH,04DH

i----

FAKE RETI INSTRUCTION

,._--------------------------------------------------------CENTRONICS PRINTER ROUTINE (WITH SEPARATE BUSY TEST

,----------------------------------------------------------CNSTAT:
OBIF 3EOI
OB21 D310
OB23 DBIO
OB25 E620
OB27 3EFF
OB29 C8
OB2A AF
OB2B C9

.

MVI
OUT
IN
ANI
MVI
RZ
XRA
RET

,

A,OOlH
OIOH
OIOH
020H
A,OFFH
A
1': I ,I',

iTO SET STROBE HIGH

·iREAD PRINTER STATUS
,

iREMOVE ALL BUT BUSY BIT
iASSUME NOT BUSY
iCHECK ASSUMPTION
iSET TO SHOW STILL BUSY

·

,
I'~

CLIST:
CALL
CNSTAT
iIS PRINTER READY NOW?
ORA
A
,JRNZ, ,." '··~L.ISTl,
i IF READY, SKIP POLL
DB
020H,CLISTl-$-1 i---- FAKE JRNZ INSTRUCTION

OB2C CDIFOB
OB2F B7
OB30+2009
OB32 C5
OB33 OE83
OB35 lEOO
OB37 CDIOOB
OB3A Cl

PUSH

B

i

MVI

C,POLL
E,PLLPT
XDOS

POLL DEVICE
PRINTER
iWAIT FOR PRINTER TO FREE U

MVI
CALL
POP

i

i

B

CLISTl:
OB3B 79
OB3C D311
OB3E 3EOO
OB40 D310
OB42 3EOI
OB44 D310
OB46 C9

MOV
OUT
MVI
OUT
MVI
OUT
RET

A,C
OllH
A,OOOH
OIOH
A,OOlH
OIOH

iCHARACTER TO PRINT
iWRITE IT TO DATA PORT
iTO FORCE STROBE LOW

·,

iTO FORCE STROBE HIGH

PAGE

i---------------------------------------------------------DISK INTERRUPT ROUTINE

i---------------------------------------------------------All Information Presented Here is Proprietary to Digital Research
137

MP/M II System Guide

-OB47 22C80D
OB4A 2lS00B
OB4D C37FOD
OBSO DB04
OBS2 32FCOA
OBSS 3EOO
OBS7 320100
OBSA lE06
OBSC+18l3
OBSE 22C80D
OB6l 2l670B
OB64 C37FOD
OB67 DB24
OB69 32FCOA

FLOPPY$INT:
SHLD
LXI
JMP
FDINTH:
IN
STA
MVI
STA
MVI
JR
DB
HARD$INT:
SHLD
LXI
JMP
HDINTH:
IN
STA

OB6C AF
OB6D 0323
OB6F lEOS

Appendix E

MP/M Banked XIOS

SVDHL
H,FDINTH
-INTINIT
" i GET STATUS
004H
STATUS
iSAVE FOR I/O ROUTINE
A,O
iSTOP TIMING OF RESPONSE TO
FPYTIME+l
E,FPYFLAG
iSHOW I/O COMPLETED
HDSTFLG
018H,HDSTFLG-$-1
i---- FAKE JR INSTR

SVDHL
H,HDINTH
INTINIT
024H
STATUS

iGET STATUS
iSAVE FOR CHECK LATER

XRA
OUT

A

023H

iRESET INTERRUPT BY RELOADI

MVI

E,HDFLAG

iSHOW I/O COMPLETED

MVI
CALL
JMP

C,FLAGST
XDOS
INTDONE

HDSTFLG:
OB7l OE8S
OB73 CDIOOB
OB76 C3670D

PAGE

i----------------------------------------------------- ----i

;

CONSOLE DISPLAY ROUTINES

i

i---------------------------------------------------------i

CONST:
OB79 CD9AOB
OB7C ADOB
OB7E ECOB
OB80 2BOC
OB82 6AOC

CALL
OW
OW
OW
OW

CONSOLE STATUS
PTBLJMP ; COMPUTE AND JUMP TO HNDLR
PTOST
CONSOLE #0 STATUS ROUTINE
PTIST
CONSOLE #1 STATUS ROUTINE
PT2ST
i CONSOLE #2 STATUS ROUTINE
PT3ST
CONSOLE #3 STATUS ROUTINE

CALL
OW
OW
OW
OW

PTBLJMP
PTOIN
PTIIN
PT2IN
PT3IN

CONIN:
OB84 CD9AOB
OB87 B80B
OB89 F70B
OB8B 360C
OB8D 7S0C
CONOUT:

;

i
;
i
i

CONSOLE INPUT
COMPUTE AND JUMP TO HNDLR
CONSOLE #0 INPUT
CONSOLE #1 INPUT
CONSOLE #2 INPUT
CONSOLE #3 INPUT
CONSOLE OUTPUT

All Information Presented Here is Proprietary to Digital Research
138

Appendix E

MP/M II System Guide
CALL
DW
DW
DW
DW

OB8F CD9AOB
OB92 CAOB
OB94 090C
OB96 480C
OB98 870C

PTBLJMP
PTOOUT
PT10UT
PT20UT
PT30UT

i

MP/M Banked XIOS

COMPUTE AND JUMP TO HNDLR
CONSOLE #0 OUTPUT
CONSOLE #1 OUTPUT
CONSOLE #2 OUTPUT
CONSOLE #3 OUTPUT

i

PTBLJMP:
i

OB9A 7A
OB9B FE04
OB9D+3803
OB9F Fl
OBAO AF
OBAl C9

COMPUTE AND JUMP TO HANDLER
D = CONSOLE #
DO NOT DESTROY <D>

MOV
CPI
JRC
DB
POP

A,D
NMBCNS
TBLJMP
038H,TBLJMP-$-1 i---- FAKE JRC INSTRUCTIO~
PSW
THROW AWAY TABLE ADDRESS

XRA

A

RET
TBLJMP:
ADD
POP
MOV
MVI
DAD
MOV
INX
MOV
XCHG
PCHL

OBA2 87
OBA3 El
OBA4 SF
OBA5 1600
OBA7 19
OBA8 5E
OBA9 23
OBAA 56
OBAB EB
OBAC E9

COMPUTE AND JUMP TO HANDLER
A = TABLE INDEX
DOUBLE TABLE INDEX FOR ADR OFFST
RETURN ADR POINTS TO JUMP TBL

A

H

E,A
D,O
D

E,M

ADD TABLE INDEX * 2 TO TBL BASE
GET HANDLER ADDRESS

H

D,M
JUMP TO COMPUTED CNS HANDLER

PAGE

i---------------------------------------------------------i
i

SERIAL PORT ADDRESS EQUATES

i---------------------------------------------------------OOlC =
OOlD =
002C =
002D =
002E =
002F =
002A =
002B =
OOlE =
OOlF =
0028 =
0029 =

DATAO
EQU
STSO
EQU
DATAl
EQU
STSl
EQU
DATA2
EQU
STS2
EQU
DATA3
EQU
STS3
EQU
LPTPRTO EQU
LPTSTSO EQU
LPTPRTl EQU
LPTSTSl EQU

OlCH
DATAO+l
02CH
DATA1+l
02EH
DATA2+1
02AH
DATA3+1
OlEH
LPTPRTO+l
028H
LPTPRT1+l

iCONSOLE #0 DATA
iCONSOLE #0 STATUS
iCONSOLE #1 DATA
iCONSOLE #1 STATUS
iCONSOLE #2 DATA
iCONSOLE #2 STATUS
iCONSOLE #3 DATA
iCONSOLE #3 STATUS
iPRINTER #0 DATA
iPRINTER #0 STATUS
iPRINTER #1 DATA
iPRINTER #1 STATUS

PAGE

All Information Presented Here is Proprietary to Digital Research
139

AppendixE

MP/M II System Guide

MP/M Banked XIOS

;--------------------------------------------~-------- -----

;

;

POLL CONSOLE

# 0

INPUT

i---------------------------------------------------------POLCIO:
PTOST:

TEST CONSOLE STATUS
RETURN. OFFH IF READY
OOOH IF NOT
;
;

XRA
OUT
IN
ANI
RZ
MVI
RET

OBAD AF
OBAE D3lD
OBBO DBID
OBB2 E60l
OBB4 CS
OBBS 3EFF
OBB7 C9

A
STSO
STSO
1

·, RXNOCHAR ?

A,OFFH

;

YES

SET FLAG

i---------------------------------------------------------;

;

CONSOLE

# 0

INPUT

;---------------------------------------------------------;
PTOIN:
OBBS CDADOB
OBBB B7
OBBC+2007
OBBE OES3
OBCO lEOS
OBC2 CDIOOB
OBCS DBIC
OBC7 E67F
OBC9 C9

RETURN CHAR IN REG A
;IS IT READY NOW?

;

CALL
ORA
JRNZ
DB
MVI
MVI
CALL
PTOINl: IN
ANI
RET

POLCIO
A
PTOINI
020H,PTOINl-$-1
C,POLL
E,PLCIO
XDOS
DATA 0
7FH

·,;IF READY, SKIP POLL

;---- FAKE JRNZ INSTRUCTION
;
;
;
;

POLL CONSOLE #0 INPUT
READ CHARACTER
STRIP PARITY

.;
.,i---------------------------------------------------------,
;

CONSOLE

# 0

OUTPUT

;

i---------------------------------------------------------;

PTOOUT:
OBCA CDDDOB
OBCD B7

CALL
ORA
JRNZ
DB
PUSH
MVI
MVI
CALL
POP

'OBCE+2009
OBDO CS
OBDI OES3
OBD3 lEOl
OBDS CDIOOB
OBDS Cl

POLCOO

; REG C = CHAR TO OUTPUT
;IS IT READY NOW?

A

; ,

PTOOUTI
;IF READY, SKIP POLL
020H,PTOOUTl-$-1
;---- FAKE JRNZ INS
B

C,POLL
E,PLCOO
XDOS

MOV
OUT

·

POLL CONSOLE #0 OUTPUT

B

,

A,C
DATAO

; TRANSMIT CHARACTER

PTOOUTl:
OBD9 79
OBDA D3lC

,.,
·,

;

All Information Presented Here is Proprietary to Digital Research
140

Appendix E

MP/M II System Guide

MP/M Banked XIOS

RET

OBDC C9
i

i----------------------------------------------------------

i

.

,

POLL CONSOLE

# 0

OUTPUT

i---------------------------------------------------------i

POLCOO:
MVI
OUT
IN
ANI
CPI
MVI
RNZ
DCR
RET

OBDD 3EIO
OBDF D31D
OBEI DBID
OBE3 E60C
OBE5 FEOC
OBE? 3EOO
OBE9 CO
OBEA 3D
OBEB C9

RETURN OFFH IF READY
OOOH IF NOT
RESET INT BIT
READ STATUS
, MASK FOR DTR AND TXE
i MUST HAVE BOTH

A,lOH
STSO
STSO
OCH
OCH
A,O

.

A

i RETURN NOT READY
iCHANGE "A" TO OFFH
i RETURN READY

PAGE

i---------------------------------------------------------i

POLL CONSOLE

# 1

INPUT

i----------------------------------------------------------

.

POLCIl:
PTlST:
OBEC AF
OBED D32D
OBEF DB2D
OBFl E601
OBF3 C8
OBF4 3EFF
OBF6 C9

, TEST CONSOLE STATUS
XRA
OUT
IN
ANI
RZ
MVI
RET

A
STSI
STSI

RETURN

1

i

A,OFFH

;

OFFH IF READY
OOOH IF NOT

RX CHAR ?
NO
YES
SET FLAG

.i----------------------------------------------------------

,

CONSOLE

# 1

INPUT

;

i---------------------------------------------------------;

PTIIN:
OBF? CDECOB
OBFA B?
OBFB+200?
OBFD OE83
OBFF lE06
OCOI CDIOOB
OC04 DB2C
OC06 E6?F

CALL
ORA
JRNZ
DB
MVI
MVI
CALL
PTIINl: IN
ANI

POLCII
A
PTIINI
020H,PTIINl-$-l
C,POLL
E,PLCII
XDOS
DATAl
?FH

; RETURN CHAR IN REG A
;READY NOW?
;

;IF READY, SKIP POLL
;---- FAKE JRNZ INSTRUCTION
i

;

POLL CONSOLE #1 INPUT
READ ·CHARACTER
STRIP PARITY

All Information Presented Here is Proprietary to Digital Research
141

MP/M II System Guide
OC08 C9

·
,

Appendix E

MP/M Banked XIOS

RET

j---------------------------------------------------------;

# I

CONSOLE

OUTPUT

;
i-------------------------------------------~-~------- -----

;

POLCOI

REG C = CHAR TO OUTPUT
iARE WE READY NOW?

A

i

B

,

C,POLL
E,PLC01
XDOS

; POLL CONSOLE #1 OUTPUT

PTIOUT:

i

CALL
ORA
JRNZ
DB
PUSH
MVI
MVI
CALL
POP

OC09 CDICOC
OCOC B7
OCOD+2009
DCOF C5
OCIO OE83
OCl2 IE02
OCl4 CDIOOB
OCl7 Cl

PTlOUTl
iIF READY, SKIP POLL
020H,PTIOUTI-$-1
;---- FAKE JRNZ INS

.

B

PTIOUTI:
OCl8 79
OCl9 D32C
OCIB C9

·

,

MOV
OUT
RET

A,C
DATAl

TRANSMIT CHARACTER

i---------------------------------------------------------POLL CONSOLE

# I

OUTPUT

i----------------------------------------------------------

·
,

POLC01 :
OCIC 3EIO
OCIE D32D
OC20 DB2D
OC22 E60C
OC24 FEOC
OC26 3EOO
OC28 CO
OC29 3D
OC2A C9

MVI
OUT
IN
ANI
CPI
MVI
RNZ
DCR
RET

RETURN OFFH IF READY
OOOH IF NOT
RESET INT BIT
READ STATUS
MASK FOR DTR AND TXE
MUST HAVE BOTH

.,

A,lOH
STSI
STSI
OCH
OCH
A,O

~;

,

.~.\.

,

; RETURN NOT READY
iCHANGE "A" TO OFFH
; RETURN READY

A

PAGE

i---------------------------------------------------------POLL CONSOLE

# 2

INPUT

·i----------------------------------------------------------

,

POLCI2:
PT2ST:
OC2B AF

XRA

;

A

TEST CONSOLE STATUS
RETURN OFFH IF READY

All Information Presented Here is Proprietary to Digital Research
142

Appendix E

MP/M II System Guide
OUT
IN
ANI
RZ
MVI
RET

OC2C D32F
OC2E DB2F
OC30 E60l
OC32 C8
OC33 3EFF
OC3S C9

MP/M Banked XIOS
OOOH IF NOT

STS2
STS2
1

RX CHAR ?
NO
SET FLAG
YES

A,OFFH
;

;

i----------------------------------------------------------

·
·,
,

CONSOLE

# 2

INPUT

;-------------------------~--------------------------- -----

;

PT2IN:
OC36 CD2BOC
OC39 B7
OC3A+2007
OC3C OE83
OC3E lE07
OC40 CDIOOB
OC43 DB2E
OC4S E67F
OC47 C9

CALL
ORA
JRNZ
DB
MVI
MVI
CALL
PT2INl: IN
ANI
RET

POLCI2
A
PT2INI
020H,PT2INl-$-1
C,POLL
E,PLCI2
XDOS
DATA 2
7FH

; RETURN CHAR IN REG A
;READY NOW?

·,;IF READY, SKIP POLL

;---- FAKE JRNZ INSTRUCTION
POLL CONSOLE #2 INPUT
;

READ CHARACTER
STRIP PARITY

,·
;

i---------------------------------------------------------CONSOLE

# 2

OUTPUT

i----------------------------------------------------------

·
,

PT20UT:
CALL
ORA
JRNZ
DB
PUSH
MVI
MVI
CALL
POP

OC48 CDSBOC
OC4B B7
OC4C+2009
OC4E CS
OC4F OE83
OCSI lE03
OCS3 CDIOOB
OCS6 Cl

POLC02

; REG C = CHAR TO OUTPUT
;READY NOW?

A

;

PT20UTI
;IF READY, SKIP POLL
020H,PT20UTl-$-1
;---- FAKE JRNZ INS
B

C,POLL
E,PLC02
XDOS

MOV
OUT
RET

; POLL CONSOLE #2 OUTPUT

B

PT20UTl:
OCS7 79
OCS8 D32E
OCSA C9

·,
·, TRANSMIT CHARACTER

A,C
DATA2

i---------------------------------------------------------;

POLL CONSOLE

# 2

OUTPUT

j----------------------------------------------------------

·
,

; RETURN OFFH IF READY

POLC02 :

All Information Presented Here is Proprietary to Digital Research
143

MP/M II System Guide
OC5B 3EIO
OC5D D32F
OC5F DB2F
OC61 E60C
OC63 FEOC
OC65 3EOO
OC67 CO
OC68 3D
OC69 C9

MVI
OUT
IN
ANI
CPI
MVI
RNZ
DCR
RET

Appendix E
A,IOH
STS2
STS2,
OCH
OCH
A,O

MP/M Banked XIOS

OOOH IF NOT
RESET
INT
BIT
i
READ STATUS
MASK FOR DTR AND TXE
MUST HAVE BOTH
i RETURN NOT READY
iCHANGE "A" TO OFFH
i RETURN READY

A

PAGE

;---------------------------------------------------------i

POLL CONSOLE

# 3

INPUT

i---------------------------------------------------------POLCI3:
PT3ST:
OC6A AF
OC6B D32B
OC6D DB2B
OC6F E601
OC71 C8
OC72 3EFF
OC74 C9

.

XRA
OUT
IN
ANI
RZ
MVI
RET

TEST CONSOLE STATUS
RETURN OFFH IF READY
OOOH IF NOT

A
STS3
STS3
1
A,OFFH

i

RX CHAR ?
NO
YES
SET FLAG

I

;----~------------------------------------------------ -----

CONSOLE

# 3

INPUT

i----------------------------------------------------- ----i

PT3IN:
OC75 CD6AOC
OC78 B7
OC79+2007
OC7B OE83
OC7D IE08
OC7F CDIOOB
OC82 DB2A
OC84 E67F
OC86 C9

CALL
ORA
JRNZ
DB
MVI
MVI
CALL
PT3INI: IN
ANI
RET

POLCI3
A
PT3INI
020H,PT3INI-$-1
C,POLL
E,PLCI3
XDOS
DATA 3
7FH

; RETURN CHAR IN REG A
iREADY NOW?
i
iIF READY, SKIP POLL
i---- FAKE JRNZ INSTRUCTION
i

POLL CONSOLE #3 INPUT

READ CHARACTER
STRIP PARITY

i---------------------------------------------------------i

CONSOLE

# 3

OUTPUT

i---------------------------------------------------------All Information Presented Here is Proprietary to Digital Research
144

Appendix E

MP/M II System Guide

POLC03

i REG C = CHAR TO OUTPUT
iREADY NOW?

A

i

PT30UT:
CALL
ORA
JRNZ
DB
PUSH
MVI
MVI
CALL
POP

OC87 CD9AOC
OC8A B7
OC8B+2009
OC8D C5
OC8E OE83
OC90 lE04
OC92 CDIOOB
OC95 Cl

MP/M Banked XIOS

PT30UTI
iIF READY, SKIP POLL
020H,PT30UTl-$-1
i---- FAKE JRNZ INS
B

C,POLL
E,PLC03
XDOS

i

POLL CONSOLE #3 OUTPUT

B

PT30UTl:
MOV
OUT
RET

OC96 79
OC97 D32A
OC99 C9

A,C
DATA3

TRANSMIT CHARACTER

;-------------------------~--------------------------- -----

i
i

POLL CONSOLE

# 3

OUTPUT

.,i---------------------------------------------------------POLC03 :
OC9A 3ElO
OC9C D32B
OC9E DB2B
OCAO E60C
OCA2 FEOC
OCA4 3EOO
OCA6 CO
OCA7 3D
OCA8 C9

MVI
OUT
IN
ANI
CPI
MVI
RNZ
OCR
RET

RETURN OFFH IF READY
OOOH IF NOT
i
RESET
INT
BIT
i
READ STATUS
i MASK FOR DTR AND TXE
MUST HAVE BOTH

A,lOH
STS3
STS3
OCH
OCH
A,O

.,

i RETURN NOT READY

iCHANGE "A" TO OFFH

A

i RETURN READY

PAGE

i---------------------------------------------------------LINE PRINTER

#0

DRIVER

.

i----------------------------------------------------- ---~-

,

LIST:
OCA9 CDBCOC
OCAC B7

iLIST OUTPUT #0

OCAD+2009

CALL
ORA
JRNZ
DB

POLLPT
A
LISTI
020H,LISTl-$-1

OCAF C5
OCBO OE83
OCB2 lEOO
OCB4 CDIOOB
OCB7 Cl

PUSH
MVI
MVI
CALL
POP

B
C,POLL
E,PLLPT
XDOS
B

iIS PRINTER READY NOW?

iIF READY, SKIP POLL
i---- FAKEJRNZ INSTRUCTION
i POLL PRINTER STATUS

i

All Information Presented Here is Proprietary to Digital Research
145

Appendix E

MP/M II System Guide

MP/M Banked XIOS

LISTl:
OCB8 79
OCB9 D31E
OCBB C9

MOV
OUT
RET

A,C
LPTPRTO

CHARACTER TO PRINT

;------------------------------~--------~------------- -----

POLL PRINTER OUTPUT

;---------------------------------------------------------i

POLLPT:
MVI
OUT
IN
ANI
CPI
MVI
RNZ
DCR
RET

OCBC 3EIO
OCBE D31F
OCCO DBIF
OCC2 E60C
OCC4 FEOC
OCC6 3EOO
OCC8 CO
OCC9 3D
OCCA C9

IF READY
., RETURN OFFH
OOOH IF NOT

A,lOH
LPTSTSO
LPTSTSO
OCH
OCH
A,O

RESET INT BIT
READ STATUS
i MASK FOR DTR AND TXE
MUST HAVE BOTH
RETURN NOT READY
iCHANGE "A" TO OFFH
i RETURN READY ,

i
A

PAGE
i

., MP/M 1.0

EXTENDED I/O SYSTEM

POLLDEVICE:
REG C = DEVICE # TO BE POLLED
RETURN OFFH IF READY,
OOOH IF NOT
OCCB 79
OCCC FE09

MOV
CPI
JRC
DB
MVI

A,C
NMBDEV
OEVOK
038H,DEVOK-$-1 i - - - - FAKE JRC INSTRUCTION
A,NMBDEVi IF DEV # >= NMBDEV,
SET TO NMBDEV

CALL

TBLJMP

OCDS BCOC

DW

POLLPT

OCD7 DDOB
OCD9 lCOC
OCDB SBOC
OCDD 9AOC
OCDF ADOB
OCEI ECOB
OCE3 2BOC
OCES 6AOC
0009 =

OW
OW
DW
DW
DW
DW
DW
DW
EQU

OCCE+3802
OCOO 3E09
DEVOK:
OCD2 CDA20B

JUMP TO DEV POLL CODE

DEVTBL:

NMBDEV

POLL PRINTER OUTPUT - THIS WILL P
SPECIFIED PARALLEL PORT FOR PRIN
POLCOO
POLL CONSOLE #0 OUTPUT
POLCOI
POLL CONSOLE #1 OUTPUT
POLC02
POLL CONSOLE #2 OUTPUT
POLC03
POLL CONSOLE #3 OUTPUT
POLCIO
POLL CONSOLE #0 INPUT
POLCII
POLL CONSOLE #1 INPUT
POLCI2
POLL CONSOLE #2 INPUT
POLCI3 i POLL CONSOLE #3 INPUT
($-DEVTBL)/2
i

All Information Presented Here is Proprietary to Digital Research
146

Appendix E

MP/M II System Guide

ow

OCE7 1AOB

MP/M Banked XIOS

RTNEMPTY; BAD DEVICE HANDLER

PAGE
SELECT / PROTECT MEMORY
SELMEMORY:
REG BC = ADR OF MEM DESCRIPTOR
BC -> BASE
1 BYTE,
SIZE
1 BYTE,
ATTRIB 1 BYTE,
;
BANK
1 BYTE.
BIOS TABLE MODIFIED
OCE9 FE20
OCEB CAEBOC
OCEE 210300
OCF1 09
OCF2 7E
OCF3 320300
OCF6 17
OCF7 17
OCFS 17
OCF9 E61S
OCFB F602
OCFD 320400
0000 0309
0002 C9
0003 00
0004 00

CPI
JZ
LXI
DAD
MOV
STA
RAL
RAL
RAL
ANI
ORI
STA
OUT
RET
BANKNO: DB
CURMEM: DB

20H
$
H,3
B
A,M
BANKNO

;

POINT TO BANK
GET IT
SAVE BANK NUMBER

.

,
01SH
MEMSK
CURMEM
009H
0
0

MASK FOR PIO
STORE CURRENT BANK MASK
SET PIO

;

LAST SELECTED MEMORY BANK NUMBER
LAST SELECTED MEMORY BANK MASK

; START CLOCK
STARTCLOCK:
WILL CAUSE FLAG #1 TO BE SET
AT EACH SYSTEM TIME UNIT TICK
0005 3EFF
0007 32CEOD
ODOA C9

MVI
STA
RET

A,OFFH
TICKN

; STOP CLOCK
STOPCLOCK:
WILL STOP FLAG #1 SETTING AT
SYSTEM TIME UNIT TICK
ODOB AF
ODOC 32CEOD
ODOF C9

XRA
STA
RET
;

A
TICKN

EXIT REGION

All Information Presented Here is Proprietary to Digital Research
147

Appendix E

MP/M II System Guide

MP/M Banked XIOS

EXITREGION:
; EI IF NOT PREEMPTED
0010 .3ACFOO
0013 B7
0014 CO
0015 FB
0016 C9

LOA
ORA
RNZ
EI
RET

PREEMP
A

; MAXIMUM CONSOLE NUMBER
0017 3E04
0019 C9

MAXCONSOLE:
MVI
RET
MP/M 1.0

008E =

OSPTCH

EQU

A,NMBCNS
INTERRUPT HANOLERS
142

INT1HNO:
; INTERRUPT 1 HANDLER ENTRY POINT
T20MS:
001A 22C800
0010 212200
0020+1850
0022 3ACEOO
OD25 B7

SHLO
LXI
JR
DB
TIMERINT:
LOA
ORA

SVDHL
H,TIMERINT
INTINIT
018H,INTINIT-$-1

;---- FAKE JR INSTR

TICKN
TICKN, INDICATES
.; TEST
DELAYED PROCESS(ES)

A

I

JRZ
DB

0026+2807
OD28 OE85
002A 1E01
002C C0100B

MVI

MVI
CALL

NOTICKN
028H,NOTICKN-$-1
;---- FAKE JRZ INST
C,FLAGST
E,l
XOOS
; SET FLAG #1 EACH TICK

NOTICKN:
002F 219DOO
0032 35
0033+2032
0035 3E70
0037 2B
0038 96
0039 77
003A 23
003B 77
OD3C OE85
003E 1E02
0040 C0100B
0043 2AOOOO
0046 7C
0047 B7
0048+2810
004A 20

LXI
OCR
JRNZ
DB
MVI
OCX
SUB
MOV
INX
MOV
MVI
MVI
CALL
LHLO
MOV
ORA
JRZ
DB
DCR

H,CNTX
M
NOT1SEC
020H,NOTlSEC-$-1
A,125
H
M

M,A
H

M,A
C,FLAGST
E,2
XDOS
FPYTIME
A,H

A

DEC TICK CNTR
;---- FAKE JRNZ INS

; *** TOGGLE COUNT 62 <-> 6
*** ACTUAL #/SEC = 62.5
; SET FLAG #2 @ 1 SEC
;IS FLOPPY TIME CHECK IN EF

;

NOT1SEC
;IF NOT IN EFFECT, FINISH
028H,NOTlSEC-$-1
i - - - - FAKE JRZ INST
L
;SUBTRACT A SECOND

All Iriformation Presented Here is Proprietary to Digital Research
148

Appendix E

MP/M II System Guide
SHLD
JRNZ
DB
MOV
SHLD
MVI

OD4B 22DOOD
OD4E+2017
OD50 65
OD51 22DOOD
OD54 OE85
OD56 1E06
OD58 CD100B
OD5B 3E90
OD5D 32FCOA
OD60 2AD20D
OD63 23
OD64 22D20D

MP/M Banked XIOS

STA
LHLD
INX
SHLD

FPYTIME
iSAVE FOR NEXT TIME
NOT1SEC
iIF NOT TOO LONG, FINISH
020H,NOT1SEC-$-1
i---- FAKE JRNZ INS
H,L
iZERO OUT INDICATOR
FPYTIME
iPREVENT RE-ENTRY OF THIS R
C,FLAGST
E,FPYFLAG
i
XDOS
iCAUSE I/O FOR FLOPPY TO CO
A,10010000B
STATUS
iSHOW ERROR IN FLOPPY I/O
FPYTCNT
H
iCOUNT TIMES WD1791 GOES TO
FPYTCNT

XRA

A

MVI

CALL
MVI

NOTISEC:
INTDONE:
0067 AF
OD68 32CFOD
OD6B CI
OD6C 01
OD6D 2ACAOD
0070 F9
0071 F1
OD72 2ACCOD
0075 E5
OD76 210DOB
OD79 E5
OD7A 2AC80D

STA
POP
POP
LHLD
SPHL
POP
LHLD
PUSH
LXI
PUSH
LHLD

PREEMP

i

CLEAR PREEMPTED FLAG

B
D

SVDSP
i

RESTORE STK PTR

PSW
SVDRET
H

H,PDISP
H
SVDHL

MP/M DISPATCH
PUT ON STACK FOR RETURN

THE FOLLOWING DISPATCH CALL WILL FORCE ROUND ROBIN
SCHEDULING OF PROCESSES EXECUTING AT THE SAME PRIORITY
EACH 1/32ND OF A SECOND.
NOTE: INTERRUPTS ARE NOT ENABLED UNTIL THE DISPATCHER
; RESUMES THE NEXT PROCESS. THIS PREVENTS INTERRUPT
OVER-RUN OF THE STACKS WHEN STUCK OR HIGH FREQUENCY
INTERRUPTS ARE ENCOUNTERED.
RETI
DB

OEDH,04DH

OD7F 22C60D
0082 EI
OD83 22CCOD
OD86 F5
0087 210000
OD8A 39
OD8B 22CAOD
OD8E 3lC60D
0091 05
0092 C5

SHLD
POP
SHLD
PUSH
LXI
DAD
SHLD
LXI
PUSH
PUSH

iSAVE MACHINE STATE FOR INTRPT HNDL
ADRINTHD
H
SVDRET
PSW
H,O
SP
SVDSP
; SAVE USERS STK PTR
SP,LSTINTSTK
LCL STK FOR INTR HNDL
0
B

0093 3EFF
0095 32CFOD

MVI
STA

A,OFFH
PREEMP

OD7D+ED4D
INTINIT:

i DISPATCH
i----

FAKE RETI INSTRUCTION

i SET PREEMPTED FLAG

All Information Presented Here is Proprietary to Digital Research
149

Appendix E

MP/M II System Guide
LHLD
PCHL

OD98 2AC60D
OD9B E9

MP/M Banked XIOS

ADRINTHD
:JUMP TO INTERRUPT HANDLER

: BIOS DATA SEGMENT
;

TOGCNT: DB
CNTX:
DB
INTSTK:
DW
OD9E C7C7C7C7C7
ODA8 C7C7C7C7C7
DW
DW
ODB2 C7C7C7C7C7
OOBC C7C7C7C7C7
DW
LSTINTSTK:
ODC6 0000
ADRINTHD: DW
ODC8 0000
SVDHL: DW
SVDSP: DW
ODCA 0000
SVDRET: DW
ODCC 0000
ODCE 00
TICKN: DB
ODCF 00
PREEMP: DB
OD9C 3E
OD9D 3E

: TOGGLE COUNTER 62 <-> 63
; TICK CNTR TO 1 SEC
: LOCAL INTRPT STK
OC7C7H,OC7C7H,OC7C7H,OC7C7H,OC7C7H
OC7C7H,OC7C7H,OC7C7H,OC7C7H,OC7C7H
OC7C7H,OC7C7H,OC7C7H,OC7C7H,OC7C7H
OC7C7H,OC7C7H,OC7C7H,OC7C7H,OC7C7H

62
62

INTERRUPT HANDLER ADDRESS
SAVED REGS HL DURING INT HNDL
SAVED SP DURING INT HNDL
SAVED RETURN DURING INT HNDL
TICKING BOOLEAN,TRUE = DELAYED
PREEMPTED BOOLEAN

0
0
0
0
0
0

if

mpm20

DW

0

DW
endif

0

FPYTIME:
ODDO 0000
FPYTCNT:
ODD2 0000

PAGE

j----------------------------------------------------- ----i

.
.
I

THESE ARE THE DISK TYPE DEFINITION BLOCKS
EACH OF WHICH CORRESPONDS TO A PARTICULAR MODE •

I

i---------------------------------------------------------ODD4 =
ODD4 1AOO
ODD6 03
ODD7 07
ODD8 00
ODD9 F200
ODDB 3FOO
ODDD CO
ODDE 00
ODDF 1000
ODE1 0200

DPBO:

EQU
OW
DB
DB
DB
DW
OW
DB
DB
DW
DW

$
26
3
7
0
242
63
192
0
16
2

; VERSION 2.0, IBM SINGLE DE
;SECTORS PER TRACK
iBLOCK SHIFT
iBLOCK SHIFT MASK
:EXTENT MASK
;DISK SIZE MINUS 1
iDIRECTORY MAX
iALLOCO
iALLOC1
:CHECK AREA SIZE
iOFFSET TO START TRACK

ODE3 =
ODE3 3400
ODES 04

DPB1:

EQU
DW
DB

$
52
4

: VERSION 2.0, IBM DOUBLE DE
;SECTORS PER TRACK
iBLOCK SHIFT

All Information Presented Here is Proprietary to Digital Research
150

Appendix E

MP/M II System Guide
DB
DB
DW
DW
DB
DB
DW
DW

ODE6 OF
ODE7 01
ODE8 F200
ODEA 7FOO
ODEC CO
ODED 00
ODEE 2000
ODFO 0200
ODF2 =
ODF2 3000
ODF4 04
ODF5 OF
ODF6 00
ODF7 EOOO
ODF9 5FOO
ODFB CO
ODFC 00
ODFD 1800
ODFF 0200

DPB2:

EQU
DW
DB
DB
DB
DW
DW
DB
DB
DW
DW
IF

OEOl+=
OEOl+8000
OE03+07
OE04+7F
OE05+07
OE06+FFOI
OE08+FFOI
OEOA+80
OEOB+OO
OEOC+0080
OEOE+OI00
0000+=
OEI0+=
OEI0+8000
OE12+07
OE13+7F
OE14+07
OE15+FFOI
OE17+FFOI
OE19+80
OEIA+OO
OE1B+0080
OE1D+OI02
0000+=
OEIF+=
OE1F+8000

DPB3:
DPB3

XLT3
DPB4:
DPB4

XLT4
DPB5:
DPB5

15
1

242
127
192

o

32
2
$
48
4
15

o

224
95
192

o

24
2

MP/M Banked XIOS

iBLOCK SHIFT MASK
iEXTENT MASK
iDISK SIZE MINUS 1
iDIRECTORY MAX
iALLOCO
iALLOCl
iCHECK AREA SIZE
iOFFSET TO START TRACK
iVERSION 1.4 ALTOS DOUBLE D
iSECTORS PER TRACK
iBLOCK SHIFT
iBLOCK SHIFT MASK
iEXTENT MASK (1.4 COMPATABI
iDISK SIZE MINUS 1
iDIRECTORY MAX
iALLOCO
iALLOCl
iCHECK AREA SIZE
iOFFSET TO START TRACK

HARDSK

if
mpm20
DISKDEF 3,0,127,,16384,512,512,0,1,,0
EQU
$
iDISK PARM BLOCK
DW
128
iSEC PER TRACK
DB
7
iBLOCK SHIFT
127
iBLOCK MASK
DB
DB
7
iEXTNT MASK
DW
511
iDISK SIZE-1
DW
511
iDIRECTORY MAX
128
iALLOCO
DB
DB
o
iALLOCl
8000H+CKSZ
DW
i PERMANENT DISK WIT
DW
1
iOFFSET
EQU
o
iNO XLATE TABLE
DISKDEF 4,0,127,,16384,512,512,0,513,,0
EQU
$
iDISK PARM BLOCK
128
iSEC PER TRACK
DW
DB
7
iBLOCK SHIFT
127
iBLOCK MASK
DB
DB
7
iEXTNT MASK
DW
511
iDISK SIZE-1
DW
511
iDIRECTORY MAX
DB
128
iALLOCO
DB
o
iALLOCl
8000H+CKSZ
iPERMANENT DISK WIT
DW
OW
513
iOFFSET
EQU
o
iNO XLATE TABLE
DISKDEF 5,0,127,,16384,512,512,0,1025,,0
EQU
$
iDISK PARM BLOCK
DW
128
;SEC PER TRACK

All Information Presented Here is Proprietary to Digital Research
151

MP/M II System Guide
OE21+07
OE22+7F
OE23+07
OE24+FFOI
OE26+FFOI
OE28+80
OE29+00
OE2A+0080
OE2C+OI04
0000+=
OE2E+=
OE2E+8000
OE30+07
OE31+7F
OE32+07
OE33+1FOI
OE35+FFOI
OE37+80
OE38+00
OE39+0080
OE3B+OI02
0000+=

XLT5

DB
DB
DB
DW
DW
DB
DB
DW
DW
EQU

Appendix E
7
127
7
511
511
128
0
8000H+CKSZ
1025
0

MP/M Banked XIOS

iBLOCK SHIFT
iBLOCK MASK
iEXTNT MASK
iDISK SIZE-l
iDIRECTORY MAX
iALLOCO
iALLOCl
iPERMANENT DISK WIT
iOFFSET
iNO XLATE TABLE

DPB3:

DISKDEF 6,0,127,,16384,288,512,0,513,,0
EQU
iDISK PARM BLOCK
$
DW
128
iSEC PER TRACK
DB
:BLOCK SHIFT
7
DB
127
iBLOCK MASK
DB
:EXTNT MASK
7
DW
287
iDISK SIZE-l
DW
511
:.DIRECTORY MAX
DB
128
:ALLOCO
DB
0
:ALLOCI
DW
8000H+CKSZ
: PERMANENT DISK WIT
DW
513
iOFFSET
EQU
:NO XLATE TABLE
else
DISKDEF 3,0,127,,16384,512,512,0,1

DPB4:

DISKDEF 4, 0,127 , ".1,6384,512,512, 0,513

DPB5:

DISKDEF 5,0,127,,16384,512,512,0,1025

DPB6:

DISKDEF 6,0,127,,16384,288,512,0,513
endif

DPB6:
DPB6

XLT6

°

ENDIF
DPB7:

if
EQU
DW
DB
DB
DB
DW
DW
DB
DB
DW
DW
endif

mdisk
$
24
3
7
0
142
63
OCOH

°°
°

:VIRTUAL DISK
:SECTORS PER TRACK
:BLOCK SHIFT
iBLOCK SHIFT MASK
iEXTENT MASK
iDISK SIZE MINUS 1
iDIRECTORY MAX
iALLOCO
iALLOCl
;CHECK AREA SIZE
:OFFSET TO START TRACK

page
MOVE SUBROUTINE
;

All Information Presented Here is Proprietary to Digital Research
152

Appendix E

MP/M II System Guide

RWMOVE:
OE3D D5
OE3E E5
OE3F CD070B
OE42 El
OE43 Dl
OE44 018000
OE47+EDBO
OE49' CDOAOB

·,
·,
i

OE4C 3AF90A
OE4F E60l
OE51+280D

·,
i

OE53 3AF60A
OE56 B7
OE57+2007
OE59 AF
OE5A 32FOOA
OE5D CD6D04

if

hardsk

push
push
call
pop
pop
lxi
LDIR
DB
call

d
h

swtuser

OE6A C9

iswitch in user bank

h
d

b,128
OEDH,OBOH
swtsys

iMOVE DATA TO/FROM BUFFER
i---- FAKE LDIR INSTRUCTION
iswitch system back in

DATA HAS BEEN MOVED TO/FROM HOST BUFFER
LDA

WRTYPE

iWRITE TYPE ??

if
ani
JRZ
DB
else
CPI
JRNZ
endif

mpm20
WRDIR
RWEND
028H,RWEND-$-1

iTO DIRECTORY??
iNO, JUST END UP HERE
i---- FAKE JRZ INSTRUCTION

WRDIR
RWEND

iTO DIRECTORY??
iNO, JUST END UP HERE

CLEAR HOST BUFFER FOR DIRECTORY WRITE
LDA
ORA
JRNZ
DB
XRA
STA
CALL

ERFLAG
A
RWEND
020H,RWEND-$-1
A
HSTWRT
WRITEHST

iCHECK PRIOR TO DIR ACTIVIT
iERRORS ??
;SKIP IF SO ••••
i---- FAKE JRNZ INSTRUCTION
iZERO TO ACCUMULATOR
iBUFFER WRITTEN

LDA
ORA
RZ
LXI
MVI
ENDIF
RET

ERFLAG
A

·,iIF ERRORS, RESET SO NO MAT

H,HSTDSK
M,OFFH

·iCANT POSSIBLY MATCH, MUST

LHLD
push
call
pop
LXI
LXI

DMAADR
; MOVE DATA TO FLOPPY BUFFE
h
swtuser iswitch in user bank,
cannot access non-common BNKXIO
h
;
,
D,FPYBUF
, 128 BYTES
B,128

RWEND:
OE60 3AF60A
OE63 B7
OE64 C8
OE65 21EAOA
OE68 36FF

MP/M Banked XIOS

iNONE, JUST RETURN

,

·,

MVDTB:
OE6B 2AAFOO
OE6E E5
OE6F CD070B
OE72 El
OE73 111D13
OE76 018000

··

All Information Presented Here is Proprietary to Digital Research
153

MP/M II System Guide
LDIR
DB
jmp
RET

OE79+EDBO
OE7B C30AOB
OE7E F5
OE7F 3AFAOA
OE82 E620

MVDFB:

OE84+2013
OE86 2AAFOO
OE89 E5
OE8A CD070B
OE8D D1
OE8E 211D13
OE91 018000
OE94+EDBO
OE96 CDOAOB
OE99 F1
OE9A C9

MVDFX:

PUSH
LDA
ANI
JRNZ
DB
LHLD
push
call
pop
LXI
LXI
LDIR
DB
call
POP
RET
IF

DS
HSTBUF: DS
DS
ENDIF

OE9B
OE9C
129C

Appendix E

MP/M Banked XIOS

;

OEDH,OBOH
swtsys

;---- FAKE LDIR INSTRUCTION
;switch system back in

PSW
CMD
20H
MVDFX
020H,MVDFX-$-1
DMAADR

.; MOVE DATA FROM FLOPPY BUF

,

; CHECK FOR READ
; NO - BYPAS MOVE
;---- FAKE JRNZ INSTRUCTION

.

,

h

swtuser ;switch in user bank,
d
;
cannot access non-common B~KXIO
H,FPYBUF
;
B,128
; 128 BYTES
;

OEDH,OBOH
swtsys
PSW

;---- FAKE LDIR INSTRUCTION
;switch system back in
;
;

HARDSK
;MUST PRECEDE HSTBU
;HOST BUFFER AREA
;MUST FOLLOW HSTBUF

1

1024
1

PAGE

1---------------------------------------------------------;

.,;

INITIALIZE MP/M: REAL TIME CLOCK & DISKS

i---------------------------------------------------------129D =
131D =

dirbuf
fpybuf

if
equ
equ
endif

mpm20
$
dirbuf+128

SYSTEMINIT:
C = BREAKPOINT RESTART NUMBER
; DE = BREAKPOINT RESTART HANDLER ADDRESS
; HL = DIRECT XIOS INTERCEPT JUMP TABLE ADDRESS
129D 225E13
12AO 69
12A1 2600
12A3 29
12A4 29
12A5 29

SHLD
MOV
MVI
DAD
DAD
DAD

SVDJT
L,C
H,O
H
H
H

;HL

= RESTART JUMP ADDRESS

All Information Presented Here is Proprietary to Digital Research
154

Appendix E

MP/M ·11 System Guide
SHLD

12A6 226013
12A9 2A130B
12AC 2EOF
12AE 46
12AF 23
12BO 23
12B1 23
12B2 23
12B3 7E
12B4 B7
12B5 C2BF12
12B8 05
12B9 C2AF12
12BC C3CE12
12BF 3E1A
12C1 CD4813
12C4 3E12
12C6 CD4813
12C9 3EOA
12CB CD4813

l2CE 3E02
l2DO CD4813
12D3 213717

SVDBPA

if
not mdisk
1h1d
sysdat
mvi
1,15
;hl = .nmbmemsegs
mov
b,m
;b = nmbmemsegs
test$bank$setup$loop:
inx
h
inx
h
inx
h
inx
h
;h1 = .memseg(i).bank
mov
a,m
ora
a
jnz
bank$setup
dcr
b
jnz
test$bank$setup$loop
jmp
after$bank$setup
bank$setup:
MVI
A,OlAH
; SELECT BANK 3
; SET UP VECTORS
CALL
STMVTR
MVI
A,012H
; SELECT BANK 2
CALL
STMVTR
; SET UP VECTORS
MVI
A,OOAH
; SELECT BANK 1
SET UP VECTORS
CALL
STMVTR
after$bank$setup:
else
mvi
a,lah
; bank 3 select for directo
·09h
out
1xi
h,Obffeh
mvi
a,Oe5h
cmp
m
inx
h
jrnz
fill
cmp
m
jrz
dontfill
fill:
mov
m,a
;set directory initialized
dcx
h
mov
m,a
lxi
lxi
lxi
mvi
out
mvi
ldir
dontfill:
endif
MVI
CALL

,,,,,
e· • • • •

12D6 l17COO

MP/M Banked XIOS

1xi
LXI
LXI

b,07ffh
h,O
d,l
a,Oah
09h
m,Oe5h

A,002H
STMVTR

;fitst 2 k of bank one gets
; select bank 1

; SELECT BANK 0
; SET UP VECTORS

h,ldrbiosbase+density$mask$offset
H,1737H
; MOVE PARAMETERS CHANGED B
D,SELO
;
THE SETUP PROGRAM

All Information Presented Here is Proprietary to Digital Research
155

Appendix E

MP/M II System Guide
12D9 010400

LXI
LDIR
DB
LXI
LXI
LDIR
DB
1h1d
LHLD
SHLD
LDA
ANI
JRZ
DB
LXI
SHLD
LXI
SHLD
MVI
OUT
MVI
OUT

013H
A,OOFH
013H

LXI

B,003H

130A CD2F02
130D 218800
1310 09
1311 C5
1312 41
1313 4E
1314 CDF807
1317 C1
1318 OD
1319 F20A13
131C CDD007

CALL
LXI
DAD
PUSH
MOV
MOV
CALL
POP
DCR
JP
CALL

SELSDP
H,MODE
B,C
C,M
XETMOD
MODESET
SDCONF

iEND OF LIST YET 11
iSET MODE FOR ALL DRIVES
iSET DISK CONFIGURATION

131F 018000
1322 CD5502

LXI
CALL

B,80H
SETDMA

iSET DMA ADDRESS

1325 E5

push

h

if
1h1d
mvi

mpm20
sysdat
1,7
a,m

12DC+EDBO
12DE 118800
12E1 010400
12E4+EDBO
12E6 2ABB17

,.....
,,,,

12E9 22B600
12EC 3AB600
12EF E602
12F1+2814
12F3 212COB
12F6 221000
12F9 211FOB
12FC 22D50C
12FF 3E03
1301 D313
1303 3EOF
1305 D313

B,4

MP/M Banked XIOS

OEDH,OBOH
D,MODE
B,4

4 SELECT MASKS

i
i

i---- FAKE LDIR INSTRUCTION

,·

4 MODE BYTES

i

OEDH,OBOH
i---- FAKE LDIR INSTRUCTION
1drbiosbase+misc$params$offset
i GET MISC. PARAMETERS
17BBH
,
MPARMS
MPARMS
i NOW TEST FOR CENTRONICS P

·
,·
2
PRTOK
NO
LEAVE SERIAL
028H,PRTOK-$-1 i---- FAKE JRZ INSTRUCTION
H,CLIST
·, CHANGE PRINTER ROUTINE
WBOTE+13
H,CNSTAT
.AND STATUS CHECK
,·
DEVTBL
A,003H
iINITIALIZE PARALLEL PORT
i

i
i

PRTOK:
1307 010300

iSET THE MODE FOR DRIVES IN

MODESET:

1326 2A130B
1329 2E07
132B 7E

mov
else
1xi

mov

B
B

B
C

iSELECT DRIVE FOR MODESET

·,

iPOINT TO CORRECT MODE BYTE
iSAVE COUNT OF DRIVES
i B = DRIVE #
i

iSET MODE

,·

h,INTERUPT
a,h

endif
132C E1
132D ED47

pop
DB

h

OEDH,047H

i----

FAKE STAI INSTRUCTION

All Information Presented Here is proprietary to Digital Research
156

Appendix E

MP/M II System Guide

MP/M Banked XIOS

i SET VECTOR FOR CTC
; CTC CHANNEL 0
; RESET /
LOAD TIME CONST
CHANNEL 3
; TIME CONSTANT

132F 3E60
1331 D330
1333 3EA7
1335 D333
1337 3EFA
1339 D333

MVI
OUT
MVI
OUT
MVI
OUT

A,60H
30H
A,OA7H
33H
A,250
033H

IF

HARDSK

133B AF
133C 32EFOA
133F 32F10A

XRA

A

STA
STA

HSTACT
UNACNT

1342 219BOE
1345 360D

LXI
MVI
ENDIF

H,HSTBUF-1
M,OODH

1347 C9

RET

;

iZERO ACCUMULATOR
;SET HOST BUFFER INACTIVE
iSET UNALLOCATED COUNT TO Z
iSETUP WRITE CONTROL BYTE F
i

;

STMVTR:
1348 D309
134A 3EC3
134C 320000
134F 2A5E13
1352 220100
1355 2A6013
1358 77
1359 23
135A 73
135B 23
135C 72
135D C9

OUT
MVI
STA
LHLD
SHLD
LHLD
MOV
INX
MOV
INX
MOV
RET

MEMPORT
A,OC3H

o

,.

SVDJT

i

i

SET VECTORS FOR BDOS
JMP INSTRUCTION

1

SVDBPA
M,A
H

M,E
H

M,D

135E
1360

SVDJT: DS
SVDBPA: DS

1362 =
139D =
139D
139D 00

if
mpm20
xiosend equ
$
fdbuf
equ
(dirbuf-base) +256
org fdbuf+«xiosend-base)/fdbuf)*«xiosend-base)-fd
db
0
endif

139E

2
2

i

SAVED DIRECT JUMP TABLE ADDRESS
SAVED BREAK POINT ADDRESS

END

070F ADDERRORS
081E ALVO
091E ALV4
OA1E ALV8
0708 BADIO
081E BEGDAT
0220 CHKHRD

ODC6 ADRINTHD
085E ALV1
095E ALV5
OA5E ALV9
OD03 BANKNO
4000 BLKSIZ
06BC CHKSO

l2CE AFTERBANKS
089E ALV2
099E ALV6
OA9E ALVA
12BF BANK SETUP
067B CHECKIT
06C7 CHKSI

03DA ALLOC
08DE ALV3
09DE ALV7
OAC2 ALVB
0000 BASE
06AE CHECKSTAT
06CD CHKS2

All Information Presented Here is Proprietary to Digital Research
157

MP/M II System Guide

Appendix E

MP/M Banked XIOS

06E6 CHKS3
06F7 CHKS4
03A1 CHKUNA
OB2C CLIST
OB3B CLIST1
OAFA CMD
OB1F CNSTAT
OD9D CNTX
OB15 COLDSTART OB04 COMMONBASE OB84 CONIN
OB8F CONOUT
OB79 CONST
0080 CPMSPT
083E CSVO
087E CSV1
095E CSV4
099E CSV5
08FE CSV3
08BE CSV2
09DE CSV6
OA1E CSV7
OA5E CSV8
OA9E CSV9
OD04 CURMEM
001C DATAO
OAE6 CSVB
OAC2 CSVA
002E DATA2
002A DATA3
00B4 DBLKAD
002C DATAl
0519 DBLUPOATE 0782 DELI
0530 DBLSAVE
052E DBLLOW
0037 DENSITYMAS. OC02 OEVOK
0784 DEL2
0782 DELAY
OOAC OISKNO
FFFF DMA
129D DIRBUF
OCD5 DEVTBL
OOAF DMAADR
OOBE DMALEN
OOBA DMAS1
00C6 DMAS2F
OOCE DMAS3F
OOBC DMASA
OOCA DMAS3
OOCO DMAS2H
ODD4 DPBO
ODE3 DPB1
ODF2 DPB2
OE01 DPB3
OE2E DPB6
0001 DPBASE
OE1F DPB5
OE10 DPB4
00D1 DPEO
00E1 OPEl
00F1 OPE2
0101 OPE3
0121 DPE5
0131 DPE6
0141 DPE7
0111 DPE4
0161 OPE9
0151 DPE8
0171 OPEA
0181 DPEB
0552 OSKSEL
008E OSPTCH
00B2 DPEPTR
0790 OSCNO
0246 DTBLT
OAF6 ERFLAG
0010 EXITREGION 0000 FALSE
OB50 FDINTH
139D FDBUF
041C FILLHST
0763 FINTFIX
0085 FLAGST
0084 FLAGWT
OB47 FLOPPYINT 0687 FLOPPYIO
065C FLOPPYSEEK 0661 FPS1
1310 FPYBUF
0006 FPYFLAG
ODD2 FPYTCNT
0000 FPYTIME
073A FPYWAIT
0670 FSECSET
06AA FWT1
OB5E HAROINT
FFFF HARDSK
0005 HOFLAG
OB67 HDINTH
OB71 HDSTFLG
OOAE HEADNO
031A HOME
0337 HOME1
0340 HOME1A
0357 HOME2
0343 HOMEHARD
02F9 HOMEIT
0321 HOMESOFT
OB03 HOMETOGGLE 048F HRWO
0499 HRW1
04C4 HRW2
04CO HRW3
04D9 HRW4
04E1 HRW5
04E6 HRW6
0504 HRW7
OAEF HSTACT
0008 HSTBLK
OE9C HSTBUF
OAEA HSTOSK
OAED HSTSEC
0400 HSTSIZ
0010 HSTSPT
OAEB HSTTRK
OAFO HSTWRT
00B8 HTK1
07F8 INITENO
001A INT1HND
00B9 HTK2
OD67 INTDONE
005E INTERUPT
0721 INTFIX
007F INTINIT
0051 LAST
OD9E INTSTK
0620 LDH1
1700 LORBIOSBAS
OCA9 LIST
OCB8 LIST1
061E LOAOHEAO
001E LPTPRTO
001F LPTSTSO
0028 LPTPRT1
0029 LPTSTS1
00C6 LSTINTSTK
OAFB MASK
0439 MATCH
OD17 MAXCONSOLE OOOC MAXDSK
0009 MEMPORT
0000 MDISK
0002 MEMSK
OOBB MISCPARAMS
0088 MODE
130A MODESET
0191 MOOLO
019D MODL1
FFFF MPM20
OE7E MVOFB
00B6 MPARMS
01A9 MODL2
OAE6 NEWDSK
OAEE NEWHST
OE99 MVDFX
OE6B MVDTB
OAE9 NEWSEC
OAE7 NEWTRK
0461 NEWTRKCMP 0004 NMBCNS
0009 NMBDEV
075F NOFPYRST
0415 NOMATCH
0304 NOOVF
OD67 NOT1SEC
OD2F NOTICKN
OB1C NULLINT
OOAO PCNT
OBOD PDISP
0005 PLCIO
0006 PLCI1
0007 PLCI2
0008 PLCI3
0001 PLCOO
0002 PLC01
0003 PLC02
0004 PLC03
0000 PLLPT
0504 PNTFN
0501 PNTH2
05B3 POINT
OBAD POLCIO
OBEC POLCI1
OC2B POLCI2
OC6A POLCI3
OBDD POLCOO
OC1C POLC01
OC5B POLC02
0083 POLL
OCCB POLLDEVICE OCBC POLLPT
OC9A POLC03
ODCF PREEMP
OB01- PRETRIES
1307 PRTOK
OBB8 PTOIN
OBC5 PTOIN1
OBCA PTOOUT
OBD9 PTOOUT1
OBAO PTOST
OBF7 PT1IN
OC04 PT1IN1
OC09 PT10UT
OC18 PT10UT1
OBEC PT1ST
OC36 PT2IN
OC43 PT2IN1
OC48 PT20UT
All Information Presented Here is P~oprietary to Oigita1 Research
158

MP/M II System Guide

Appendix E

MP/M Banked XIOS

OC2B PT2ST
OC57 PT20UT1
OC87 PT30UT
OC96 PT30UTI
028B READ
036B READ HARD
05E4 READSOFT
0308 REALDISK
OAF7 RSFLAG
02EE RETMOD
03E2 RWOPER
OE3D RWMOVE
07Fl SDL1
07DE SDDBL
0003 SECSHF
00B1 SECTNO
0203 SELDSK
0242 SELERR
0556 SELSOFT
022F SELSDP
0544 SETDVD
0211 SETDSK
0273 SET SEC
02A1 SETMOD
05Al SLHI
0547 SHD1
0575 SLS3
0584 SLS4
0615 SRW2
0601 SRW1
ODOB STOPCLOCK
1348 STMVTR
002D STSI
001D STSO
1360 SVDBPA
ODC8 SVDHL
OBOA SWTSYS
ODCA SVDSP
129D SYSTEMINIT ODIA T20MS
12AF TESTBANKSE ODCE TICKN
OOAD TRAKNO
OB02 TRETRIES
OAF1 UNACNT
FFFF TRUE
OAF3 UNATRK
0717 WAITO
0001 WRDIR
0000 WRALL
05F2 WRITESOFT
046D WRITEHST
07F8 XETMOD
OB10 XDOS
01B5 XLTO
OlCF XLTI
0000 XLT4
0000 XLT5

OC75 PT3IN
OC82 PT3INI
OC6A PT3ST
OB9A PTBLJMP
OAF8 READOP
047F READHST
FFFF RELOC
0643 REMOVELD
OE60 RWEND
OBIA RTNEMPTY
07DO SDCONF
OAFD SAVEl
0007 SECMSK
07F3 SDOK
05D6 SECTRAN
007C SELO
OCE9 SELMEMORY
059B SELHARD
0255 SETDMA
0278 SETDEN
0532 SETHED
0540 SETH14
02C7 SETSEL
026D SETTRK
056B SLS2
055D SLSI
02E3 SMERR
0595 SLSERR
OD05 STARTCLOCK OAFC STATUS
05DB STRNI
05E2 STRN2
002B STS3
002F STS2
ODCC SVDRET
l35E SVDJT
OB13 SYSDAT
OB07 SWTUSER
OBA2 TBLJMP
0094 TCNT
OD22 TIMERINT
OD9C TOGCNT
064A TRKTST
0070 TRKO
OAF5 UNASEC
OAF2 UNADSK
OBIS WARMSTART 0003 WBOTE
037E WRITEHARD
0296 WRITE
OAF9 WRTYPE
0002 WRUAL
0801 XETSEL
1362 XIOSEND
OlCF XLT2
0000 XLT3
0000 XLT6

All Information Presented Here is Proprietary to Digital Research
159

Index
A

ALI field, 27
ALV, 25
attribute byte, 56
B

bank byte, 57
bank-switched memory, 55
banked resident system
process, 49
Basic Disk Operating System
(BOOS), 15, 48
BIOS, 15
BIOS devices, 16
BIOS disk definition, 29
BIOS Disk Definition Tables,
24
BIOS entry point, 15
BIOS jump table, 16
BIOS subroutines, 15, 17, 19,
20, 22, 23
BIOS WRITE entry point, 36
BLM field, 27
BLM values, 27
blocking and deblocking, 36
BLS, 28
BNKBDOS, 47, 48
BNKBDOS.SPR, 49
BNKXDOS, 47
BNKXIOS, 1, 3
BNKXIOS.SPR, 48
BOOT, 12
booting MP/M II, 6
bootstrap operation, 13
breakpoint, 6
breakpoint restart number, 53
BSH field, 27
BSH values, 27

c
character I/O, 15, 16
CKS field, 27
cks parameter, 31
CKS value, 29
cold start loader, 6, 7
common memory base page, 55
commonbase, 17

COMMONBASE subroutine, 33, 37
CONIN, 17
CONOUT, 18
consoles, 16
CONST, 17
copyright, 11
CSV, 25
custom generation of an MP/M
II boot, 8
custom resident system
processes, 49
customized XIOS, 47
D

dayfile logging, 55
DDT, 2, 4, 7, 47
debugging a resident system
process, 4
debugging an XIOS, 4, 5, 6
default entry values, 52
delay list, 44
dir parameter, 31
DIRBUF, 25
directory check information,
29
directory entries, 28
disk I/O, 15, 16
disk organization, 12, 13
Disk Parameter Block (DPB),
26, 29
Disk Parameter Headers (DPHs),
24, 25, 32
Disk Parameter Table Format,
24
DISKDEF, 24, 29, 30
disks, 16
dks parameter, 31
DMA address, 16
dn parameter, 31
DPB, 25
DPBASE, 25
DPH labels, 32
DRM, 28
DRM field, 27
DSM field, 27
E

END statement, 30
ENDEF macro, 30, 32

161

execution address,S, 7, 11
EXITREGION, 41
EXM field, 27
EXMvalues, 28
Extended Input/Output System
(XIOS), 39
external procedure access
code, 34
external procedure entry
points, 33

logical drives, 30
lsc parameter, 31
II

Flag Set, 44
flags, 43
fsc parameter, 31

MAC, 29
macro statements, 29
MAXCONSOLE, 42
memory map, 5, 56
memory segment table, 56
MP/M II Boot, 7
MP/M II nucleus, 49
MPM.SYS, 47
MPM.SYS file, 11
MPMLDR, 2, 6
MPMLDR display, 58

G

o

GENSYS, 51, 57
GETSYS, 6, 8,9

OFF field, 27, 29
ofa parameter, 31
one second flag, 44

p

B
p

header block, 32
HOME, 18

page address, 11
page relocatable files, 49
PDISP entry point, 35, 44
POLLDEVICE, 40
prm parameter, 31
process termination, 15
PUNCH, 18
PUTSYS, 6, 8, 10

I

IDLE process, 43
Intel MDS-800, 7, 12
interrupt service routines, 43
interrupts, 3

a

J

READ, 21
READER, 18
real time, 44
RESBDOS, 47, 48
RESBDOS.SPR, 48
resident system process, 47,
49, 56
restart number, 4
RES XI OS, 1,· 3
RESXIOS.SPR, 48
RET instruction, 15
RETI instruction, 44
RMAC, 29

jump addresses, 15
jump instructions, 15
jump vector, 15, 33
K

k16 parameter, 31
L

LDRBIOS, 1, 2, 3
licensing agreement, 11
LIST, 18
list devices, 16
LISTST, 23
load address, 7
loading MPM.SYS, 11
locked records, 54
logical devices, 15

s
sector allocation, 12
SECTRAN, 23
SEKDSK entry point, 36
SELDSK, 2, 16, 19, 25

162

SELMEMORY, 40
SETDMA, 20
SETSEC, 20
SETTRK, 20
SID, 2, 4, 7, 47
skew factor, 23
skew factor parameter, 32
skf parameter, 31
SPT field, 27
STARTCLOCK, 40
STAT, 33
STOPCLOCK, 41
SUBMIT, 54
subroutine, 1
SWTSYS, 22
SWTSYS entry point, 35
SWTUSER, 22
SWTUSER entry point, 35
SYSDAT entry, 35
SYSDAT page, 11
SYSGEN, 6, 7, 8
system data page, 35, 47, 56
system tick, 44, 45
SYSTEMINIT, 42

XIOS jump vector, 39
XLT, 25

z
Z80 CPU, 54

T

temporary file drive, 54
Terminal Message Processes
(TMPs), 53
time bases, 44
TMP, 47
top page of operating system,
53
trademark, 11
translation table, 32
translation vectors, 26

u
user memory segments, 55

w
WBOOT, 17
WRITE, 22
WRITESEC subroutines, 9

x
XDOS, 15, 47, 53
XDOS entry point, 35
XDOS.SPR, 49
XIOS, 1, 3, 15, 48
XIOS entry points, 15, 39

163

